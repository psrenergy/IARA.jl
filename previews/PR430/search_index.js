var documenterSearchIndex = {"docs":
[{"location":"tutorial/case_03_build_profile_base_case.html#Profile-Bid-Building","page":"Profile bids example","title":"Profile Bid - Building","text":"The data for this case is available in the folder data/case_3","category":"section"},{"location":"tutorial/case_03_build_profile_base_case.html#Market-Clearing-overview","page":"Profile bids example","title":"Market Clearing overview","text":"In the last two tutorials we have built cases with different components, including a hydro unit, and executed them in different run modes. In this tutorial, we will focus on one of the three run modes that we have seen earlier: MARKET_CLEARING.\n\nDuring MARKET_CLEARING, we have Asset Owners placing energy bids from their Bidding Groups. These bids are selected by the system to meet the demand at the lowest cost possible, considering the possible constraints that the problem might have.\n\nA possible configuration that a bid can have is to have a profile bid, where the price for the energy is the same for all subperiods in the study. Additionally, for profile bids, the system is obligated to accept the bid for all subperiods in the study.\n\nFor this tutorial we will be building a case with two Bidding Groups, where one of them has a profile bid.","category":"section"},{"location":"tutorial/case_03_build_profile_base_case.html#Case-overview","page":"Profile bids example","title":"Case overview","text":"The case will have the following characteristics:\n\nPeriods Subperiods Scenarios Subperiod duration (hours)\n1 2 1 1.0\n\nAnd for the bids we will set the maximum number of bidding segments and profiles to 1.\n\nWe'll start by importing the necessary packages.\n\nusing Dates\nusing Quiver\nusing DataFrames\nusing IARA\n; #hide\nnothing #hide\n\nDefining some constants\n\nnumber_of_periods = 1\nnumber_of_scenarios = 1\nnumber_of_subperiods = 2\nsubperiod_duration_in_hours = 1.0\nnumber_of_bidding_groups = 2\ncycle_duration_in_hours =\n    subperiod_duration_in_hours * number_of_subperiods * number_of_periods\n; #hide\nnothing #hide","category":"section"},{"location":"tutorial/case_03_build_profile_base_case.html#Creating-the-case","page":"Profile bids example","title":"Creating the case","text":"Just as we have done in the previous tutorials, we will start by creating a new case.\n\nconst PATH_BASE_CASE = joinpath(@__DIR__, \"data\", \"case_3\")\n\ndb = IARA.create_study!(PATH_BASE_CASE;\n    number_of_periods = number_of_periods,\n    number_of_scenarios = number_of_scenarios,\n    number_of_subperiods = number_of_subperiods,\n    initial_date_time = \"2020-01-01T00:00:00\",\n    subperiod_duration_in_hours = [\n        subperiod_duration_in_hours for _ in 1:number_of_subperiods\n    ],\n    policy_graph_type = IARA.Configurations_PolicyGraphType.LINEAR,\n    cycle_discount_rate = 0.0,\n    cycle_duration_in_hours = cycle_duration_in_hours,\n    demand_deficit_cost = 500.0,\n    demand_scenarios_files = IARA.Configurations_UncertaintyScenariosFiles.ONLY_EX_ANTE,\n)\n; #hide\nnothing #hide","category":"section"},{"location":"tutorial/case_03_build_profile_base_case.html#Zone-and-Bus","page":"Profile bids example","title":"Zone and Bus","text":"In this tutorial we are concerned only with highlighting the specifications of a clearing with profile bids. Therefore, we will be simplifying it by using a single zone and a single bus. We can add each of them by using the IARA.add_zone! and IARA.IARA.add_bus! functions.\n\nIARA.add_zone!(db; label = \"zone_1\")\nIARA.add_bus!(db; label = \"bus_1\", zone_id = \"zone_1\")","category":"section"},{"location":"tutorial/case_03_build_profile_base_case.html#Demand","page":"Profile bids example","title":"Demand","text":"This case will have a single demand, which we can add with the function IARA.add_demand_unit!.\n\nIARA.add_demand_unit!(db;\n    label = \"dem_1\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [1],\n    ),\n    bus_id = \"bus_1\",\n    max_demand = 0.03,\n)\n\nWe can now link the time series files for the demand to the database. You can find this time series file in the data/case_3 folder. Let's take a quick look at the file.\n\nIARA.time_series_dataframe(joinpath(PATH_BASE_CASE, \"demand.csv\"))\n\nIARA.link_time_series_to_file(\n    db,\n    \"DemandUnit\";\n    demand_ex_ante = \"demand\",\n)","category":"section"},{"location":"tutorial/case_03_build_profile_base_case.html#Asset-Owners-and-Bidding-Groups","page":"Profile bids example","title":"Asset Owners and Bidding Groups","text":"For this case, we will be demonstrating the differences of a profile bid offer and an independent bid offer. Thus, we will create two Bidding Groups, one for each type of bid, and link them to the same Asset Owner.\n\nWe can add an Asset Owner with the function IARA.add_asset_owner!.\n\nIARA.add_asset_owner!(db;\n    label = \"asset_owner_1\",\n)\n\nNow we can define its Bidding Groups with IARA.add_bidding_group!.\n\nIARA.add_bidding_group!(db;\n    label = \"bg_1\",\n    assetowner_id = \"asset_owner_1\",\n)\n\nIARA.add_bidding_group!(db;\n    label = \"bg_2\",\n    assetowner_id = \"asset_owner_1\",\n)\n\nAfter adding the Bidding Groups, we can link the time series files for the price and quantity bids. Let's take a look at each of these files before linking them.","category":"section"},{"location":"tutorial/case_03_build_profile_base_case.html#Quantity-Offer","page":"Profile bids example","title":"Quantity Offer","text":"IARA.time_series_dataframe(joinpath(PATH_BASE_CASE, \"quantity_bid.csv\"))","category":"section"},{"location":"tutorial/case_03_build_profile_base_case.html#Price-Offer","page":"Profile bids example","title":"Price Offer","text":"IARA.time_series_dataframe(joinpath(PATH_BASE_CASE, \"price_bid.csv\"))\n\nIARA.link_time_series_to_file(\n    db,\n    \"BiddingGroup\";\n    quantity_bid = \"quantity_bid\",\n    price_bid = \"price_bid\",\n)\n\nWe have just added the time series for the independent bids. Now let's check the profile bids and link them to our case.","category":"section"},{"location":"tutorial/case_03_build_profile_base_case.html#Quantity-Offer-2","page":"Profile bids example","title":"Quantity Offer","text":"IARA.time_series_dataframe(\n    joinpath(PATH_BASE_CASE, \"quantity_bid_profile.csv\"),\n)","category":"section"},{"location":"tutorial/case_03_build_profile_base_case.html#Price-Offer-2","page":"Profile bids example","title":"Price Offer","text":"IARA.time_series_dataframe(\n    joinpath(PATH_BASE_CASE, \"price_bid_profile.csv\"),\n)\n\nIARA.link_time_series_to_file(\n    db,\n    \"BiddingGroup\";\n    quantity_bid_profile = \"quantity_bid_profile\",\n    price_bid_profile = \"price_bid_profile\",\n)","category":"section"},{"location":"tutorial/case_03_build_profile_base_case.html#Generation-Units","page":"Profile bids example","title":"Generation Units","text":"IARA.add_thermal_unit!(db;\n    label = \"ter_1\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = 1,\n        min_generation = 0.0,\n        max_generation = 50.0,\n        om_cost = 20.0,\n    ),\n    biddinggroup_id = \"bg_1\",\n    has_commitment = 0,\n    bus_id = \"bus_1\",\n)\n\nIARA.add_thermal_unit!(db;\n    label = \"ter_2\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = 1,\n        min_generation = 0.0,\n        max_generation = 20.0,\n        om_cost = 10.0,\n    ),\n    biddinggroup_id = \"bg_2\",\n    has_commitment = 0,\n    bus_id = \"bus_1\",\n)","category":"section"},{"location":"tutorial/case_03_build_profile_base_case.html#Closing-the-case","page":"Profile bids example","title":"Closing the case","text":"IARA.close_study!(db)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"heuristic_bid_examples.html#Heuristic-Bid-Examples","page":"Heuristic bids examples","title":"Heuristic Bid Examples","text":"This section is a follow-up of the Introduction: Bid structures and bid data chapter, where we introduced different bid formats.\n\nThe heuristic bid generation differs based on the type of assets that an agent's bidding group contains. Here, we will present examples of how the heuristic bid is generated for different types of bidding groups. For the mathematical formulation of the heuristic bid, please refer to the Heuristic Bid chapter.","category":"section"},{"location":"heuristic_bid_examples.html#Only-thermal-units","page":"Heuristic bids examples","title":"Only thermal units","text":"When considering a bidding group with only thermal units, the heuristic bid is evaluated based on the operational cost and maximum generation of the assets that compose it.\n\nThe resulting bid will divided into segments, where the price for each segment corresponds to the operational cost of a thermal unit in the bidding group, always orderd from the cheapest to the most expensive, and the quantity for each segment corresponds to the maximum generation of the thermal unit in the bidding group.\n\nFor instance, consider that we have two thermal units witht the following characteristics:\n\nThermal Unit Max Generation (MW) Operational Cost (/MWh)\nT1 50 30.0\nT2 100 40.0\n\nThe heuristic bid will have the following structure:","category":"section"},{"location":"heuristic_bid_examples.html#Price-bid","page":"Heuristic bids examples","title":"Price bid","text":"period scenario subperiod bid_segment bg1 - bus1\n1 1 1 1 30.0\n1 1 1 2 40.0","category":"section"},{"location":"heuristic_bid_examples.html#Quantity-bid","page":"Heuristic bids examples","title":"Quantity bid","text":"period scenario subperiod bid_segment bg1 - bus1\n1 1 1 1 50\n1 1 1 2 100","category":"section"},{"location":"heuristic_bid_examples.html#Using-markup-factors","page":"Heuristic bids examples","title":"Using markup factors","text":"When using markup factors, the price bid is calculated by increasing the operational cost of the thermal unit by the markup factor (cost * (1 + markup factor)).  The markup factor is a global parameter for all assets in a bidding group. It can be used to make more complex bidding strategies, by dividing the bids originated from a single asset into multiple segments, each with a different markup factor. Also, each segment is assigned a different portion of the generation, which is used to calculate the quantity bid.\n\nUsing the same example as before, consider that we have the following markup factors:\n\nbid_segment Portion of the generation (%) Markup factor (%)\n1 40.0 20.0\n2 60.0 30.0\n\nThen, for example, T1 will be bidding 40% of its generation in the first segment for a price of 36.0 $/MWh and 60%  of its generation in the second segment for a price of 39.0 $/MWh.\n\nThe heuristic bid will have the following structure:","category":"section"},{"location":"heuristic_bid_examples.html#Price-bid-2","page":"Heuristic bids examples","title":"Price bid","text":"period scenario subperiod bid_segment bg1 - bus1\n1 1 1 1 36.0 (T1)\n1 1 1 2 39.0 (T1)\n1 1 1 3 48.0 (T2)\n1 1 1 4 52.0 (T2)","category":"section"},{"location":"heuristic_bid_examples.html#Quantity-bid-2","page":"Heuristic bids examples","title":"Quantity bid","text":"period scenario subperiod bid_segment bg1 - bus1\n1 1 1 1 20.0 (T1)\n1 1 1 2 30.0 (T1)\n1 1 1 3 40.0 (T2)\n1 1 1 4 60.0 (T2)\n\nnote: Code snippet\nIn order to create a bidding group with markup bids, you can use the following code example:IARA.add_bidding_group!(\n    db;\n    label = \"Thermal Owner\",\n    assetowner_id = \"Thermal Owner\",\n    risk_factor = [0.2, 0.3],\n    segment_fraction = [0.4, 0.6],\n)","category":"section"},{"location":"heuristic_bid_examples.html#Only-renewable-units","page":"Heuristic bids examples","title":"Only renewable units","text":"When considering a bidding group with only renewable units, the heuristic bid is evaluated based on the maximum generation, operational cost and the expected generation of the assets that compose it.\n\nThe expected generation, which is given in p.u., is a forecast of the generation that the renewable unit will produce in the next period. For our example, we will be working with a time horizon of 1 period, 2 scenarios and 2 subperiods. Consider the following forecast of expected generation for the renewable units Renewable1 and Renewable2:\n\nperiod scenario subperiod R1 R2\n1 1 1 0.5 0.7\n1 1 2 0.4 0.6\n1 2 1 0.6 0.8\n1 2 2 0.3 0.5\n\nAlso, consider the following characteristics of the renewable units:\n\nRenewable Unit Max Generation (MW) Operational Cost (/MWh)\nR1 100 30.0\nR2 100 40.0\n\nAs seen in the previous example for thermal units, the heuristic bid for this case will also be divided into segments, where the price for each segment corresponds to the operational cost of a renewable unit in the bidding group and the quantity for each segment corresponds to the expected generation of the renewable unit (in p.u.) multiplied by the maximum generation of the renewable unit.","category":"section"},{"location":"heuristic_bid_examples.html#Price-bid-3","page":"Heuristic bids examples","title":"Price bid","text":"period scenario subperiod bid_segment bg1 - bus1\n1 1 1 1 30\n1 1 1 2 40\n1 1 2 1 30\n1 1 2 2 40\n1 2 1 1 30\n1 2 1 2 40\n1 2 2 1 30\n1 2 2 2 40","category":"section"},{"location":"heuristic_bid_examples.html#Quantity-bid-3","page":"Heuristic bids examples","title":"Quantity bid","text":"period scenario subperiod bid_segment bg1 - bus1\n1 1 1 1 50.0\n1 1 1 2 70.0\n1 1 2 1 40.0\n1 1 2 2 60.0\n1 2 1 1 60.0\n1 2 1 2 80.0\n1 2 2 1 30.0\n1 2 2 2 50.0","category":"section"},{"location":"build_a_case_from_scratch.html#Introduction:-Building-a-case-from-scratch","page":"Introduction","title":"Introduction: Building a case from scratch","text":"The best way to learn is by doing - we encourage you to explore the tutorial for the construction of a simple case. This page explains conceptually the step by step process that is followed in each of these examples in order to build each of the key components of a IARA database, which should be applicable to any type of case.","category":"section"},{"location":"build_a_case_from_scratch.html#Building-the-temporal-structure","page":"Introduction","title":"Building the temporal structure","text":"Given that intertemporality is a key component of realistic electricity systems IARA is meant to represent, having a well-defined temporal structure is a key component for IARA execution, as this profoundly affects the decision-making process in the model. The fundamental language for the representation of this temporal structure is the \"Policy graph\", as described in detail in the SDDP.jl documentation. Further explorations of the options available for constructing a Policy Graph in IARA are presented in a dedicated page that introduces the complexities associated with the Policy Graph representation step by step.\n\nPolicy graph parameters are usually passed directly when calling the create_study! function, with the following key parameters being related to policy graph construction. Please refer to IARA's standard nomenclature for further explanations on the jargon used (e.g. subperiods, seasons, cycles, etc.):\n\nnumber_of_subperiods is an integer that indicates how many subperiods are included when simulating each period. Note that a \"period\" represents a block of decisions made at once (e.g. looking at an entire day, week, month, etc.) and a \"subperiod\" corresponds to subdivisions within that period for simulation and optimization purposes (e.g. broken down into days, hourly intervals, 15-minute intervals, etc.)\nsubperiod_duration_in_hours is a vector that indicates the length of each subperiod - therefore, the length of this vector corresponds to the number of subperiods represented. The duration of each \"representative subproblem\" will be equal to the sum of the elements in the subperiod_duration_in_hours. Each season's representative subproblem will have the same duration.\nexpected_number_of_repeats_per_node is a vector that indicates, for each season, how many times the \"representative subproblem\" is expected to repeat in order to constitute the total length of the season. This must be a number greater than or equal to one (but can be fractional), and the expected duration of the season as a whole is equal to the product of all three parameters: the subperiod_duration_in_hours, the  number_of_subperiods, and the expected_number_of_repeats_per_node.\ncycle_duration_in_hours is a real number that can be used either to validate the total duration of the cycle (calculated from adding up the expected duration as a whole of each season as described above) or to introduce an adjustment multiplier. Note that if the cycle represents one year, this parameter should always be equal to 8760 hours, but it is useful to have the flexibility to change this definition.\ncycle_discount_rate is a real number that describes how much future periods are discounted relative to the present, expressed as a discrete one-time discount after the entire duration of a cycle (which is a common way to express this parameter in economic applications). In practice, IARA will distribute this yearly discount rate as a discount that is applied after each season's representative subproblem (based on the corresponding duration), in such a way that the cumulative effect over the course of a period with length equal to cycle_duration_in_hours is equivalent to applying the cycle_discount_rate.\npolicy_graph_type is an enumeration parameter that allows for different policy graph representation paradigms. IARA's default representation is a \"cyclic\" policy graph.\n\nWhen calling the create_study! function, it is also possible to define additional parameters that describe the dimensions of the study execution, as detailed below (once again, refer to this page for nomenclature and definitions). One important distinction is that, while the parameters used to define the policy graph are in a sense more \"fundamental\" in describing the physical nature of the problem, the number of periods, scenarios and subscenarios in essence represent a choice of how many samples one wishes to model, taking into account computational limitations. Nonetheless, these parameters will have an influence when building time series data to finalize the database creation:\n\nnumber_of_periods represents how many subproblems (representative of each season) will be modeled sequentially in the execution\nnumber_of_scenarios represents how many subproblems (representative of each season) will be modeled in parallel (i.e. representing independent trajectories) in the execution\nnumber_of_subscenarios represents how many \"openings\" of each trajectory (represented by the \"scenarios\") will be modeled, with an impact on the structure of subproblems to be modeled\n\nNote that the output of the create_study! function is a database object, db. In all subsequent steps for creating the database, the db object is the first parameter that ought to be passed for most functions (marked by a ! as the last character of the function signature).","category":"section"},{"location":"build_a_case_from_scratch.html#Building-the-spatial-structure","page":"Introduction","title":"Building the spatial structure","text":"The spatial structure is characterized by a network of buses organized into zones. The entities that characterize the spatial structure are created by calling the following functions:\n\nadd_zone! introduces a Zone to the study\nadd_bus! introduces a Bus to the study and links it to a Zone\nadd_dc_line! introduces a connection in direct current (DC) to the study, linking it to the two buses that are connected by this physical line (a \"starting\" bus and an \"ending\" bus), and defining relevant physical parameters for modelling the line's physical features\nadd_branch! introduces an electrical connection (a transmission line in alternate current or a transformer) to the study, linking it to the two buses that are connected by this physical line (a \"starting\" bus and an \"ending\" bus), and defining relevant physical parameters for modelling the branch's physical features\n\nBecause all Units will later need to be placed in this spatial structure, this is a fundamental component for input data. Conceptually, the system operator's optimization problem for making economic dispatch decisions in an electricity system can either be constructed on a \"zonal\" basis (with one supply-demand balance constraint per zone) or on a \"nodal\" basis (with one supply-demand balance constraint per bus). Note that DC lines and Branches effectively represent \"arcs\" in the representation of the spatial graph, and these are assumed to be fully under the control of the system operator as long as they remain within the physical limits characterized by the lines' parameters and physical laws.","category":"section"},{"location":"build_a_case_from_scratch.html#Building-the-ownership-structure","page":"Introduction","title":"Building the ownership structure","text":"The ownership structure is characterized by (i) a number of bidding groups, (ii) a number of virtual reservoirs, and (iii) a number of asset owners. The entities that characterize the ownership structure are created by calling the following functions:\n\nadd_asset_owner! introduces an Asset Owner to the study, potentially indicates that this particular agent operates as a \"pricemaker\" when making strategic decisions (with the default behavior being \"pricetaker\"), and potentially defines additional parameters useful for building the agent's preferred \"pricemaker\" strategy.\nadd_virtual_reservoir! introduces a Virtual Reservoir to the study, and indicates which asset owners are registered to make virtual reservoir bids on this virtual reservoir. Note that the relationship between virtual reservoirs and asset owners is one-to-many, and a \"virtual reservoir account\" is characterized by the combination of a virtual reservoir and an asset owner.\nadd_bidding_group! introduces a Bidding Group to the study, linking it to a single asset owner responsible for submitting the associated bids, and introducing parameters relevant for describing heuristic bid strategies specific for the bidding group.\n\nNote that Units will later be associated to Bidding Groups (mandatorily) and Virtual Reservoirs (restricted to hydro-type units, optionally). Even though in a cost-based market structure the asset owner's strategy does not play a role, pricemaker asset owners may be able to influence the market outcomes under a bid-based market structure in accordance with their preferences. In practice, an asset owner will seek to maximize their profits (possibly adjusted for some preference parameters), taking into account the joint effect of bidding strategies applied in all bidding groups and all virtual reservoir accounts under the control of that asset owner.","category":"section"},{"location":"build_a_case_from_scratch.html#Building-the-unit-structure","page":"Introduction","title":"Building the unit structure","text":"\"Units\" refer to any type of physical asset connected to the system which can be under the control of an asset owner. While the diversity of Units that could potentially be contemplated in IARA is very high (with highly complex parameterizations), the current implementation focuses on four types of unit, which can be created using the following functions:\n\nadd_renewable_unit! introduces a Renewable Unit to the study (representing a technology such as wind or solar, with variable and curtailable resource), links it to a Bus in the spatial structure and to a Bidding Group in the ownership structure, and defines additional physical parameters.\nadd_hydro_unit! introduces a Hydro Unit to the study (representing a technology that has a variable resource with some flexibility to transfer resource between subperiods and/or periods), links it to a Bus in the spatial structure and to a Bidding Group in the ownership structure, and defines additional parameters.\nadd_thermal_unit! introduces a Thermal Unit to the study (representing a technology that is more dispatchable/controllable, with parameters aiming to describe its degree of controllability), links it to a Bus in the spatial structure and to a Bidding Group in the ownership structure, and defines additional parameters.\nadd_demand_unit! introduces a Demand Unit to the study (which typically contributes to the supply-demand balance equation with a negative sign, contrary to the other UNits above), links it to a Bus in the spatial structure and to a Bidding Group in the ownership structure, and defines additional parameters.\n\nNote that each Unit has its own set of complex and thorough parameters, which can be assessed in the API reference. However, they all share the same basic structure of fundamentally linking to the spatial structure and the ownership structure.","category":"section"},{"location":"build_a_case_from_scratch.html#Building-external-data-structures","page":"Introduction","title":"Building external data structures","text":"\"External data structures\" refer to information that is available in separate files (usually in an easy-to-manipulate csv format), which the IARA database links to and accesses in order to build individual optimization subproblems. These external files can contain detailed information that varies per period, subperiod, scenario and subscenario following the study's temporal structure.\n\nThese external links can be classified into three main groups:\n\nThe first group corresponds to physical time series data, and contains information that is associated to Units with a stochastic dependency. Most prominently, this group includes the representation of demand fluctuations (tied to Demand Units), renewable production fluctuations (tied to Renewable Units), and inflow availability fluctuations (tied to Hydro Units).\nThe second group corresponds to bid time series data, and contains information that is associated to the different types of bid that can be submitted by the agents, as described in detail in a dedicated page describing the bidding formats available.\nA third group is more \"miscellaneous\", and includes other types of data that can be linked by the IARA database. One example of this category is the \"curve guide\" parameter inputs, which is used in the virtual reservoir representation as a \"tiebreaker\" function.\n\nGenerally speaking, in case a csv file has been pre-generated with the required structure of rows and columns (as exemplified in our practical examples), it is possible to link this external data structure to the database using the link_time_series_to_file function, following the indications shown in our API reference.","category":"section"},{"location":"development_guides.html#Development-guides","page":"Development guides","title":"Development guides","text":"This section contains guides for developers who want to contribute to the development of the project.","category":"section"},{"location":"development_guides.html#How-to-add-a-new-collection","page":"Development guides","title":"How to add a new collection","text":"The database definition of IARA.jl is based on the standards described in the PSRDatabaseSQLite documentation page.\n\nThe first step to add a new collection is to define the tables, attributes and relationships as a migration in the database/migrations folder.\n\nAfter defining the new collection in the migration file the next step is to create a new collection type in the src/collections folder. The new collection should be a subtype of the AbstractCollection type and should implement at least the following functions:\n\ninitialize!(my_new_collection::MyNewCollection, inputs::AbstractInputs)\nadd_my_new_collection!(db::DatabaseSQLite; kwargs...)\nupdate_my_new_collection!(db::DatabaseSQLite, label::String; kwargs...)\nvalidate(my_new_collection::MyNewCollection, inputs::AbstractInputs)\nadvanced_validations(my_new_collection::MyNewCollection, inputs::AbstractInputs)\n\nThe last step is to add the new collection to the IARA.Collections type.","category":"section"},{"location":"development_guides.html#How-to-add-a-new-time-series-from-external-file","page":"Development guides","title":"How to add a new time series from external file","text":"Whenever a time series varies with time and scenario we advise it to be loaded into the inputs using the IARA.ViewFromExternalFile abstraction. \n\nThe first step to create a new time series from external file is to define a time series file in the schema, developers can follow the PSRDatabaseSQLite documentation page to define the time series file.\n\nOnce the time series file is defined in the schema and read into a collection developers should add a new field to the IARA.TimeSeriesViewsFromExternalFiles struct. The new field should be a subtype of the IARA.ViewFromExternalFile and could be an existing subtype or a new subtype.\n\nAfter adding the new field developers should initialize it in the IARA.initialize_time_series_from_external_files function. When making this implementation developers should always pass the expected unit and labels of the time series.","category":"section"},{"location":"development_guides.html#How-to-add-a-new-mathematical-model-element","page":"Development guides","title":"How to add a new mathematical model element","text":"Mathematical model elements are the building subperiods of the different possible optimization problems. They are defined in the src/model_variables or src/model_constraints folders. To add a new mathematical model element, developers should create a new file in the respective folder and define at least the following functions:\n\nmy_new_model_element!(\n    model::SubproblemModel,\n    inputs::Inputs,\n    run_time_options::RunTimeOptions,\n    ::Type{SubproblemBuild},\n)\n\nmy_new_model_element!(\n    model::SubproblemModel,\n    inputs::Inputs,\n    run_time_options::RunTimeOptions,\n    scenario::Int,\n    subscenario::Int,\n    ::Type{SubproblemUpdate},\n)\n\nmy_new_model_element!(\n    outputs::Outputs,\n    inputs::Inputs,\n    run_time_options::RunTimeOptions,\n    ::Type{InitializeOutput},\n)\n\nmy_new_model_element!(\n    outputs::Outputs,\n    inputs::Inputs,\n    run_time_options::RunTimeOptions,\n    simulation_results::SimulationResultsFromPeriodScenario,\n    period::Int,\n    scenario::Int,\n    subscenario::Int,\n    ::Type{WriteOutput},\n)\n\nEach one of these functions performs an action that is specific to the phase of the execution that it is executing at the time. The documentation for each action is available here:\n\nIARA.SubproblemBuild.\nIARA.SubproblemUpdate.\nIARA.InitializeOutput.\nIARA.WriteOutput.\n\nAfter defining the new model element, developers should add the varargs function of the new model element to the respective optimization problem action function defined in the src/mathematical_model.jl file.","category":"section"},{"location":"development_guides.html#How-to-add-a-new-post-processing-function","page":"Development guides","title":"How to add a new post-processing function","text":"All post-processing functions are defined in the src/post_processing folder. To add a new post-processing function, developers should create a new file in the src/post_processing folder and add the new function in the scope of IARA.post_processing.","category":"section"},{"location":"development_guides.html#How-to-add-a-new-plot","page":"Development guides","title":"How to add a new plot","text":"All plots are defined in the src/plots folder. To add a new plot, developers should add a new IARA.PlotConfig in the IARA.build_plots function. \n\nIf a developer wants to implement a new plot type, they should create a new file in the src/plots folder and define the new plot type. The new plot type should be a concrete subtype of the IARA.PlotType abstraction and should implement the IARA.plot_data function for the corresponding new plot type.\n\nexample:\n\nplot_data(\n    ::Type{MyNewPlotType},\n    data::Array{T, N},\n    agent_names::Vector{String},\n    dimensions::Vector{String};\n    title::String = \"\",\n    unit::String = \"\",\n    file_path::String,\n) where {T <: AbstractFloat, N}","category":"section"},{"location":"contributing.html#Contributing","page":"Contributing","title":"Contributing","text":"IARA.jl is an open-source project, and we welcome contributions from the community. Whether you are a seasoned developer or a newcomer, your contributions are valuable to us. We follow JuMP's contribution guidelines in addition to some specific instructions that are detailed below.","category":"section"},{"location":"contributing.html#Code-of-Conduct","page":"Contributing","title":"Code of Conduct","text":"Please refer to the Code of Conduct for guidelines on how to interact with the community.","category":"section"},{"location":"contributing.html#Improve-the-documentation","page":"Contributing","title":"Improve the documentation","text":"The documentation is written in Markdown using Documenter.jl and Literate.jl. The source code for the documentation can be found here. Please refer to the Style guide for more details on how to write documentation.\n\nIn order to generate the documentation locally, you can run the following command in the root directory of the project:\n\njulia --project=docs 'docs/make.jl'","category":"section"},{"location":"contributing.html#File-a-bug-report-or-feature-request","page":"Contributing","title":"File a bug report or feature request","text":"If you encounter a bug or have a feature request, please file an issue on our GitHub Issues page. \n\nWhen filing a bug report, please include:\n\nA clear and descriptive title.\nA link (google drive, dropbox, etc.) to the files of the case you are working on.\nSteps to reproduce the issue.\nThe expected behavior and what actually happens.\nAny relevant error messages or stack traces.\nYour Julia version and operating system details.\n\nProviding this information will help us address the issue more efficiently. Thank you for your feedback!","category":"section"},{"location":"tutorial/case_01_run_base_case.html#Base-Case-Running","page":"Base Case - Running","title":"Base Case - Running","text":"The data for this case is available in the folder data/case_1\n\nusing Dates\nusing DataFrames\nusing IARA\n; #hide\nnothing #hide\n\nIn the last tutorial, we built a simple case with the following characteristics:\n\nPeriods Subperiods Scenarios Subperiod duration (hours) Yearly discount rate\n2 1 4 24 10%\n\nTechnology Name Owner Maximum Generation (MW) Cost ($/MWh)\nRenewable Solar1 Price Taker 80 \nThermal Thermal1 Thermal Owner 20 10\nThermal Thermal2 Price Taker 20 30\nThermal Thermal3 Thermal Owner 20 100\nThermal Thermal4 Price Taker 20 300\nThermal Thermal5 Price Taker 50 1000\nThermal Thermal6 Price Taker 50 3000\n\nNow, we will run this case in two different run modes: TRAIN_MIN_COST and MARKET_CLEARING.\n\nFirst, let's create separate folders inside a case_1_execution folder for each case and copy the base case to the centralized and market_clearing folders.\n\nconst PATH_ORIGINAL = joinpath(@__DIR__, \"data\", \"case_1\")\n\nconst PATH_EXECUTION = joinpath(@__DIR__, \"case_1_execution\")\nif !isdir(PATH_EXECUTION)\n    mkdir(PATH_EXECUTION)\nend\n\nconst PATH_CENTRALIZED = joinpath(PATH_EXECUTION, \"centralized\")\nconst PATH_MARKET_CLEARING = joinpath(PATH_EXECUTION, \"market_clearing\")\n\nif !isdir(PATH_CENTRALIZED)\n    mkdir(PATH_CENTRALIZED)\nend\nif !isdir(PATH_MARKET_CLEARING)\n    mkdir(PATH_MARKET_CLEARING)\nend\n\ncp(PATH_ORIGINAL, PATH_CENTRALIZED; force = true);\ncp(PATH_ORIGINAL, PATH_MARKET_CLEARING; force = true);\nnothing #hide","category":"section"},{"location":"tutorial/case_01_run_base_case.html#Centralized-Operation","page":"Base Case - Running","title":"Centralized Operation","text":"Now we are able to run the case with IARA.train_min_cost.\n\nIARA.train_min_cost(PATH_CENTRALIZED)","category":"section"},{"location":"tutorial/case_01_run_base_case.html#Analyzing-the-results","page":"Base Case - Running","title":"Analyzing the results","text":"After running the case, the outputs are saved in the outputs folder inside the case folder. Inside this directory, you will find the raw results and some plots (inside the plots subdirectory).\n\ncase_folder\n ├── outputs\n │    ├── plots\n │    │   └── ...\n │    └── ...\n └── ...\n\nHaving access to all the outputs, we can visualize the data as we would like. However, IARA already plots some of the outputs for us and saves it inside the plots folder.\n\nLet's take a look into some of the plots generated automatically.\n\n<iframe src=\"case_1_execution\\\\centralized\\\\outputs\\\\plots\\\\load_marginal_cost_all.html\" style=\"height:500px;width:100%;\"></iframe>\n\n<iframe src=\"case_1_execution\\\\centralized\\\\outputs\\\\plots\\\\renewable_generation_all.html\" style=\"height:500px;width:100%;\"></iframe>\n\n<iframe src=\"case_1_execution\\\\centralized\\\\outputs\\\\plots\\\\thermal_generation_all.html\" style=\"height:500px;width:100%;\"></iframe>","category":"section"},{"location":"tutorial/case_01_run_base_case.html#Market-Clearing","page":"Base Case - Running","title":"Market Clearing","text":"Let's load the case with IARA.load_study. As we are updating the run mode, we need to open it using read_only = false.\n\ndb = IARA.load_study(PATH_MARKET_CLEARING; read_only = false);\n#hide\n\nIn order to run the case in Market Clearing, we need to set the run mode and the clearing bid source (where the bid quantity and price offers will come from). For this example we will be using parameterized heuristic bids without validation. This setting will automatically generate bids for each Bidding Group. We can set these parameters in the configurations, with IARA.update_configuration!.\n\nIARA.update_configuration!(\n    db;\n    bid_processing = IARA.Configurations_BidProcessing.PARAMETERIZED_HEURISTIC_BIDS,\n    bid_price_validation = IARA.Configurations_BidPriceValidation.DO_NOT_VALIDATE,\n    construction_type_ex_ante_physical = IARA.Configurations_ConstructionType.HYBRID,\n    construction_type_ex_ante_commercial = IARA.Configurations_ConstructionType.HYBRID,\n    construction_type_ex_post_physical = IARA.Configurations_ConstructionType.HYBRID,\n    construction_type_ex_post_commercial = IARA.Configurations_ConstructionType.HYBRID,\n)\nIARA.close_study!(db)\n\nNow we are able to run the case with IARA.market_clearing.\n\nIARA.market_clearing(\n    PATH_MARKET_CLEARING;\n    delete_output_folder_before_execution = true,\n)\n\nLet's take a look into some of the plots generated automatically.\n\n<iframe src=\"case_1_execution\\\\market_clearing\\\\outputs\\\\plots\\\\bidding_group_price_bid_all.html\" style=\"height:500px;width:100%;\"></iframe>\n\n<iframe src=\"case_1_execution\\\\market_clearing\\\\outputs\\\\plots\\\\bidding_group_energy_bid_all.html\" style=\"height:500px;width:100%;\"></iframe>\n\n<iframe src=\"case_1_execution\\\\market_clearing\\\\outputs\\\\plots\\\\bidding_group_generation_ex_ante_commercial_all.html\" style=\"height:500px;width:100%;\"></iframe>\n\n<iframe src=\"case_1_execution\\\\market_clearing\\\\outputs\\\\plots\\\\bidding_group_generation_ex_post_commercial_all.html\" style=\"height:500px;width:100%;\"></iframe>\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"tutorial/case_05_run_reservoir_case.html#Virtual-Reservoir-Running","page":"Virtual Reservoir - Running","title":"Virtual Reservoir - Running","text":"The data for this case is available in the folder data/case_5\n\nusing Dates\nusing DataFrames\nusing IARA\n; #hide\nnothing #hide","category":"section"},{"location":"tutorial/case_05_run_reservoir_case.html#Case-recap","page":"Virtual Reservoir - Running","title":"Case recap","text":"In the previous section, we have built a case containing a virtual reservoir with two hydro units and two asset owners. Now we will run this case using the MARKET_CLEARING mode.\n\nAs we have Hydro Units in this case, we need the hydro generation and hydro opportunity cost time series files. We can automatically generate them by running the case with the TRAIN_MIN_COST mode. We will be doing this before running the case in the MARKET_CLEARING mode.\n\nLet's create a folder to store the output of the MARKET_CLEARING mode and define the path to the original case.\n\nconst PATH_ORIGINAL = joinpath(@__DIR__, \"data\", \"case_5\")\nconst PATH_EXECUTION = joinpath(@__DIR__, \"case_5_execution\")\n\nif !isdir(PATH_EXECUTION)\n    mkdir(PATH_EXECUTION)\nend\n\ncp(PATH_ORIGINAL, PATH_EXECUTION; force = true);\n#hide","category":"section"},{"location":"tutorial/case_05_run_reservoir_case.html#Executing","page":"Virtual Reservoir - Running","title":"Executing","text":"","category":"section"},{"location":"tutorial/case_05_run_reservoir_case.html#Adding-Hydro-time-series","page":"Virtual Reservoir - Running","title":"Adding Hydro time series","text":"Now we are able to run the case with IARA.train_min_cost.\n\nIARA.train_min_cost(\n    PATH_EXECUTION;\n    delete_output_folder_before_execution = true,\n)\n\nAfter that, we have to move the cost-to-go function cuts file to the case_5_execution folder.\n\nfcf_cuts_file = joinpath(\n    PATH_EXECUTION,\n    \"outputs\", \"cuts.json\",\n)\n\nfcf_cuts_destination = joinpath(PATH_EXECUTION, \"cuts.json\")\n\nmv(fcf_cuts_file, fcf_cuts_destination; force = true)\n#hide\n\nNow we are ready to run the case in the MARKET_CLEARING mode.\n\nAs we need to set the run mode to MARKET_CLEARING, we need to open the study again.\n\ndb = IARA.load_study(PATH_EXECUTION; read_only = false);\n\nIARA.update_configuration!(\n    db;\n    bid_processing = IARA.Configurations_BidProcessing.READ_BIDS_FROM_FILE,\n    bid_price_validation = IARA.Configurations_BidPriceValidation.DO_NOT_VALIDATE,\n    construction_type_ex_ante_physical = IARA.Configurations_ConstructionType.HYBRID,\n    construction_type_ex_ante_commercial = IARA.Configurations_ConstructionType.HYBRID,\n    construction_type_ex_post_physical = IARA.Configurations_ConstructionType.HYBRID,\n    construction_type_ex_post_commercial = IARA.Configurations_ConstructionType.HYBRID,\n)\n\nIARA.link_time_series_to_file(\n    db,\n    \"Configuration\";\n    fcf_cuts = \"cuts.json\",\n)\n\nIARA.close_study!(db)\n; #hide\nnothing #hide\n\nFinally, we are ready to run the case.\n\nIARA.market_clearing(\n    PATH_EXECUTION;\n    delete_output_folder_before_execution = true,\n)","category":"section"},{"location":"tutorial/case_05_run_reservoir_case.html#Analyzing-the-results","page":"Virtual Reservoir - Running","title":"Analyzing the results","text":"The results are stored inside the case folder, in the outputs directory.\n\ncase_folder\n ├── outputs\n │    ├── plots\n │    │   └── ...\n │    └── ...\n └── ...\n\nAccording to our results, for the first bid segment, there is more energy generated by the first Asset Owner, which is related to their bidding prices differences. The second bid segment has a similar behavior, with the the first asset owner decreasing its energy generation probably due to the decrease in the hydro volume.\n\n<iframe src=\"case_5_execution\\\\outputs\\\\plots\\\\virtual_reservoir_generation_ex_post_commercial_all.html\" style=\"height:500px;width:100%;\"></iframe>\n\nAlso, the volume from the first hydro unit starts at 100 hm³, and as the energy decreases, the volume decreases as well. The second Hydro unit starts with 0 hm³ and increases over time\n\n<iframe src=\"case_5_execution\\\\outputs\\\\plots\\\\hydro_initial_volume_ex_post_physical_all.html\" style=\"height:500px;width:100%;\"></iframe>\n\nFinally, as the second hydro unit has a higher O&M cost, it is only dispatched when the energy from the first hydro unit is not enough to meet the demand.\n\n<iframe src=\"case_5_execution\\\\outputs\\\\plots\\\\hydro_generation_ex_post_physical_all.html\" style=\"height:500px;width:100%;\"></iframe>\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"style_guide.html#Style-Guide","page":"Style guide","title":"Style Guide","text":"Most of the style guidelines are based on the Julia Style Guide and the JuMP Style Guide. Please refer to these guides for more details.\n\nIn this document we will cover some specific guidelines for IARA.jl.","category":"section"},{"location":"style_guide.html#Folder-Structure","page":"Style guide","title":"Folder Structure","text":"The folder structure of the project is organized to separate concerns and improve maintainability. Below is a brief description of the main directories:\n\ncompile: Contains scripts and configurations for compiling the project.\ndatabase: Includes migration scripts and metadata for the attributes of each table in the database.\ndocker: Contains a dockerfile and related files for building a docker image capable of simulating a day-to-day operation of the system.\ndocs: Documentation files for the project, including this style guide.\nformat: Scripts and configurations for code formatting using JuliaFormatter.jl.\nprofiling: Profiling scripts to analyze and optimize performance.\nrevise: Utilities for live code reloading during development.\nsrc: The main source code of the project, organized into submodules for different functionalities.\ntest: Test cases and scripts for verifying the correctness of the project.\n\nEach subdirectory in src corresponds to a specific module or functionality, and its structure is designed to keep related code together for better organization.\n\nMore specifically, the src directory is organized as follows:\n\ncollections: Contains the data structures for each collection of the model, with their respective attributes and methods.\nexternal_time_series: Contains methods for reading and writing time series files.\ninterface_calls: Contains the methods compatible with the docker image generated by the docker folder.\nmodel_constraints: Contains the methods for generating the constraints of the model.\nmodel_variables: Contains the methods for generating the variables of the model.\nplots: Contains the methods for generating the plots of the model.\npost_processing: Contains the methods for post-processing the results of the model.\n\nIn addition to the subdirectories, the src folder also contains other .jl files, including some utility functions and methods related to the optimization problem, such as mathematical_model.jl, that contains functions to build the optimization model, using methods from the model_variables and model_constraints subdirectories.\n\nIARA.jl\n├── compile\n├── database\n├── docker\n├── docs\n├── format\n├── profiling\n├── revise\n├── src\n│   ├── collections\n|   |     └── ...\n|   ├── external_time_series\n|   |     └── ...\n|   ├── interface_calls\n|   |     └── ...\n|   ├── model_constraints\n|   |     └── ...\n|   ├── model_variables\n|   |     └── ...\n|   ├── plots\n|   |     └── ...\n|   ├── post_processing\n|   |     └── ...\n|   └── ...\n├── test\n└── ...","category":"section"},{"location":"style_guide.html#Code-Formatting","page":"Style guide","title":"Code Formatting","text":"To ensure uniform formatting, this project uses JuliaFormatter.jl. You can format your code just by running the following commands:\n\njulia --project=format 'format/format.jl'\n\nMake sure you format your code before committing it. Otherwise, a CI job will run the JuliaFormatter.jl and raise an error if the code is not formatted correctly.","category":"section"},{"location":"style_guide.html#Testing","page":"Style guide","title":"Testing","text":"We use Test.jl for testing. The tests are located in the test directory of the project.\n\nThe tests are organized into subdirectories based on the module they test.  Each module is related to a base case and its variants. A base case is created in the base_case subdirectory, using the build_case.jl script, and its variants are created in their respective subdirectories, with a modify_case.jl file that modifies the base case. Finally, each subdirectory contains a test_case.jl file that contains the tests for that specific case.\n\nExample Case 1:\n\ntest/case_01\n├── base_case\n│   ├── ...\n│   ├── build_case.jl\n│   └── test_case.jl\n├── ...\n|\n└── ac_line_case\n    ├── ...\n    ├── modify_case.jl\n    └── test_case.jl\n\nIn order to run all the tests, you can run the following command in the root directory of the project:\n\njulia --project=test -e \"import Pkg; Pkg.Registry.update(); Pkg.test()\"","category":"section"},{"location":"input_files.html#Input-files-table","page":"Input files table","title":"Input files table","text":"Here is a table of the model attributes that need a external file:\n\nCollection Attribute Description Parameter Unit Dimensions\nBiddingGroup quantity_bid Quantity of bids for independent segement bids Q_i n tau k(omega) GWh period, scenario, subperiod, bid_segment\nBiddingGroup price_bid Price of bids for independent segement bids P_i n tau k(omega) MWh period, scenario, subperiod, bid_segment\nBiddingGroup quantity_bid_profile Quantity of bids for profile bids Q^M_i n tau k(omega) GWh period, scenario, subperiod, profile\nBiddingGroup price_bid_profile Price of bids for profile bids P^M_i n k(omega) MWh period, scenario, profile\nBiddingGroup parent_profile Parent profile of profile k mathcalp(k)  period, profile\nBiddingGroup minimum_activation_level Minimum activation level of profile k X_i k(omega)  period, scenario, profile\nBiddingGroup complementary_grouping Complementary grouping m for the asset owner i mathcalK_m(i)  period, profile, complementary_group\nConfiguration hour_subperiod_map Mapping of hours to subperiods d(tau)  period, hour\nConfiguration fcf_cuts FCF cuts for the model, it's a file read from SDDP.jl in JSON format   \nConfiguration period_season_map Mapping of periods to seasons   period,scenario\nDemandUnit demand_ex_ante Demand data for the model in ex-ante, also used in the min cost module D_j tau(omega) pu period, scenario, subperiod\nDemandUnit demand_ex_post Demand data for the model in ex-post D_j tau(omega) pu period, scenario, subscenario, subperiod\nDemandUnit elastic_demand_price Elastic demand price data P_j tau(omega) MWh period, scenario, subperiod\nDemandUnit demand_window Window of demand W_j tau(omega) h period, scenario, subperiod\nHydroUnit inflow_ex_ante Inflow data for the model in ex-ante, also used in the min cost module a_j tau m^3s period, scenario, subperiod\nHydroUnit inflow_ex_post Inflow data for the model in ex-post a_j tau m^3s period, scenario, subscenario, subperiod\nRenewableUnit generation_ex_ante Realized generation for the model in ex-ante, also used in the min cost module G^R_j tau(omega) pu period, scenario, subperiod\nRenewableUnit generation_ex_post Realized generation for the model in ex-post G^R_j tau(omega) pu period, scenario, subscenario, subperiod\nVirtualReservoir quantity_bid Quantity of bids for virtual reservoirs Q^VR_r i k(omega) GWh period, scenario, bid_segment\nVirtualReservoir price_bid Price of bids for virtual reservoirs P^VR_r i k(omega) MWh period, scenario, bid_segment","category":"section"},{"location":"bid_limits.html#Bid-Price-Limit","page":"Bid price limits","title":"Bid Price Limit","text":"If the bidding group bid validation is enabled, the system will enforce limits on bid prices based on some input parameters. These parameters help ensure that bids are within acceptable ranges and are justified according to the type of bid.\n\nInput parameters for bid price limits include:\n\nP^ref_low and P^ref_high: These are the reference prices used to calculate the bid price limits. P^ref_low  P^ref_high.\nM^n_p: The maximum markup without justification for profile bids.\nM^n_i: The maximum markup without justification for independent bids.\nM^j_p: The maximum markup with justification for profile bids.\nM^j_i: The maximum markup with justification for independent bids.","category":"section"},{"location":"bid_limits.html#Reference-Prices","page":"Bid price limits","title":"Reference Prices","text":"The reference price for a bidding group is calculated according to the types of units in the group.","category":"section"},{"location":"bid_limits.html#Bidding-Group-with-Thermal-Units","page":"Bid price limits","title":"Bidding Group with Thermal Units","text":"For a bidding group that contains thermal units, the reference price is the maximum between the O&M costs of the thermal units and the low reference price parameter: \n\nP^ref = max(C^T cup P^ref_low)","category":"section"},{"location":"bid_limits.html#Bidding-Group-with-Renewable-Units-and-no-Thermal-Units","page":"Bid price limits","title":"Bidding Group with Renewable Units and no Thermal Units","text":"For a bidding group that contains renewable units and does not contain any thermal units, the reference price is the low reference price parameter:\n\nP^ref = P^ref_low","category":"section"},{"location":"bid_limits.html#Bidding-Group-with-no-Renewable-or-Thermal-Units","page":"Bid price limits","title":"Bidding Group with no Renewable or Thermal Units","text":"For a bidding group that does not contain any renewable or thermal units, the reference price is the high reference price parameter:\n\nP^ref = P^ref_high","category":"section"},{"location":"bid_limits.html#Maximum-Markup-over-Reference-Price","page":"Bid price limits","title":"Maximum Markup over Reference Price","text":"The maximum markup over the reference price, with and withot justification, varies based on the type of bid.","category":"section"},{"location":"bid_limits.html#Independent-Bids","page":"Bid price limits","title":"Independent Bids","text":"M^n = M^n_i \nM^j = M^j_i","category":"section"},{"location":"bid_limits.html#Profile-Bids","page":"Bid price limits","title":"Profile Bids","text":"M^n = M^n_p \nM^j = M^j_p","category":"section"},{"location":"bid_limits.html#Bid-Price-Limits","page":"Bid price limits","title":"Bid Price Limits","text":"Given the reference price, the maximum markup without justification, and the maximum markup with justification, the price bids are validated as follows:\n\nIf the bid price is below the non justified limit (P le P^ref cdot (1 + M^n)), the bid is considered valid.\nIf the bid price is above the non justified limit, but below the justified limit ($ P^{ref} \\cdot (1+M^n) \\le P \\le P^{ref} \\cdot (1 + M^j)$), the bid is considered valid if a justification is provided.\nIf the bid price is above the justified limit (P  P^ref cdot (1 + M^j)), the bid is automatically considered invalid.\n\nThe bid justifications are plain text explanations provided via JSON file. The configuration parameter bid_justifications_file specifies the path to this file. When using IARA in the Market Game platform, a prompt will ask the user to provide a justification for the bids that exceed the non justified limit.","category":"section"},{"location":"bidding_formats.html#Introduction:-Bid-structures-and-bid-data","page":"Introduction","title":"Introduction: Bid structures and bid data","text":"","category":"section"},{"location":"bidding_formats.html#Types-of-bid-and-data-flow","page":"Introduction","title":"Types of bid and data flow","text":"Being able to describe agents' strategies in a bid-based market is one of IARA's key features. IARA has three main types of bid that can be submitted by decision-making agents:\n\nindependent bids refer to price-quantity bids that are associated to a single subperiod, and which can be accepted or rejected in a fully independent manner\nprofile bids refer to price-quantity bids that represent an interdependence between different subperiods, with a single decision potentially affecting output in multiple subperiods\nvirtual reservoir bids refer to price-quantity bids tied to virtual reservoir accounts, designed to combat the externality issues involved in hydro cascades.\n\nFor all three types of bid, there are two possible options for managing this bid data: \n\nBid data can be produced automatically, using IARA's standard \"heuristic bid\" functionality that is applied by default in the course of running a market clearing problem\nAlternatively, bid data can be read from external files, which are referenced as external data structures of the IARA database.\n\nNote that, in case the heuristic bid alternative is chosen, bid files will be generated with the same structure that is expected if bids were to be read as input data.","category":"section"},{"location":"bidding_formats.html#Price-and-quantity-parameter-data-files","page":"Introduction","title":"Price and quantity parameter data files","text":"All three types of bid in IARA involve \"price\" and \"quantity\" information that can be expressed by a time series file, and which can be linked using the function IARA.link_time_series_to_file.\n\nHowever, there are some differences in the way that these time series files are structured, depending on the type of bid. The following sections describe the expected structure of the time series files for each type of bid.","category":"section"},{"location":"bidding_formats.html#Independent-bids:","page":"Introduction","title":"Independent bids:","text":"Independent bids have both quantities and prices varying per subperiod, as decisions are indeed individualized per subperiod. Independent bids can be parameterized using the following syntax: link_time_series_to_file(db,\"BiddingGroup\"; quantity_bid = \"q\", price_bid = \"p\"), where \"q\" and \"p\" are the names of the CSV files containing the time series data for the quantity and price bids, respectively. The expected structure of these files is shown in the following tables:","category":"section"},{"location":"bidding_formats.html#Price-bid","page":"Introduction","title":"Price bid","text":"period scenario subperiod bid_segment bg1 - bus1 bg1 - bus2 bg2 - bus1 bg2 - bus2\n1 1 1 1 100.0 80.0 90.0 70.0\n1 1 2 1 100.0 80.0 90.0 70.0\n1 2 1 1 100.0 80.0 90.0 70.0\n1 2 2 1 100.0 80.0 90.0 70.0","category":"section"},{"location":"bidding_formats.html#Quantity-bid","page":"Introduction","title":"Quantity bid","text":"period scenario subperiod bid_segment bg1 - bus1 bg1 - bus2 bg2 - bus1 bg2 - bus2\n1 1 1 1 5.0 1.0 5.0 2.0\n1 1 2 1 5.0 1.0 5.0 2.0\n1 2 1 1 4.0 1.5 4.0 3.0\n1 2 2 1 4.0 1.5 4.0 3.0","category":"section"},{"location":"bidding_formats.html#Profile-bids:","page":"Introduction","title":"Profile bids:","text":"Profile bids have quantities varying per subperiod. However, the prices for each bid do not vary, as the decision on whether or not to activate the profile bid is made only once in the period (and therefore it is sufficient to represent the associated cost with a single price parameter).  Profile bids can be parameterized using the following syntax: link_time_series_to_file(db,\"BiddingGroup\"; quantity_bid_profile = \"q\", price_bid_profile = \"p\"), where \"q\" and \"p\" are the names of the CSV files containing the time series data for the quantity and price profile bids, respectively.","category":"section"},{"location":"bidding_formats.html#Price-bid-2","page":"Introduction","title":"Price bid","text":"period scenario profile bg_1 bg_2\n1 1 1 0.0 45.0\n1 1 2 0.0 35.0\n1 2 1 0.0 45.0\n1 2 2 0.0 35.0","category":"section"},{"location":"bidding_formats.html#Quantity-bid-2","page":"Introduction","title":"Quantity bid","text":"period scenario subperiod profile bg1 - bus1 bg1 - bus2 bg2 - bus1 bg2 - bus2\n1 1 1 1 0.0 0.0 4.0 4.0\n1 1 1 2 0.0 0.0 4.0 4.0\n1 1 2 1 0.0 0.0 4.0 4.0\n1 1 2 2 0.0 0.0 4.0 4.0\n1 2 1 1 0.0 0.0 4.0 4.0\n1 2 1 2 0.0 0.0 4.0 4.0\n1 2 2 1 0.0 0.0 4.0 4.0\n1 2 2 2 0.0 0.0 4.0 4.0","category":"section"},{"location":"bidding_formats.html#Virtual-reservoir-bids:","page":"Introduction","title":"Virtual reservoir bids:","text":"Virtual Reservoir bids have neither quantities nor prices varying per subperiod, as the decisions associated with the virtual reservoir bids are intended to drive the target reservoir storage level at the end of the period (for which it is not necessary to include per-subperiod granularity). Virtual reservoir bids can be parameterized using the following syntax: link_time_series_to_file(db,\"BiddingGroup\"; virtual_reservoir_quantity_bid = \"q\", virtual_reservoir_price_bid = \"p\"), where \"q\" and \"p\" are the names of the CSV files containing the time series data for the quantity and price bids, respectively. The expected structure of these files is shown in the table below:","category":"section"},{"location":"bidding_formats.html#Price-bid-3","page":"Introduction","title":"Price bid","text":"period scenario bid_segment virtualreservoir1 - assetowner1 virtualreservoir1 - assetowner2\n1 1 1 491.198334 491.198334\n1 2 1 368.398743 368.398743","category":"section"},{"location":"bidding_formats.html#Quantity-bid-3","page":"Introduction","title":"Quantity bid","text":"period scenario bid_segment virtualreservoir1 - assetowner1 virtualreservoir1 - assetowner2\n1 1 1 1.5 6.0\n1 2 1 1.5 6.0","category":"section"},{"location":"bidding_formats.html#Bid-segments","page":"Introduction","title":"Bid segments","text":"As seen in independent bids and virtual reservoir bids there is an entry for bid_segment, which allows for the bid bid to be broken down into segments. This is useful for representing a single bid divided into multiple bids, each with its own price and quantity.\n\nnote: Note\nAlthough each bid segment counts as a separate bid, for the same subperiod, the total quantity of its segments cannot exceed the maximum quantity of the bidding group. \n\nIn the following table we show an example of a segmented bid for independent bids quantity bids, where the maximum generation of the bidding group is 100 MW.\n\nperiod scenario subperiod bid_segment bg1 - bus1\n1 1 1 1 50.0\n1 1 1 2 50.0\n1 1 2 1 50.0\n1 1 2 2 50.0","category":"section"},{"location":"bidding_formats.html#Profile-bids","page":"Introduction","title":"Profile bids","text":"Although the representation introduced earlier of independent bids, profile bids, and virtual reservoir bids is quite powerful, it is insufficient for properly representing all possible types of interdependence between the decisions at multiple subperiods that would be needed to actually emulate realistic constraints of various types of physical units. In order to extend the model and truly allow for all types of interplay (synergies and anti-synergies) between possible dispatch choices at different hours, we introduce three additional features tied to the profile bids structure: precedence constraints, complementarity constraints, and minimum activation constraints. All three of these features work with a coefficient $ 0 \\leq \\lambda \\leq 1$ that indicates the fraction of the profile bid that was accepted. We will now describe these three constraints in more detail.","category":"section"},{"location":"bidding_formats.html#Precedence-constraints","page":"Introduction","title":"Precedence constraints","text":"It is possible to model precedence constraints between two profile bids, which are constraints that impose that the activation of one profile bid (say, A) is a necessary condition for the activation of another profile bid (say, B). Thus if B has A as a parent, then the constraint lambda_B leq lambda_A must hold. This is represented in the database by the parent_profile time series file, which can be attached to the case using the IARA.link_time_series_to_file function. \n\nIn the following example of a parent_profile.csv file, we have have bids for the Bidding Groups bg_1 and bg_2, with three profiles each.  For bg_2, its first profile is a parent of its second profile, while for bg_1, its second profile is a parent of its third profile. \n\nperiod profile bg_1 bg_2\n1 1 0.0 0.0\n1 2 0.0 1.0\n1 3 2.0 0.0\n2 1 0.0 0.0\n2 2 0.0 1.0\n2 3 2.0 0.0","category":"section"},{"location":"bidding_formats.html#Complementarity-constraints","page":"Introduction","title":"Complementarity constraints","text":"Complementarity constraints impose that the sum of the activation coefficients of a complementary group must be less than or equal to 1.  This is represented in the database by the complementary_grouping_profile time series file, which can be attached to the case using the IARA.link_time_series_to_file function.\n\nIn the following example of a complementary_grouping_profile.csv file, we have two bidding groups, bg_1 and bg_2, with 2 profiles and 3 complementary groups each. The columns bg_1 and bg_2 contain boolean values that indicate whether the profile is part of the complementary group or not.\n\nObserving the table, we can draw the following conclusions:\n\nThe first profile of bg_2 is part of the complementary group 1, along with its second profile.\nThe first profile of  bg_2 is also part of the complementary group 2, but no other profile is part of this group.\nThe second profile of bg_2 is part of the complementary group 3, with no other profile being part of this group.\nNo profile of bg_1 is part of any complementary group.\n\nIf a profile is not part of any complementary group, its coefficient keeps its original constraint of being between 0 and 1. The same applies for profiles that are the only ones in a complementary group.\n\nperiod profile complementary_group bg_1 bg_2\n1 1 1 0.0 1.0\n1 1 2 0.0 1.0\n1 1 3 0.0 0.0\n1 2 1 0.0 1.0\n1 2 2 0.0 0.0\n1 2 3 0.0 1.0","category":"section"},{"location":"bidding_formats.html#Minimum-activation-constraints","page":"Introduction","title":"Minimum activation constraints","text":"Minimum activation constraints establish that, for a profile bid to be accepted, the bid quantity must be at least a certain threshold, expressed as a percentage of the total bid volume. This is represented in the database by the minimum_activation_level_profile time series file, which can be attached to the case using the IARA.link_time_series_to_file function.\n\nIn the following example of a minimum_activation_level_profile.csv file, we have two bidding groups, bg_1 and bg_2, with two profiles each. All bg_2 profiles have a minimum activation level of 0.8, while bg_1 has a minimum activation level of 0.0 for both profiles.\n\nperiod scenario profile bg_1 bg_2\n1 1 1 0.0 0.8\n1 1 2 0.0 0.8\n\nThese three types of constraints associated with the profile bids are analogous to the \"block bid\" functionalities extensively used in Europe, and they represent a technology-neutral way to express any possible technological feature leading to interdependence relations between the operational choices at different hours. It is possible to demonstrate that, with only the three types of constraints above and assuming that the number of profiles and constraints that can be used is sufficiently large, it is possible to represent virtually any possible shape of interdependencies. Also, it is worth noting that, once a profile bid is accepted, the quantities for each subperiod are proportional to the activation coefficient lambda and the quantity bid of the profile bid. ","category":"section"},{"location":"bidding_formats.html#Heuristic-bids","page":"Introduction","title":"Heuristic bids","text":"As mentioned above, during the market clearing process, IARA can automatically generate bids for the decision-making agents using a heuristic approach. \n\nThe heuristic bid generation differs based on the type of assets that an agent's bidding group contains. In this documentation we provide examples of how the heuristic bid is generated. For the mathematical formulation of the heuristic bid, please refer to the Heuristic Bid chapter. The heuristic bid for virtual reservoirs is described in the Virtual Reservoir Bids chapter.","category":"section"},{"location":"bidding_formats.html#Practical-examples","page":"Introduction","title":"Practical examples","text":"The tutorials below highlight the construction and execution of studies using different types of bids:\n\nA simple introduction to profile bids\nA case with minimum activation and integer variables\nA case with reservoir hydro bids","category":"section"},{"location":"hydro_challenges.html#Hydro-reservoirs,-cascades,-and-virtual-reservoirs","page":"Hydro reservoirs, cascades and virtual reservoirs","title":"Hydro reservoirs, cascades, and virtual reservoirs","text":"","category":"section"},{"location":"hydro_challenges.html#The-nature-of-hydropower","page":"Hydro reservoirs, cascades and virtual reservoirs","title":"The nature of hydropower","text":"In the context of \"zero marginal cost\" electricity systems, characterized by the contributions from variable renewable energy such as wind or solar being more than sufficient to meet demand a large majority of the time, hydro resources play an interesting role. Despite being variable in longer time scales (in the sense that hydro avaialbility is uncertain), in shorter time scales hydropower is actually highly controllable and can help accommodate variable renewable energy sources.\n\nIn addition to this flexibility of allocating the hydro resource between subperiods within a given period, reservoir hydro plants have even more flexibility, as they can choose to allocate their water resource over a much longer time horizon (e.g. several months). For this type of intertemporal allocation, it becomes desirable to make decisions under uncertainty taking into account the opportunity cost of future water usage as a value function, drawing from the literature of stochastic dynamic programming and stochastic dual dynamic programming (SDDP).\n\nAnother feature of hydropower that is of particular relevance for assessments of market incentives and bid-based applications is the existence of hydro cascades. In a hydro cascade, the amount of water available in the downstream power plant is dependent on decisions made in the upstream power plants, which creates a codependence between these units.\n\nEach of these features has had an impact on the development philosophy of IARA.","category":"section"},{"location":"hydro_challenges.html#SDDP-representation-of-intertemporal-optimization","page":"Hydro reservoirs, cascades and virtual reservoirs","title":"SDDP representation of intertemporal optimization","text":"In order to properly represent hydro reservoirs' intertemporal management strategy and the corresponding opportunity costs, IARA incorporates functionality that is integrated with the SDDP.jl package. To this end, IARA can be run in a \"train mincost\" mode that will create the intertemporal structure necessary for describing optimal decisions under uncertainty, described in practice by a \"policy graph\".\n\nThe \"mincost\" representation is not as complete as IARA's market clearing representation, as in particular it involves simplifying the decisions each period to a single optimization problem and always using the \"cost-based\" representation rather than the \"bid-based\" one. Despite this limitation, it will produce a reasonable representation of reservoir hydro plants' \"future cost function\" to drive intertemporal policy, which at the very least can be useful as an initial heuristic (that can be further refined in accordance with the bidding strategies of hydro plant owners).\n\nThe outcome of the mincost representation is a set of \"cuts\" generated iteratively by the SDDP process and which describe intertemporal preferences for reservoir hydro plants (or, more generally, for any units that involve a state variable creating a lasting impact from one period's decisions to the next). These cuts are saved as part of the external data structure of the IARA database, and will be used if needed to generate heuristic bids during the market clearing process.","category":"section"},{"location":"hydro_challenges.html#Externalities-and-virtual-reservoirs","page":"Hydro reservoirs, cascades and virtual reservoirs","title":"Externalities and virtual reservoirs","text":"A classic result from economic theory is the equivalence between the solution of a central planner's optimization problem and the market equilibrium obtained from marginal pricing and profit maximization of each individual agent in the system. While this outcome is highly desirable, it relies on a number of assumptions, such as the lack of market power. The case of hydro cascades has yet another pathological issue, which is the fact that they violate the assumption of no externalities. Because there is no market to coordinate the joint operation of the upstream plant with the downstreap plant, price signals will be inefficient - and therefore, even as competition increases and agents' market power falls, the result of the market equilibrium will not be the same as the optimal centralized policy.\n\nThis externality issue was the main motivation for the proposal of the novel virtual reservoir mechanism as a market design strategy. Even though it would be possible to eliminate the externalities via mergers and acquisitions (i.e. forcing all hydro power plants in the same cascade to have the same owner), in the case of the Brazilian electricity system this is not practical, given the large size and complexity of Brazilian cascades, which represent a large share of the system's total capacity and already involve the coordination of multiple different owners.\n\nUnder the virtual reservoir mechanism, rather than each individual asset owner being responsible for their own hydro plants and submitting bids accordingly (despite the lack of proper price signals to take into account how their bids would affect other plants in the same cascade), bids are submitted jointly for a group of hydro plants, or \"virtual reservoir\". Ownership of the virtual reservoir is shared, in the sense that any agent can submit bids for any virtual reservoir: each agent has a \"virtual reservoir account\" that reflects the number of \"shares\" they currently own out of the total amount of potential energy currently stored in the physical reservoirs, and the maximum amount they can bid with their virtual reservoir bids is limited by the total amount in their account. The virtual reservoir representation in practice changes the way how the optimization problem is constructed.","category":"section"},{"location":"tutorial/case_02_build_hydrounit_base_case.html#Hydro-Base-Case-Building","page":"Hydro Base Case - Building","title":"Hydro Base Case - Building","text":"The data for this case is available in the folder data/case_2\n\nusing Dates\nusing DataFrames\nusing IARA\n; #hide\nnothing #hide\n\nIn this tutorial we will start with the Case 1 elements and build a run of river Hydro Unit. This Hydro Unit will be linked to a new Bidding Group Hydro Owner Group, which belongs to the Hydro Owner owner.\n\nBefore we start, let's recap some information about the original case.","category":"section"},{"location":"tutorial/case_02_build_hydrounit_base_case.html#Original-Case-Recap","page":"Hydro Base Case - Building","title":"Original Case Recap","text":"Periods Subperiods Scenarios Subperiod duration (hours) Yearly discount rate\n2 1 4 24 10%\n\nTechnology Name Owner Maximum Generation (MW) Cost ($/MWh)\nRenewable Solar1 Price Taker 80 \nThermal Thermal1 Thermal Owner 20 10\nThermal Thermal2 Price Taker 20 30\nThermal Thermal3 Thermal Owner 20 100\nThermal Thermal4 Price Taker 20 300\nThermal Thermal5 Price Taker 50 1000\nThermal Thermal6 Price Taker 50 3000\n\nAlso, when defining the time series for the demand and solar generation, we had considered that the demand could be on High or Low levels, and the solar generation could be on High or Low levels as well.","category":"section"},{"location":"tutorial/case_02_build_hydrounit_base_case.html#Changes-for-this-tutorial","page":"Hydro Base Case - Building","title":"Changes for this tutorial","text":"As already mentioned, we will add a Hydro Unit to the case. This Hydro Unit will belong to a new a new Asset Owner called Hydro Owner.\n\nMoreover, we will change the number of scenarios to 12, considering that the inflow values for Hydro Unit could be on High, Medium or Low levels.","category":"section"},{"location":"tutorial/case_02_build_hydrounit_base_case.html#Loading-case","page":"Hydro Base Case - Building","title":"Loading case","text":"Now let's copy the base case to a new folder and load it.\n\nconst PATH_ORIGINAL = joinpath(@__DIR__, \"data\", \"case_1\")\n\nconst PATH_HYDRO = joinpath(@__DIR__, \"data\", \"case_2\")\n\nif !isdir(PATH_HYDRO)\n    mkdir(PATH_HYDRO)\nend\n\ncp(\n    joinpath(PATH_ORIGINAL, \"study.iara\"),\n    joinpath(PATH_HYDRO, \"study.iara\");\n    force = true,\n)\n\ndb = IARA.load_study(PATH_HYDRO; read_only = false);\n#hide","category":"section"},{"location":"tutorial/case_02_build_hydrounit_base_case.html#Changing-the-number-of-scenarios","page":"Hydro Base Case - Building","title":"Changing the number of scenarios","text":"We will change the number of scenarios to 12, using the IARA.update_configuration! function.\n\nIARA.update_configuration!(\n    db;\n    number_of_scenarios = 12,\n    inflow_scenarios_files = IARA.Configurations_UncertaintyScenariosFiles.ONLY_EX_ANTE,\n)\n; #hide\nnothing #hide","category":"section"},{"location":"tutorial/case_02_build_hydrounit_base_case.html#Financial-elements","page":"Hydro Base Case - Building","title":"Financial elements","text":"We will add a new Asset Owner called Hydro Owner, using the IARA.add_asset_owner! function.\n\nIARA.add_asset_owner!(\n    db;\n    label = \"Hydro Owner\",\n)\n\nNow we will add a new Bidding Group called Hydro Owner Group, using the IARA.add_bidding_group! function. For this example, the Bidding Group will have a risk factor of 20%.\n\nIARA.add_bidding_group!(\n    db;\n    label = \"Hydro Owner\",\n    assetowner_id = \"Hydro Owner\",\n    risk_factor = [0.2],\n    segment_fraction = [1.0],\n)","category":"section"},{"location":"tutorial/case_02_build_hydrounit_base_case.html#Physical-Elements","page":"Hydro Base Case - Building","title":"Physical Elements","text":"","category":"section"},{"location":"tutorial/case_02_build_hydrounit_base_case.html#Gauging-Station","page":"Hydro Base Case - Building","title":"Gauging Station","text":"When adding a Hydro Unit, we need to associate a Gauging Station to it. When creating a Hydro Unit, if no Gauging Station is provided, the package will create one automatically.\n\nIARA.add_gauging_station!(db;\n    label = \"gauging_station\",\n)","category":"section"},{"location":"tutorial/case_02_build_hydrounit_base_case.html#Hydro-Unit","page":"Hydro Base Case - Building","title":"Hydro Unit","text":"For this example, we will add a Hydro Unit with the following characteristics\n\nType Name Owner Maximum Generation (MW)\nRun of river Hydro1 Hydro Owner 100\n\nnote: Note\nA Run of river Hydro Unit does not have a reservoir\n\nTo add a hydro unit, we need to use the IARA.add_hydro_unit! function.\n\nWe can feed some data about the hydro unit that varies with time, such as maximum and minimum generation. For that, we need to pass a DataFrame in the parameters argument.\n\nIARA.add_hydro_unit!(db;\n    label = \"Hydro1\",\n    intra_period_operation = IARA.HydroUnit_IntraPeriodOperation.CYCLIC_WITH_FLEXIBLE_START,\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [1], # 1 = true\n        production_factor = [1.0], # MW/m³/s\n        max_generation = [100.0], # MW\n        max_turbining = [100.0], # m³/s\n        min_volume = [0.0], # hm³\n        max_volume = [0.0], # hm³\n        min_outflow = [0.0], # m³/s\n        om_cost = [0.0], # $/MWh\n    ),\n    initial_volume = 0.0, # hm³\n    gaugingstation_id = \"gauging_station\",\n    biddinggroup_id = \"Hydro Owner\",\n    bus_id = \"Island\",\n)","category":"section"},{"location":"tutorial/case_02_build_hydrounit_base_case.html#Time-Series","page":"Hydro Base Case - Building","title":"Time Series","text":"Since we have updated the number of scenarios, we will need different time series for the demand and solar generation. Just as in the previous tutorial, we will be loading a CSV file we have created earlier.\n\nOur CSV files are\n\ndemands.csv: with the demand time series\nsolar_generation.csv: with the solar generation time series\ninflows.csv: with the inflow time series\n\nLet's take a look at the first lines of each file, using the function IARA.time_series_dataframe.","category":"section"},{"location":"tutorial/case_02_build_hydrounit_base_case.html#Demands:","page":"Hydro Base Case - Building","title":"Demands:","text":"IARA.time_series_dataframe(joinpath(PATH_HYDRO, \"demands.csv\"))","category":"section"},{"location":"tutorial/case_02_build_hydrounit_base_case.html#Solar-generation:","page":"Hydro Base Case - Building","title":"Solar generation:","text":"IARA.time_series_dataframe(joinpath(PATH_HYDRO, \"solar_generation.csv\"))","category":"section"},{"location":"tutorial/case_02_build_hydrounit_base_case.html#Inflows:","page":"Hydro Base Case - Building","title":"Inflows:","text":"IARA.time_series_dataframe(joinpath(PATH_HYDRO, \"inflow.csv\"))","category":"section"},{"location":"tutorial/case_02_build_hydrounit_base_case.html#Linking-the-time-series","page":"Hydro Base Case - Building","title":"Linking the time series","text":"Now need to link the time series with the function IARA.link_time_series_to_file.\n\nIARA.link_time_series_to_file(\n    db,\n    \"DemandUnit\";\n    demand_ex_ante = \"demands\",\n)\n\nIARA.link_time_series_to_file(\n    db,\n    \"RenewableUnit\";\n    generation_ex_ante = \"solar_generation\",\n)\n\nIARA.link_time_series_to_file(\n    db,\n    \"HydroUnit\";\n    inflow_ex_ante = \"inflow\",\n)","category":"section"},{"location":"tutorial/case_02_build_hydrounit_base_case.html#Closing-the-database","page":"Hydro Base Case - Building","title":"Closing the database","text":"Now that we have added all the elements and linked the time series files, we can close the database to run the case, with the function IARA.close_study!.\n\nIARA.close_study!(db)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"tutorial/case_building.html#Editing-physical-data","page":"Editing physical data","title":"Editing physical data","text":"In this tutorial, it is described how to edit the physical configuration of an existing case in IARA - for example, data related to generation units or network elements. For that, we will use as a starting point the example case boto_base_01, analyzed in the first steps tutorial, and manipulate it, aiming to illustrate the incorporation of modifications to its dataset.\n\nIf you have already gone through the previous tutorial, this case was built in the case_path defined. In order to manipulate its inputs, we will now load the boto_base_01 example case, with the IARA.load_study function, and store it in a variable named case_edit_unit. Note that we need to include the read_only = false argument to indicate that we wish to write modifications to the case.\n\nusing IARA # hide\nconst case_path = joinpath(@__DIR__, \"data\", \"ExampleCase_boto_base_01\") # hide\n; # hide\n\ncase_name = \"boto_base_01\"\nIARA.ExampleCases.build_example_case(case_path, case_name) # hide\ncase_edit_unit = IARA.load_study(case_path; read_only = false);\n#hide\n\nNow, we can modify any case characteristic, from general characteristics (such as number of periods or number of scenarios) to market clearing aspects. In the present tutorial, we will focus on editing physical elements, which can be added, removed or have their parameters modified. To illustrate this functionality, we can, for example, add a new thermal generator to our example case, using the function IARA.add_thermal_unit!, as shown below. Note that the functions related to other physical elements of the system are analogous to the one used in this example - for instance, IARA.add_renewable_unit! adds a new renewable generator and IARA.add_bus! adds a new bus.\n\nRegardless of the element type, additions require the definition of a set of parameters. In the case of thermal units, as shown below, the information needed comprises: (i) the case that is being modified (see above that we have store our example case in a variable named case_edit_unit), (ii) the label, which corresponds to the plant's name, (iii) technical characteristics, such as the generation capacity (max_generation), (iv) variable costs (om_cost), (v) the bus to which it is connected (bus_id), and the bidding group to which it is assigned (biddinggroup_id) - for more information on Bidding groups, read about the model's key features.\n\nNote that IARA.add_thermal_unit! uses the functions DataFrame and DateTime, which belong to the DataFrames and Dates packages, respectively, which must be installed. Then, we just need to import them before calling IARA.add_thermal_unit!, as shown below.\n\nusing DataFrames\nusing Dates\n; #hide\n\nIARA.add_thermal_unit!(\n    case_edit_unit;\n    label = \"Geothermal\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [1],\n        max_generation = [20.0],\n        om_cost = [3.0],\n    ),\n    biddinggroup_id = \"ThermalA_01\",\n    bus_id = \"Eastern\",\n)\n; #hide\nnothing #hide\n\nAs mentioned, other general or physical modifications can be carried out, using functions similar to the ones presented above. For now, let's move forward with the example case incorporating the addition presented in this tutorial. The final step is to close the study, using the IARA.close_study! function, assign a new folder for the model to write execution outputs and re-execute it, using the function IARA.market_clearing.\n\nIARA.close_study!(case_edit_unit)\npath02_edit_unit = joinpath(case_path, \"02_edit_unit\")\nIARA.market_clearing(\n    case_path;\n    output_path = path02_edit_unit,\n    delete_output_folder_before_execution = true,\n);\n#hide\n\nAfter successfully re-executing IARA, the outputh path will be filled with files containing the model's results, including automatically generated plots. When analyzing the new marginal costs obtained, using the function IARA.custom_plot (which uses the output file load_marginal_cost_ex_post_physical.csv), we can see that they present differences in comparison with the ones observed in the previous execution, prior to the addition of the new thermal plant. In particular, since we have added to the Eastern bus a new low-cost generation asset, it is visible the consequent reduction in the marginal costs in this bus.\n\ncmg_name2 = \"load_marginal_cost_ex_post_physical.csv\"\ncmg_path2 = joinpath(path02_edit_unit, cmg_name2)\nIARA.custom_plot(cmg_path2, IARA.PlotTimeSeriesQuantiles)\n\nMoving forward with the sequence of tutorial, click here to understand how to modify market clearing configurations in an existing case.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"post_processing_virtual_reservoir.html#Pre-and-post-processing-virtual-reservoirs","page":"Virtual reservoirs pre and post processing","title":"Pre and post processing virtual reservoirs","text":"The virtual reservoir representation in the market clearing problem requires some pre-calculation at the beginning of the run, as well as at the beginning and end of each period. These calculations can use input data and results from optimizing the market clearing subproblem of a previous period, and are utilized to fill and update parameters used in the subproblem.","category":"section"},{"location":"post_processing_virtual_reservoir.html#Water-to-Energy-Factors","page":"Virtual reservoirs pre and post processing","title":"Water-to-Energy Factors","text":"For a hydro unit h at a virtual reservoir r, the water-to-energy factor zeta_rh represents the amount of energy (MWh) that can be generated by each hm^3 of volume at h within the hydro units of reservoir r. To calculate this factor, we analyze the topology of the cascade to identify which hydro units within r lie downstream of h. Specifically, we look for hydro units g in J^H_VR(r) such that there exists a path from h to g through intermediate units. This path is defined by a sequence of units h g_1 g_2 dots g_n g, where each g_i in J^H_VR(r) for all i in n, with each unit in the sequence receiving water from the previous one: h turbines water to g_1, g_i turbines water to g_i+1, and g_n turbines water to g.\n\nLet G be the set of possible downstream units g. Thus, the water-to-energy factor is given by:\n\nzeta_rh = sum_g in G rho_g cdot C_hm^3h rightarrow m^3s\n\nwhere rho_g is the production factor of hydro unit g.","category":"section"},{"location":"post_processing_virtual_reservoir.html#Additional-energy-from-inflows","page":"Virtual reservoirs pre and post processing","title":"Additional energy from inflows","text":"At the beginning of each period, for each scenario, we calculate the additional energy that is stored in the virtual reservoirs due to inflows. This is done by analyzing the inflow series and the current volume of each hydro unit. The calculation begins at the top of the cascade and proceeds downstream. At each hydro unit j, the inflow volume for the period is:\n\na^vol_j = sum_tau in B(t) a_j tau cdot C_m^3s rightarrow hm^3h cdot d(tau)\n\nThe maximum volume of water that can be turbined from hydro unit j during the period is:\n\nU_j^vol = U_j cdot C_m^3s rightarrow hm^3h cdot sum_tau in B(t) d(tau)\n\nThe inflow volume that unavoidably spills from hydro unit j is:\n\nz^vol_j = max(a^vol_j + v^S_in_j - (V_j + U_j^vol) 0)\n\nThe additional energy that can be generated by the inflow at hydro unit j is:\n\ne^inflow_r = (a^vol_j - z^vol_j) cdot zeta_rj\n\nwhere zeta_rj is the water-to-energy factor for hydro unit j at virtual reservoir r.\n\nThe excess inflow z^vol_j is added to the downstream hydro unit g that receives water from j, if it exists, and the process continues downstream until all hydro units in the virtual reservoir have been processed.","category":"section"},{"location":"post_processing_virtual_reservoir.html#Post-processing-energy-account","page":"Virtual reservoirs pre and post processing","title":"Post processing energy account","text":"At the end of each period, we want to guarantee that the sum of the energy accounts of the asset owners at a virtual reservoir is equal to the stored energy of the hydro units of this virtual reservoir. For that, we adjust the energy accounts, if necessary. The raw energy accounts can be obtained from the optimization solution: E^out_ri^*. The stored energy of each hydro unit h can be calculated based on the final volume at the optimization solution v^S_out_h^* and the water-to-energy factors zeta_rh.\n\nStored energy of virtual reservoir r: A=sum_h in J^H_VR(r) v^S_out_h^* cdot zeta_rh\n\nSum of energy accounts of virtual reservoir r: B =sum_i in I^VR(r) E^out_ri^*\n\nFor each asset owner i at virtual reservoir r, we define the post-processed energy account E_ri:\n\nE_ri = E^out_ri^* cdot fracAB\n\nThis way, sum_i in I^VR(r) E_ri = A, and the proportions of energy accounts at r are kept.\n\nFor the next period, E^in_ri = E_ri.","category":"section"},{"location":"key_features.html#Key-features-of-IARA","page":"Key features of IARA","title":"Key features of IARA","text":"IARA is a sophisticated piece of software intended to model realistic electricity markets. IARA's core usage is the \"market clearing\" execution mode, which will calculate dispatch decisions and marginal prices associated with the particular market design choices initialized (conceptualized as the regulator's decisionmaking) and, when applicable, also affected by the bidding strategies of individual agents operating in the market.","category":"section"},{"location":"key_features.html#Optimization-problem-structure","page":"Key features of IARA","title":"Optimization problem structure","text":"Electricity system dispatch and price formation typically relies on building and solving optimization problems. In order to accomodate different electricity market designs, IARA contemplates multiple \"types\" of representation of the underlying physical reality, as discussed in a dedicated page. In particular, there are four key ways to represent physical units in the system:\n\nIn a cost-based representation, physical units are modeled directly as parameterized. The underlying assumption is that the system operator has all of this relevant information and no further input from the asset owner is needed.\nIn a bid-based representation, physical units are represented abstractly by a set of bid segments submitted by the asset owners. The only decision variable available to the operator is how much of each bid segment to activate.\nIn a hybrid representation, each physical unit is represented by two sets of variables, one representing bid segment activations and another representing physical decision variables.\nThe virtual reservoir hybrid representation is a modified version of the hybrid representation which was designed specifically to tackle the challenges of hydro cascades.","category":"section"},{"location":"key_features.html#The-market-clearing-process","page":"Key features of IARA","title":"The market clearing process","text":"Each time IARA is run, it will create a number of scenarios S (parallel trajectories to simulate), each of which will involve modeling a number of sequential periods T (with the possibility of using the results of the previous period within each scenario to affect the curent period). The \"market clearing process\" run for each S and each T is described in detail in a separate dedicated page, but it can be summarized as follows:\n\nMarket clearing begins by the collection of ex ante physical data. This is intended to represent the best information available when the system operator is making key decisions (i.e. the \"ex ante process\") which cannot easily be changed in real time.\nThe second step is the bidding phase, in which market agents submit their bids to the system operator. Note that bids are only submitted ex ante, and that the process of bidding can be automated by a heuristic bid process.\nThe third step is solving the ex ante subproblem, which is built according to the optimization problem structure defined earlier and parameterized according to the data and/or bids collected in the previous steps.\nThe following step is the collection of ex post physical data. Ex post physical data usually represents possible realizations of relevant random variables, and they vary per \"subscenario\" s - but otherwise have a similar structure to ex ante data.\nThe next step is solving the ex post subproblems, which once again involves building the optimization problems (one per subscenario) and solving it using information from bids and ex post physical data.\nFinally, the post-processing step involves a final calculation of revenue flows for each asset owner based on the ex ante and ex post subproblems and the structure of the market design.","category":"section"},{"location":"key_features.html#IARA's-physical-system-data","page":"Key features of IARA","title":"IARA's physical system data","text":"In order to execute the clearing process detailed above, IARA must contain relevant information about the physical units in the system. The IARA database can be thought of as composed by the following components:\n\nThe temporal structure is used to describe underlying features such as the number of \"subperiods\" modeled in each \"period\", as well as the seasonal and/or cyclic nature of the \"periods\" represented in the simulation.\nThe spatial structure describes locations (or \"buses\") available for the physical units to be connected to, in addition to a physical description of available links connecting these buses (which are assumed to be under the control of the system operator).\nThe ownership structure describes the asset owners that control each of the physical units, as well as the \"bidding groups\" according to which different units are grouped together for the purpose of submitting bids. Note that, in a bid-based representation, the system operator will be unable to distinguish between the output of different units in the same bidding group.\nThe unit structure describes the actual physical parameters of each of the available units, which can be represented directly (in a cost-based scheme) or replaced by bids (in a bid-based scheme). This is the most complex structure, with individual parameterizations for each type of physical unit - which includes thermal plants, renewable plants, hydro plants, and demand units. Note that conceptually there is no obstacle to representing demand-side bids in the same structure as other bidding units.\nThe external data structure represents additional supporting data tying into the structures above and which is usually read in the data collection stages of the market clearing process. Most prominently, we have physical time series data which link to the unit structure and the temporal structure and bid time series data which link to the ownership structure, the spatial structure, and the temporal structure.","category":"section"},{"location":"key_features.html#Glossary","page":"Key features of IARA","title":"Glossary","text":"IARA uses some special terminology to describe the components of the clearing process and of the time series files which might be unfamiliar for some users initially. Key points of this nomenclature are summarized below, and are used consistently througout these guides:\n\nRelated to the clearing process:\nEx ante: The default interpretation of the ex ante process should be a \"day-ahead\" market, in which agents submit their bids under partial information (with additional information arriving ex post). More generally, this ex ante process can represent other moments in time, such as an intraday auction. \nEx post: In the nomenclature of many electricity market designs, if the ex ante process is likened to a day-ahead market, the ex post process corresponds to the \"real-time market\" for valuing deviations between day-ahead and real-time.\nCommercial: In some market designs, there is a distinction between the system representation that is used for determining the marginal price and the physical reality of the system. The \"commercial\" representation refers to the subproblem structure that ought to be utilized for the purpose of electricity price formation.\nPhysical: In case a separate \"commercial\" representation is used for determining the system marginal price, it is still important to have a representation that better follows the physical reality. The \"physical\" representation has this purpose, and is used for actual physical production decisions (considering that the system operator would be forced to redispatch units accordingly).\nRelated to the clearing process's subproblems:\nSubproblem type: Along the clearing process, there are in practice four types of subproblem that are built and solved: the ex ante physical subproblem, the ex ante commercial subproblem, the ex post physical subproblem, and the ex post commercial subproblem. In the context of describing market design choices that might be different for each of these, we will sometimes refer to the four \"subproblems\" (rather than \"subproblem types\") of the clearing process.\nSubproblem instances: One \"instance\" of the subproblem represents a particular choice of parameters (depending on the ex ante and/or ex post physical data in addition to bid data) that leads to an optimization problem to be solved. Each of the ex ante subproblem types will yield one instance per period P and scenario S, whereas each of the ex post subproblem types will yield additional instances per subscenario s.\nSubproblem structure: The \"structure\" refers to the exact characterization of the subproblem type for a particular case execution, which involves defining whether physical units will be represented as cost-based, bid-based, hybrid, or virtual reservoir hybrid according to the standard IARA formulation. Note that while the subproblem structure can be complex, it is fully defined by the IARA case options and the subproblem type (with all instances of a given subproblem type having the same structure).\nRelated to time series dimensions:\nPeriod: Each \"period\" refers to one round of the market clearing process (including a set of optimization problems) that is solved sequentially. Note that the duration of each period is a parameter of the database, and therefore while the standard use case would be to represent one \"period\" as one day, it is possible to have each period representing one week or one month, for example. \nSubperiod: Periods are broken down into \"subperiods\", and the optimization problems involving the various units will in practice have constraints associated with the electricity supply-demand balance for each subperiod. As a consequence, physical unit data usually will have a subperiod dimension as well.\nScenario: Each \"scenario\" refers to one round of the market clearing process (including a set of optimization problems) that is solved independently. Because periods of each scenario are linked, scenarios can be understood as parallel trajectories simulated.\nSubscenario: A \"subscenario\" represents an individual realization of ex post uncertainty. Note that, within each round of the market clearing process, each of the ex post subproblems will be evaluated once per subscenario (but not the ex ante subproblems), and in this sense scenarios can be thought of as being broken down into \"subscenarios\". \nCycle: A \"cycle\" is used to represent the fact that periods tend to repeat cyclically (i.e. they start to display the same probability distributions of possible occurrences), usually after one year. It is generally desirable for the simulation to be run for a number of periods greater than the duration of the cycle.\nSeason: The cycle is broken down into \"seasons\" in order to describe the cyclical nature of the problem (with more or less granularity). IARA allows, for example, the representation of 12 \"seasons\" per cycle (typical months) or 52 \"seasons\" per cycle (typical weeks).","category":"section"},{"location":"heuristic_bids.html#From-Physical-Data-to-Bid-Offers","page":"Heuristic bids for bidding groups","title":"From Physical Data to Bid Offers","text":"This document describes the process of transforming physical data from asset owners into bid offers for various unit types, including thermal, renewable, and hydro units.  Bid offers are calculated using predefined formulas that incorporate operational parameters, risk factors, and specific bidding approaches.","category":"section"},{"location":"heuristic_bids.html#Asset-Owner-attributes","page":"Heuristic bids for bidding groups","title":"Asset Owner attributes","text":"I: Set of assets owners\nBG(i): Set of Bidding Groups of asset owner i\nJ^T(b n): Set of thermal units of bidding group b and network node n.\nJ^H(b n): Set of hydro units of bidding group b and network node n.\nJ^R(b n): Set of renewable units of bidding group b and network node n.\nJ^DE(b n): Set of elastic demand units of bidding group b and network node n.\nF(b) Set of risk factors for bidding group b.\nm_f: Risk factor.\ns_f: proportion of the risk factor r in the bidding group b.\nB(t): Set of subperiods in period t.","category":"section"},{"location":"heuristic_bids.html#Parameters","page":"Heuristic bids for bidding groups","title":"Parameters","text":"d(tau): Duration in hours of subperiod tau.","category":"section"},{"location":"heuristic_bids.html#Thermal-Units","page":"Heuristic bids for bidding groups","title":"Thermal Units","text":"The bid offers for thermal units are based on their maximum generation and operational costs.  The maximum generation overlineG^T_j and om cost overlineC^T_j are converted to bid offers by using the following formula:\n\nbeginalign\nQ_i n tau k(omega) = s_f cdot overlineG^T_j cdot d(tau) quad forall k = (j - 1) cdot F(b) + f f in F(b) j in J^T(b n)  \nP_i n tau k(omega) = (1 + m_f) cdot overlineC^T_j quad forall k = (j - 1) cdot F(b) + f f in F(b) j in J^T(b n)\nendalign\n\nWhere:\n\nQ_i n tau k(omega)  represents the bid offer in segment k for energy quantity in period tau, calculated by multiplying the unit’s maximum generation overlineG^T_j, the duration of the subperiod d(tau), and the proportion of the risk factor s_f.\nP_i n tau k(omega) represents the bid offer in segment k for price, calculated by applying a risk factor m_f to the operational cost overlineC^T_j.\n\nThe bid offers are calculated for each thermal unit j in bidding group b and network node n and bid segment k. Each segment represents a combination of thermal unit and risk factor, so the number of segments is the product of the number of thermal units and the number of risk factors in the bidding group.\n\nNote: Other thermal unit attributes are not considered when forming these bid offers.","category":"section"},{"location":"heuristic_bids.html#Renewable-Units","page":"Heuristic bids for bidding groups","title":"Renewable Units","text":"For renewable units, the conversion incorporates the maximum generation G^R_j, the realized generation G^R_j tau(omega) and om cost overlineC^R_j are converted to bid offers by using the following formula:\n\nbeginalign\nQ_i n tau k(omega) = s_f cdot G^R_j tau(omega)cdot G^R_j cdot d(tau) quad forall k = (j - 1) cdot F(b) + f f in F(b) j in J^R(b n)  \nP_i n tau k(omega) = (1 + m_f) cdot overlineC^R_j quad forall k = (j - 1) cdot F(b) + f f in F(b) j in J^R(b n)\nendalign\n\nThe renewable unit bid offers follows the same structure as thermal units, with the exception that the energy quantity is calculated using the realized generation G^R_j tau(omega) instead of the maximum generation.","category":"section"},{"location":"heuristic_bids.html#Demand-Units","page":"Heuristic bids for bidding groups","title":"Demand Units","text":"Demand unit bid offers are derived from the elastic demand d^E_j tau and the demand price P_j tau(omega) are converted into bids by using the following formula:\n\nbeginalign\nQ_i n tau k(omega) = s_f cdot d^E_j tau(omega) quad forall k = (j - 1) cdot F(b) + f f in F(b) j in J^DE(b n)  \nP_i n tau k(omega) = (1 + m_f) cdot P_j tau(omega) quad forall k = (j - 1) cdot F(b) + f f in F(b) j in J^DE(b n)\nendalign","category":"section"},{"location":"heuristic_bids.html#Hydro-Units","page":"Heuristic bids for bidding groups","title":"Hydro Units","text":"For hydro units that are not associated to virtual reservoirs, the bid offers are derived from a Minimum Cost Run, where the generation output g^H_j tau and opportunity cost pi^H_j tau are converted into bids. The conversion is performed using the following formulas:\n\nbeginalign\nQ_j n tau k(omega) = s_f cdot g^H_j tau(omega) quad forall k = (j - 1) cdot F(b) + f f in F(b) j in J^H(b n)  \nP_j n tau k(omega) = (1 + m_f) cdot pi^H_j tau quad forall k = (j - 1) cdot F(b) + f f in F(b) j in J^H(b n)\nendalign\n\nIn the Independent Bids approach, it has the same structure as thermal and renewable units, with the exception that the energy quantity is calculated using the generation output g^H_j tau(omega) instead of the maximum generation. This is just a simplification of the bid offer calculation. ","category":"section"},{"location":"tutorial/case_06_run_policy_graph.html#Policy-Graphs-Running","page":"Policy graphs example: running","title":"Policy Graphs - Running","text":"The data for this case is available in the folder data/case_6","category":"section"},{"location":"tutorial/case_06_run_policy_graph.html#Recap","page":"Policy graphs example: running","title":"Recap","text":"In this tutorial, we explore the differences between two types of policy graphs, linear and cyclic, using a simple model with varying numbers of periods. The model contains one zone, one bus, one demand point, one hydro unit, and one thermal unit. We will analyze how changes in policy graph types affect the decision-making process in centralized operations, focusing on the impact of different configurations of periods.\n\nWe'll start by importing the necessary packages.\n\nusing Dates\nusing DataFrames\nusing IARA\n; #hide\nnothing #hide\n\nFirst, let's create a folder that will contain the execution for each iteration.\n\nconst PATH_ORIGINAL = joinpath(@__DIR__, \"data\", \"case_6\")\n\nconst PATH_EXECUTION = joinpath(@__DIR__, \"case_6_execution\")\nif !isdir(PATH_EXECUTION)\n    mkdir(PATH_EXECUTION)\nend","category":"section"},{"location":"tutorial/case_06_run_policy_graph.html#Running-the-Case:-Linear-Policy-Graph-with-2-Stages","page":"Policy graphs example: running","title":"Running the Case: Linear Policy Graph with 2 Stages","text":"Let's create a copy of the original case.\n\nconst PATH_LINEAR_2 = joinpath(PATH_EXECUTION, \"linear_2\")\nif !isdir(PATH_LINEAR_2)\n    mkdir(PATH_LINEAR_2)\nend\n\ncp(PATH_ORIGINAL, PATH_LINEAR_2; force = true);\nnothing #hide\n\nIn the previous section we created a case with 2 periods and a linear policy graph. Therefore, we do not need to update the number of periods or the policy graph type.\n\nLet's begin by running the case with a linear policy graph and 2 periods. This scenario simulates a situation where decision-making happens over two periods with no cyclic behavior.\n\nIARA.train_min_cost(PATH_LINEAR_2)","category":"section"},{"location":"tutorial/case_06_run_policy_graph.html#Analyzing-the-results","page":"Policy graphs example: running","title":"Analyzing the results","text":"Here's the graph of the final volume at each period\n\nhydro_final_volume_all =\n    joinpath(PATH_LINEAR_2, \"outputs\", \"hydro_final_volume.csv\") # hide\nIARA.custom_plot(\n    hydro_final_volume_all,\n    IARA.PlotTimeSeriesQuantiles;\n    title = \"Reservoir Final Volume\",\n    agents = [\"Hydro1\"],\n    period = 1:2,\n)\n\nFor this case, the optimal strategy for the hydro unit is to release water in the last period. This happens because there are no future costs associated with the last period, encouraging full use of available resources.","category":"section"},{"location":"tutorial/case_06_run_policy_graph.html#Running-the-Case:-Linear-Policy-Graph-with-10-Stages","page":"Policy graphs example: running","title":"Running the Case: Linear Policy Graph with 10 Stages","text":"Next, we increase the number of periods to 10 while keeping the policy graph linear. This allows us to see how a longer planning horizon influences the decision-making process.\n\nconst PATH_LINEAR_10 = joinpath(PATH_EXECUTION, \"linear_10\")\n\nif !isdir(PATH_LINEAR_10)\n    mkdir(PATH_LINEAR_10)\nend\n\ncp(PATH_ORIGINAL, PATH_LINEAR_10; force = true);\nnothing #hide\n\nNow we need to update the number of periods to 10.\n\ndb = IARA.load_study(PATH_LINEAR_10; read_only = false)\n\nIARA.update_configuration!(\n    db;\n    number_of_periods = 10,\n)\n\nWe will also update the inflow and demand time series files to have 10 periods.\n\nIARA.link_time_series_to_file(\n    db,\n    \"DemandUnit\";\n    demand_ex_ante = \"demands_10_periods\",\n)\n\nIARA.link_time_series_to_file(\n    db,\n    \"HydroUnit\";\n    inflow_ex_ante = \"inflow_10_periods\",\n)\n\nIARA.close_study!(db)\n\nLet's run the case.\n\nIARA.train_min_cost(PATH_LINEAR_10)","category":"section"},{"location":"tutorial/case_06_run_policy_graph.html#Analyzing-the-results-2","page":"Policy graphs example: running","title":"Analyzing the results","text":"Here's the graph of the final volume at each period\n\nhydro_final_volume_all =\n    joinpath(PATH_LINEAR_10, \"outputs\", \"hydro_final_volume.csv\") # hide\nIARA.custom_plot(\n    hydro_final_volume_all,\n    IARA.PlotTimeSeriesQuantiles;\n    title = \"Reservoir Final Volume\",\n    agents = [\"Hydro1\"],\n    period = 1:2,\n)\n\nWith 10 periods, the model accounts for a longer planning horizon, influencing the decision to release water more conservatively in earlier periods. The hydro unit no longer empties the reservoir in a single burst but instead manages water levels more carefully over time, anticipating future periods.\n\nIARA.custom_plot(\n    hydro_final_volume_all,\n    IARA.PlotTimeSeriesQuantiles;\n    title = \"Reservoir Final Volume\",\n    agents = [\"Hydro1\"],\n    period = 3:10,\n)\n\nAs the planning horizon progresses, the model becomes more aggressive in its approach, depleting the reservoir by the end of the fourth year.","category":"section"},{"location":"tutorial/case_06_run_policy_graph.html#Running-the-Case:-Cyclic-Policy-Graph-with-2-Stages","page":"Policy graphs example: running","title":"Running the Case: Cyclic Policy Graph with 2 Stages","text":"Now, we will switch the policy graph to cyclic, which assumes that the decision-making process repeats over time.\n\nconst PATH_CYCLIC_2 = joinpath(PATH_EXECUTION, \"cyclic_2\")\n\nif !isdir(PATH_CYCLIC_2)\n    mkdir(PATH_CYCLIC_2)\nend\n\ncp(PATH_ORIGINAL, PATH_CYCLIC_2; force = true);\nnothing #hide\n\nNow we need to update the policy graph type to CYCLIC_WITH_NULL_ROOT.\n\ndb = IARA.load_study(PATH_CYCLIC_2; read_only = false)\n\nIARA.update_configuration!(\n    db;\n    number_of_periods = 2,\n    policy_graph_type = IARA.Configurations_PolicyGraphType.CYCLIC_WITH_NULL_ROOT,\n)\n\nWe will also update the inflow and demand time series files to have 2 periods, and replace the period dimension with season, as required for cyclic cases.\n\nIARA.link_time_series_to_file(\n    db,\n    \"DemandUnit\";\n    demand_ex_ante = \"demands_by_season\",\n)\n\nIARA.link_time_series_to_file(\n    db,\n    \"HydroUnit\";\n    inflow_ex_ante = \"inflow_by_season\",\n)\n;\n\nIARA.close_study!(db)\n; #hide\nnothing #hide\n\nLet's run the case.\n\nIARA.train_min_cost(PATH_CYCLIC_2)","category":"section"},{"location":"tutorial/case_06_run_policy_graph.html#Analyzing-the-results-3","page":"Policy graphs example: running","title":"Analyzing the results","text":"Here's the graph of the final volume at each period\n\nhydro_final_volume_all =\n    joinpath(PATH_CYCLIC_2, \"outputs\", \"hydro_final_volume.csv\") # hide\nIARA.custom_plot(\n    hydro_final_volume_all,\n    IARA.PlotTimeSeriesQuantiles;\n    title = \"Reservoir Final Volume\",\n    agents = [\"Hydro1\"],\n    period = 1:2,\n)\n\nWith a cyclic policy graph, the decision-making process becomes more dynamic. The hydro unit is now planning with the expectation that the periods will repeat, creating an incentive to maintain a certain level of water in the reservoir.","category":"section"},{"location":"tutorial/case_06_run_policy_graph.html#Conclusion","page":"Policy graphs example: running","title":"Conclusion","text":"Through these simulations, we observe significant differences between linear and cyclic policy graphs. In the 2-period linear setup, the model chooses an aggressive strategy at the end of the first year, since there is no incentive to conserve water for future periods. This short-term focus leads to a rapid depletion of the reservoir.\n\nWith 10 periods in the linear policy graph, the model's approach becomes more conservative, water levels are managed more carefully during the early years, reflecting a longer-term outlook. However, the reservoir is still emptied by the end of the fourth year, indicating a gradual shift toward resource depletion as the planning horizon progresses.\n\nIn contrast, the cyclic policy graph with 2 periods adds a dynamic element to the decision-making process. Here, the hydro unit balances the immediate need for power generation with the understanding that the periods will repeat, encouraging more sustainable water management across cycles.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"tutorial/first_execution.html#My-first-execution","page":"My first execution","title":"My first execution","text":"In this tutorial, we will load an example case, analyze its input data, execute the model and assess the results obtained. This case contains some basic elements that can help understand some of the functionalities of the IARA package.","category":"section"},{"location":"tutorial/first_execution.html#First-steps","page":"My first execution","title":"First steps","text":"We'll start by indicating we are using the IARA package - assuming it is already installed (otherwise, see the Installation Guide) - and defining a directory to store the example case we will analyze.\n\nusing IARA\nconst case_path = joinpath(@__DIR__, \"data\", \"ExampleCase_boto_base_01\")\n; #hide\nnothing #hide\n\nIARA has a number of pre-defined example cases that can be used to explore the model's functionalities. These example cases have standardized names and, for this example, we will use the one named boto_base_01 - which means that we are representing a fictional physical system named boto in a variant named base and a subvariant 01.\n\nTo load this example case, we can use the function IARA.ExampleCases.build_example_case, indicating the path in which the files must be stored (the case_path defined), as well as the name of the example case to be loaded (as mentioned above, this is an internal name used in IARA).\n\ncase_name = \"boto_base_01\"\nIARA.ExampleCases.build_example_case(case_path, case_name)\n; #hide\nnothing #hide\n\nBesides using example cases in their default configurations, it is also possible to edit a case's physical data, or even build a case from scratch. For now, let's stick to this example case as it is defined.","category":"section"},{"location":"tutorial/first_execution.html#Analyzing-input-data","page":"My first execution","title":"Analyzing input data","text":"After loading (or creating or editing) a case, it is possible to analyze the input data using the IARA.summarize function. This function describes briefly the case's key characteristics, as shown below.\n\nThe first block indicates the execution options considered in the study. IARA is inherently multistage stochastic, and the output below indicates that the execution will be run for 6 periods, using 3 scenarios and 4 subscenarios. The following block, Collections, indicates the number of elements of each type in the database. In particular, Units (RenewableUnit, HydroUnit, ThermalUnit and DemandUnit) can either be represented directly, with an explicit modelling of their physical characteristics (under a cost-based representation), or represented as BiddingGroups, in which case their modelling will depend on an AssetOwner's preferred strategy (under a bid-based representation). Finally, the summary also lists the external files considered, which contatin stochastic data that will be taken into account when building the market clearing problem.\n\nIARA.summarize(case_path)","category":"section"},{"location":"tutorial/first_execution.html#Execution","page":"My first execution","title":"Execution","text":"Since this example case already contains all the basic data required, we can now run the market clearing in the IARA model. For that, we must first define the folder in which the output files will be stored. This will be created as subfolder of the case_path folder defined above.\n\npath01_first_execution = joinpath(case_path, \"01_first_execution\")\n; #hide\nnothing #hide\n\nThen, the execution can be carried out using the IARA.market_clearing function, indicating the case path and the output path defined, as follows:\n\nIARA.market_clearing(case_path; output_path = path01_first_execution);\n#hide\n\nAfter successfully executing the model, the output path will be filled with several output files, including a subfolder containing automatically generated plots. The final folder structure is as presented below.\n\nThe case_path folder contains, besides the output folder (in our example, named output01_first_execution), the case's input files. The output01_first_execution folder contains, besides the plots folder, raw outputs of the model execution, in .csv and .tomlL formats. The plots folder contains several _.html files, which lead to graphic visualizations (dashboards) of the outputs.\n\ncase_path\n ├── output01_first_execution\n │    ├── plots\n │    └── ...\n └── ...","category":"section"},{"location":"tutorial/first_execution.html#Assessing-outputs","page":"My first execution","title":"Assessing outputs","text":"Now, we can examine the outputs obtained in the execution. As an example, we can take a look at the marginal cost results. You can either open this plot directly from the plot subfolder (the file should be named load_marginal_cost_ex_post_physical_avg.html) or run the IARA.custom_plot function referring to the output file load_marginal_cost_ex_post_physical.csv, as shown below. More information about this functionality can be found in the plots tutorial.\n\ncmg_name = \"load_marginal_cost_ex_post_physical.csv\"\ncmg_path = joinpath(path01_first_execution, cmg_name)\nIARA.custom_plot(cmg_path, IARA.PlotTimeSeriesQuantiles)\n\nBecause the boto_base_01 example case has 2 buses, there are 2 sets of marginal costs data represented, corresponding respectively to the Eastern and Western buses. On the horizontal axis, we have 6 periods represented sequentially (summer, winter, winter, winter, summer, summer), with each period broken down into 3 subperiods (morning, afternoon, evening). There is variation of marginal costs within each period and subperiod, due to the presence of scenarios and subscenarios, which result in the bands shown in the image. Note that all 3 periods corresponding to summer have the same underlying probability distribution, and the same is true for the 3 periods corresponding to winter.\n\nThe marginal cost result is an output of the market clearing optimization problem, which dispatches the available units under a least cost criterion, taking into account stochastic resource availability. It can be seen that the winter periods typically present higher marginal costs than summer periods and that so does the Western bus in comparison with the Eastern bus.","category":"section"},{"location":"tutorial/first_execution.html#Next-steps","page":"My first execution","title":"Next steps","text":"In addition to this initial page, there are other Getting started guides, which aim to provide an initial overview of the main functionalities of the IARA model. You can access the following pages to continue this tutorial:\n\nEditing physical data describes the procedure to edit a case's physical input data, such as system elements;\nEditing clearing options addresses details of different clearing configurations that can be considered;\nHeuristic bid pre-processing details the procedure applied to generate the agents' bids in the bid-based representation;\nSDDP pre-processing presents the pre-execution treatment that must be given to cases that include hydro reservoirs.\n\nIf you are already familiar with these procedures, you can look into more general practical use guides:\n\nBuilding a case from scratch shows how to build completely new cases, initializing the study, defining execution options and adding elements;\nManipulating bid data describes how to manually define agents' bids in the model, rather than using the ones bids built by the model itself;\nManipulating the case's temporal structure details how periods and subperiods relate temporally in the model's framework;\nExploring custom plots illustrates how to generate customized visualizations of the results.\n\nAlternatively, you can delve into more conceptual descriptions:\n\nKey features of the IARA model, from physical data to clearing options;\nMarket clearing structure, including the market iterations comprised in the model and the execution modes available;\nAspects of hydro systems that were taken into account when designing conceptual IARA features;\nConceptual mathematical formulation of the different problem representations supported by IARA.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"tutorial/case_04_build_multi_min_activation.html#Min-activation-Bid-Building","page":"Minimum activation bids example","title":"Min activation Bid - Building","text":"The data for this case is available in the folder data/case_4\n\nWe'll start by importing the necessary packages.\n\nusing Dates\nusing Quiver\nusing DataFrames\nusing IARA\n; #hide\nnothing #hide\n\nIn this tutorial, we will start with the Case 3 elements and create a case with a minimum activation level for a Bidding Group.","category":"section"},{"location":"tutorial/case_04_build_multi_min_activation.html#Original-Case-Recap","page":"Minimum activation bids example","title":"Original Case Recap","text":"In the original case we had two Bidding Groups, one with a profile bid and the other with an independent bid. Running the MARKET_CLEARING mode, we analyzed the effect of the profile bid in the market.","category":"section"},{"location":"tutorial/case_04_build_multi_min_activation.html#Changes-for-this-tutorial","page":"Minimum activation bids example","title":"Changes for this tutorial","text":"In this tutorial, we will add a minimum activation level for the Bidding Group with the profile bid.","category":"section"},{"location":"tutorial/case_04_build_multi_min_activation.html#Loading-case","page":"Minimum activation bids example","title":"Loading case","text":"Now let's copy the base case to a new folder and load it.\n\nconst PATH_ORIGINAL = joinpath(@__DIR__, \"data\", \"case_3\")\n\nconst PATH_MIN_ACTIVATION = joinpath(@__DIR__, \"data\", \"case_4\")\n\nif !isdir(PATH_MIN_ACTIVATION)\n    mkdir(PATH_MIN_ACTIVATION)\nend\n\ncp(\n    joinpath(PATH_ORIGINAL, \"study.iara\"),\n    joinpath(PATH_MIN_ACTIVATION, \"study.iara\");\n    force = true,\n)\n\ndb = IARA.load_study(PATH_MIN_ACTIVATION; read_only = false);\n#hide","category":"section"},{"location":"tutorial/case_04_build_multi_min_activation.html#Minimum-Activation-Level-Time-series","page":"Minimum activation bids example","title":"Minimum Activation Level Time series","text":"In the data/case_4 folder, we have a time series files for the minimum activation level for the Bidding Group with the profile bid. Let's take a quick look at the file and load it into the database.\n\nIARA.time_series_dataframe(\n    joinpath(PATH_MIN_ACTIVATION, \"minimum_activation_level_profile.csv\"),\n)\n\nIARA.time_series_dataframe(\n    joinpath(PATH_MIN_ACTIVATION, \"parent_profile.csv\"),\n)\n\nIARA.time_series_dataframe(\n    joinpath(PATH_MIN_ACTIVATION, \"complementary_grouping_profile.csv\"),\n)\n\nIARA.link_time_series_to_file(\n    db,\n    \"BiddingGroup\";\n    minimum_activation_level_profile = \"minimum_activation_level_profile\",\n    parent_profile = \"parent_profile\",\n    complementary_grouping_profile = \"complementary_grouping_profile\",\n)\n; #hide\nnothing #hide","category":"section"},{"location":"tutorial/case_04_build_multi_min_activation.html#Closing-the-case","page":"Minimum activation bids example","title":"Closing the case","text":"IARA.close_study!(db)\n; #hide\nnothing #hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"iara_platform.html#IARA-Platform","page":"IARA Platform","title":"IARA Platform","text":"As discussed in this documentation, IARA.jl uses several concepts from electricity markets, which can be complex to understand. That said, along with IARA.jl, we have developed a web platform called IARA Platform that allows users to participate in an energy market simulation, where they can play the role of an Asset Owner or System Operator. For now, the IARA Platform is only available in Portuguese.\n\n(Image: IARA Platform Screenshot)\n\nIn a game, each user is assigned to an Asset Owner by the System Operator, who is responsible for executing the optimization problem after all users have submitted their bids. A user's bid, which consists of a quantity and price bid, should be chosen by the user based on their knowledge of the market and their assets.\n\n(Image: IARA Platform Bidding)","category":"section"},{"location":"iara_platform.html#Single-Period-Market-Clearing","page":"IARA Platform","title":"Single Period Market Clearing","text":"In the Key Features section, we explained IARA.jl's Market Clearing Process, which optimizes the dispatch of assets based on the bids submitted by asset owners. In this case, the problem's time horizon can vary and have multiple time steps, which are depicted by the period and subperiod dimensions. Additionally, the subperiod duration can vary and is defined by the subperiod_duration parameter during the formulation of the problem.\n\nIn the web platform, however, in order to simplify the user experience, we consider the notion of a game being comprised of rounds, where each round is treated a a single period. This single period is then divided into subperiods, each representing one hour of the day.\n\nWhen executing a round, IARA.jl performs the single period market clearing process by calling the IARA.single_period_market_clearing function, which considers the bids submitted by the users for the current round and outputs specialized plots for the web platform. The results of the market clearing process are then displayed to the users, allowing them to visualize the dispatch of assets and the prices determined by the market.\n\n(Image: IARA Platform Bidding)","category":"section"},{"location":"iara_platform.html#Features","page":"IARA Platform","title":"Features","text":"","category":"section"},{"location":"iara_platform.html#Price-Violation","page":"IARA Platform","title":"Price Violation","text":"The IARA Platform includes a validation routine that checks if the price bids submitted by the users are within the allowed range for their assets. At Bid Price Limit, you can find more information about how the price limits are calculated by IARA.jl.\n\nThere are two main price thresholds that are considered in the validation routine:\n\nNon justified bid: If the price bid is below this limit, the user is not required to justify their bid. \n\nHowever, if the price bid is above this limit, the user must provide a justification for their bid in a text box.\n\n(Image: IARA Platform Bidding)\n\nJustified bid: If the price bid is above this limit, the user cannot submit their bid, even if they provide a justification.\n\n(Image: IARA Platform Bidding)\n\nAfter the round is executed, the System Operator can review the justifications provided by the users in the results section.\n\n(Image: IARA Platform Bidding)","category":"section"},{"location":"tutorial/case_02_run_hydrounit_base_case.html#Hydro-Base-Case-Running","page":"Hydro Base Case - Running","title":"Hydro Base Case - Running","text":"The data for this case is available in the folder data/case_2\n\nusing Dates\nusing DataFrames\nusing IARA\n; #hide\nnothing #hide\n\nIn the previous section, we have loaded the base case and added a Hydro Unit to it. Now, we will run this case in two different run modes:\n\nTRAIN_MIN_COST\nMARKET_CLEARING\n\nLet's create a folder to store each run mode output and define the path to the original case.\n\nconst PATH_EXECUTION = joinpath(@__DIR__, \"case_2_execution\")\nif !isdir(PATH_EXECUTION)\n    mkdir(PATH_EXECUTION)\nend\n\nconst PATH_ORIGINAL = joinpath(@__DIR__, \"data\", \"case_2\")\n; #hide\nnothing #hide\n\nnote: Note\nAs we have a Hydro Unit in this case, running the TRAIN_MIN_COST mode before the MARKET_CLEARING mode is necessary, as it will help us generate the hydro bids.\n\nSo, before running our case, let's review some information about it.","category":"section"},{"location":"tutorial/case_02_run_hydrounit_base_case.html#Case-Recap","page":"Hydro Base Case - Running","title":"Case Recap","text":"Periods Subperiods Scenarios Subperiod duration (hours) Yearly discount rate\n2 1 12 24 10%\n\nTechnology Name Owner Maximum Generation (MW) Cost ($/MWh)\nRenewable Solar1 Price Taker 80 \nThermal Thermal1 Thermal Owner 20 10\nThermal Thermal2 Price Taker 20 30\nThermal Thermal3 Thermal Owner 20 100\nThermal Thermal4 Price Taker 20 300\nThermal Thermal5 Price Taker 50 1000\nThermal Thermal6 Price Taker 50 3000\nHydro Hydro1 Hydro Owner 80 ","category":"section"},{"location":"tutorial/case_02_run_hydrounit_base_case.html#Centralized-Operation","page":"Hydro Base Case - Running","title":"Centralized Operation","text":"First let's copy the original case to a new folder.\n\nconst PATH_CENTRALIZED = joinpath(PATH_EXECUTION, \"centralized\")\n\nif !isdir(PATH_CENTRALIZED)\n    mkdir(PATH_CENTRALIZED)\nend\n\ncp(PATH_ORIGINAL, PATH_CENTRALIZED; force = true);\n#hide\n\nNow, let's run the case with IARA.train_min_cost.\n\nIARA.train_min_cost(\n    PATH_CENTRALIZED;\n    delete_output_folder_before_execution = true,\n)","category":"section"},{"location":"tutorial/case_02_run_hydrounit_base_case.html#Analyzing-the-results","page":"Hydro Base Case - Running","title":"Analyzing the results","text":"The results are stored inside the case folder, in the outputs directory.\n\ncase_folder\n ├── outputs\n │    ├── plots\n │    │   └── ...\n │    └── ...\n └── ...\n\nAs we have seen before, IARA provides a set of plots to help us analyze the results. Let's take a look at some of them.\n\nLet's take a look into some of the plots generated automatically.\n\n<iframe src=\"case_2_execution\\\\centralized\\\\outputs\\\\plots\\\\load_marginal_cost_all.html\" style=\"height:500px;width:100%;\"></iframe>\n\n<iframe src=\"case_2_execution\\\\centralized\\\\outputs\\\\plots\\\\renewable_generation_all.html\" style=\"height:500px;width:100%;\"></iframe>\n\n<iframe src=\"case_2_execution\\\\centralized\\\\outputs\\\\plots\\\\thermal_generation_all.html\" style=\"height:500px;width:100%;\"></iframe>\n\n<iframe src=\"case_2_execution\\\\centralized\\\\outputs\\\\plots\\\\hydro_generation_all.html\" style=\"height:500px;width:100%;\"></iframe>","category":"section"},{"location":"tutorial/case_02_run_hydrounit_base_case.html#Market-Clearing","page":"Hydro Base Case - Running","title":"Market Clearing","text":"Now that we have the hydro bids from the TRAIN_MIN_COST mode, we can run the MARKET_CLEARING mode.\n\nLet's copy the data from the TRAIN_MIN_COST mode to a new folder. The hydro bids are in the outputs folder inside the centralized folder. For our case, we need to move this files to the root of the case folder.\n\nconst PATH_MARKET_CLEARING = joinpath(PATH_EXECUTION, \"market_clearing\")\n\nif !isdir(PATH_MARKET_CLEARING)\n    mkdir(PATH_MARKET_CLEARING)\nend\n\ncp(PATH_CENTRALIZED, PATH_MARKET_CLEARING; force = true)\ncp(\n    joinpath(PATH_MARKET_CLEARING, \"outputs\", \"hydro_generation.csv\"),\n    joinpath(PATH_MARKET_CLEARING, \"hydro_generation.csv\");\n    force = true,\n)\ncp(\n    joinpath(PATH_MARKET_CLEARING, \"outputs\", \"hydro_generation.toml\"),\n    joinpath(PATH_MARKET_CLEARING, \"hydro_generation.toml\");\n    force = true,\n)\n\ncp(\n    joinpath(PATH_MARKET_CLEARING, \"outputs\", \"hydro_opportunity_cost.csv\"),\n    joinpath(PATH_MARKET_CLEARING, \"hydro_opportunity_cost.csv\");\n    force = true,\n)\ncp(\n    joinpath(PATH_MARKET_CLEARING, \"outputs\", \"hydro_opportunity_cost.toml\"),\n    joinpath(PATH_MARKET_CLEARING, \"hydro_opportunity_cost.toml\");\n    force = true,\n)\n; #hide\nnothing #hide\n\nBefore running, we need to load the case and set the run mode to MARKET_CLEARING and configure the bid processing to use parameterized heuristic bids without validation.\n\ndb = IARA.load_study(PATH_MARKET_CLEARING; read_only = false)\n\nIARA.update_configuration!(\n    db;\n    bid_processing = IARA.Configurations_BidProcessing.PARAMETERIZED_HEURISTIC_BIDS,\n    bid_price_validation = IARA.Configurations_BidPriceValidation.DO_NOT_VALIDATE,\n    construction_type_ex_ante_physical = IARA.Configurations_ConstructionType.HYBRID,\n    construction_type_ex_ante_commercial = IARA.Configurations_ConstructionType.HYBRID,\n    construction_type_ex_post_physical = IARA.Configurations_ConstructionType.HYBRID,\n    construction_type_ex_post_commercial = IARA.Configurations_ConstructionType.HYBRID,\n)\n; #hide\n\nIARA.close_study!(db)\n\nNow, let's run the case with IARA.market_clearing.\n\nIARA.market_clearing(\n    PATH_MARKET_CLEARING;\n    delete_output_folder_before_execution = true,\n)\n\nLet's take a look into some of the plots generated automatically.\n\n<iframe src=\"case_2_execution\\\\market_clearing\\\\outputs\\\\plots\\\\bidding_group_price_bid_all.html\" style=\"height:500px;width:100%;\"></iframe>\n\n<iframe src=\"case_2_execution\\\\market_clearing\\\\outputs\\\\plots\\\\bidding_group_energy_bid_all.html\" style=\"height:500px;width:100%;\"></iframe>\n\n<iframe src=\"case_2_execution\\\\market_clearing\\\\outputs\\\\plots\\\\bidding_group_generation_ex_ante_commercial_all.html\" style=\"height:500px;width:100%;\"></iframe>\n\n<iframe src=\"case_2_execution\\\\market_clearing\\\\outputs\\\\plots\\\\bidding_group_generation_ex_post_commercial_all.html\" style=\"height:500px;width:100%;\"></iframe>\n\n<iframe src=\"case_2_execution\\\\market_clearing\\\\outputs\\\\plots\\\\hydro_generation_ex_post_physical_all.html\" style=\"height:500px;width:100%;\"></iframe>\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"intro_policy_graph.html#Introduction:-Policy-graph","page":"Introduction","title":"Introduction: Policy graph","text":"The best way to learn is by doing - we ecourage you to explore the tutorial for building and running a database with a more complex policy graph structure.","category":"section"},{"location":"intro_policy_graph.html#The-temporal-structure-and-a-visual-representation-of-cyclicality","page":"Introduction","title":"The temporal structure and a visual representation of cyclicality","text":"When building a case from scratch, creating the temporal structure using the language of the policy graph is one of the first necessary steps. The following study parameters are used in practice to guide the construction of the policy graph: \n\nnumber_of_subperiods\nsubperiod_duration_in_hours\nexpected_number_of_repeats_per_node\ncycle_duration_in_hours\ncycle_discount_rate\npolicy_graph_type\n\nA visual representation of the cyclicality between seasons is represented in the image below (for a simple example that only includes two seasons, Summer and Winter). Note the relationship between the parameters displayed in the picture and the parameters input to the database:\n\nt represents the duration of each season's \"representative subproblem\", which depends on the number_of_subperiods and subperiod_duration_in_hours parameters.\nq represents a probability that the simulation will \"terminate\" after solving a season's \"representative subproblem\", which is used in practice to represent a discount rate (future periods are valued less because there is a probability that they will never be reached). This parameter is calculated based on the cycle_discount_rate and the cycle_duration_in_hours, and it also depends on the duration t.\np represents the probability that the same season will repeat once again after the season's \"representative subproblem\" is solved, provided that the simulation does not terminate. This parameter is calculated based on the expected_number_of_repeats_per_node.\n\n(Image: Diagram)\n\nNote that the probability that the simulation will move forward to the next season is fully given by the parameters p and q: if the simulation does not terminate and the current season does not repeat, the only remaining alternative is to move forward to the next season. This structure generalizes easily to a case with more than two seasons: in a 12-season model used to represent typical months, after each January (for example) there are only three possibilities: either the simulation terminates (with probability q), or the typical month of January will \"repeat\" in the next period, implying that January typical month data will be used once again as the input (with conditional probability p), or the simulation will move forward and the following period will be represented with probability distributions representative of the typical month of February.","category":"section"},{"location":"intro_policy_graph.html#Linear-and-cyclic-policy-graphs","page":"Introduction","title":"Linear and cyclic policy graphs","text":"The policy_graph_type parameter's goal is to choose whether the intertemporal optimization will consider a cyclic representation (IARA's default) or a linear one.\n\nIn a cyclic policy graph, the periods are connected in a cyclic sequence: there is one \"future cost function\" per season, and the decisions made in the last season will affect the decisions in the first season.\nIn a linear policy graph, the periods are connected in a linear sequence: there is one \"future cost function\" per period, and the decisions made in the last period do not affect any other decisions (as the simulation terminates).\n\nEven in a linear policy graph, the probability of repeating the current season (represented by p in the diagram above) is still applied. The key distinction of the linear policy graph representation is that it does not assume cyclicality, and therefore does not impose that the future cost function in the Spring of 2025 is the same as the future cost function in the Spring of 2026, despite these two dates referring to the same season. Even though there are applications in which a linear policy graph can be more suitable, the cyclic policy graph that IARA uses as a default is intended to reduce the number of future cost functions that need to be estimated and accelerate convergence - with the underlying assumption that the system's supply-demand balance does not change substantially along the years to make a significant difference.\n\nFor more details on linear policy graphs and cyclic policy graphs, see the SDDP.jl documentation.","category":"section"},{"location":"tutorial/case_05_build_reservoir_case.html#Virtual-Reservoir-Building","page":"Virtual reservoir example","title":"Virtual Reservoir - Building","text":"The data for this case is available in the folder data/case_5","category":"section"},{"location":"tutorial/case_05_build_reservoir_case.html#Virtual-Reservoir-overview","page":"Virtual reservoir example","title":"Virtual Reservoir overview","text":"Before getting into the details of the case, let's understand the concept of a virtual reservoir.\n\nA virtual reservoir is a mechanism to aggregate multiple hydro units into a single entity. More than one Asset Owner can be linked into the same Virtual Reservoir\n\nEach Asset Owner has an inflow allocation and an initial energy account share. The inflow allocation is the percentage of inflow that each Asset Owner has in the Virtual Reservoir. The initial energy account share is used to compute the initial energy in the Virtual Reservoir for each Asset Owner.","category":"section"},{"location":"tutorial/case_05_build_reservoir_case.html#Case-overview","page":"Virtual reservoir example","title":"Case overview","text":"In this case, we will have two Hydro Units and two Asset Owners linked to a single Virtual Reservoir. The inflow allocation for the first Asset Owner is 40%, and for the second Asset Owner is 60%. The initial energy account share will be the same as the inflow allocation.\n\nThe second Asset Owner will place higher bids than the first Asset Owner. So what we expect is that the first Asset Owner will be generating more energy in the beginning and, as the energy of the first Asset Owner decreases, the second Asset Owner will start generating more energy.\n\nAlso, the hydro units will be in a cascade relationship, where the first hydro unit will be able to turbine and spill water to the second hydro unit.\n\nIt is necessary to associate each hydro unit with a bidding group. In this case, we will use the same bidding group for both hydro units.","category":"section"},{"location":"tutorial/case_05_build_reservoir_case.html#Creating-the-case","page":"Virtual reservoir example","title":"Creating the case","text":"We'll start by importing the necessary packages.\n\nusing Dates\nusing DataFrames\nusing IARA\n; #hide\nnothing #hide\n\nThe case will have the following characteristics\n\nnumber_of_periods = 3\nnumber_of_scenarios = 1\nnumber_of_subperiods = 4\nsubperiod_duration_in_hours = 1000.0 / number_of_subperiods\ncycle_duration_in_hours =\n    subperiod_duration_in_hours * number_of_subperiods * number_of_periods\n; #hide\nnothing #hide\n\nLet's define a few conversion factors that we will use later.\n\nm3_per_second_to_hm3_per_hour = 3600.0 / 1e6\n; #hide\nnothing #hide\n\nAs we have done in the previous tutorials, we will start by creating a new case.\n\nconst PATH_CASE = joinpath(@__DIR__, \"data\", \"case_5\")\n\ndb = IARA.create_study!(PATH_CASE;\n    number_of_periods = number_of_periods,\n    number_of_scenarios = number_of_scenarios,\n    number_of_subperiods = number_of_subperiods,\n    initial_date_time = \"2020\",\n    subperiod_duration_in_hours = [\n        subperiod_duration_in_hours for _ in 1:number_of_subperiods\n    ],\n    policy_graph_type = IARA.Configurations_PolicyGraphType.LINEAR,\n    cycle_discount_rate = 0.0,\n    cycle_duration_in_hours = cycle_duration_in_hours,\n    demand_deficit_cost = 500.0,\n    bid_processing = IARA.Configurations_BidProcessing.READ_BIDS_FROM_FILE,\n    bid_price_validation = IARA.Configurations_BidPriceValidation.DO_NOT_VALIDATE,\n    demand_scenarios_files = IARA.Configurations_UncertaintyScenariosFiles.ONLY_EX_ANTE,\n    inflow_scenarios_files = IARA.Configurations_UncertaintyScenariosFiles.ONLY_EX_ANTE,\n)\n; #hide\nnothing #hide","category":"section"},{"location":"tutorial/case_05_build_reservoir_case.html#Zone-and-Bus","page":"Virtual reservoir example","title":"Zone and Bus","text":"Let's add a zone and a bus to our case. This case will have a single zone and a single bus for simplicity.\n\nIARA.add_zone!(db; label = \"zone_1\")\n\nIARA.add_bus!(db; label = \"bus_1\", zone_id = \"zone_1\")","category":"section"},{"location":"tutorial/case_05_build_reservoir_case.html#Hydro-Unit","page":"Virtual reservoir example","title":"Hydro Unit","text":"Now we can add our hydro units that will be linked to the virtual reservoir.\n\nIARA.add_hydro_unit!(db;\n    label = \"hydro_1\",\n    initial_volume = 100.0,\n    bus_id = \"bus_1\",\n    minimum_outflow_violation_cost = 600.0,\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = 1,\n        production_factor = 1000.0 * m3_per_second_to_hm3_per_hour,\n        max_generation = 400.0,\n        min_volume = 0.0,\n        max_turbining = 400.0 / m3_per_second_to_hm3_per_hour, # maybe it is 0.4 instead of 400\n        max_volume = 2000.0,\n        min_outflow = 0.3 / m3_per_second_to_hm3_per_hour,\n        om_cost = 10.0,\n    ),\n)\n\nIARA.add_hydro_unit!(db;\n    label = \"hydro_2\",\n    initial_volume = 0.0,\n    bus_id = \"bus_1\",\n    minimum_outflow_violation_cost = 600.0,\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = 1,\n        production_factor = 1000.0 * m3_per_second_to_hm3_per_hour,\n        max_generation = 400.0,\n        max_turbining = 400.0 / m3_per_second_to_hm3_per_hour,\n        min_volume = 0.0,\n        max_volume = 0.0,\n        min_outflow = 0.0,\n        om_cost = 100.0,\n    ),\n)","category":"section"},{"location":"tutorial/case_05_build_reservoir_case.html#Setting-Hydro-Unit-relations","page":"Virtual reservoir example","title":"Setting Hydro Unit relations","text":"IARA.set_hydro_turbine_to!(db, \"hydro_1\", \"hydro_2\")\nIARA.set_hydro_spill_to!(db, \"hydro_1\", \"hydro_2\")","category":"section"},{"location":"tutorial/case_05_build_reservoir_case.html#Asset-Owner","page":"Virtual reservoir example","title":"Asset Owner","text":"Let's add two asset owners to our case. Both of them will be price makers.\n\nIARA.add_asset_owner!(db; label = \"asset_owner_1\")\n\nIARA.add_asset_owner!(db; label = \"asset_owner_2\")","category":"section"},{"location":"tutorial/case_05_build_reservoir_case.html#Virtual-Reservoir","page":"Virtual reservoir example","title":"Virtual Reservoir","text":"Now we can add the virtual reservoir to our case. Notice that we are setting the inflow allocation, the initial energy account share, and linking the asset owners and hydro units.\n\nIARA.add_virtual_reservoir!(db;\n    label = \"reservoir_1\",\n    assetowner_id = [\"asset_owner_1\", \"asset_owner_2\"],\n    inflow_allocation = [0.4, 0.6],\n    initial_energy_account_share = [0.4, 0.6],\n    hydrounit_id = [\"hydro_1\", \"hydro_2\"],\n)","category":"section"},{"location":"tutorial/case_05_build_reservoir_case.html#Bidding-Group","page":"Virtual reservoir example","title":"Bidding Group","text":"Let's add a bidding group to our case. Both hydro units will be linked to this bidding group.\n\nIARA.add_bidding_group!(db;\n    label = \"bidding_group_1\",\n    assetowner_id = \"asset_owner_1\",\n    segment_fraction = [1.0],\n    risk_factor = [0.0],\n)\n\nIARA.update_hydro_unit_relation!(db,\n    \"hydro_1\";\n    collection = \"BiddingGroup\",\n    relation_type = \"id\",\n    related_label = \"bidding_group_1\",\n)\n\nIARA.update_hydro_unit_relation!(db,\n    \"hydro_2\";\n    collection = \"BiddingGroup\",\n    relation_type = \"id\",\n    related_label = \"bidding_group_1\",\n)","category":"section"},{"location":"tutorial/case_05_build_reservoir_case.html#Demand","page":"Virtual reservoir example","title":"Demand","text":"This case will have a single demand, which we can add with the function IARA.add_demand_unit!.\n\nIARA.add_demand_unit!(db;\n    label = \"dem_1\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [1],\n    ),\n    bus_id = \"bus_1\",\n    max_demand = 5.0,\n)","category":"section"},{"location":"tutorial/case_05_build_reservoir_case.html#Time-Series","page":"Virtual reservoir example","title":"Time Series","text":"For this case, we have added time series files for the\n\nDemand\nInflow\nVirtual Reservoir Energy Offer\nVirtual Reservoir Price Offer\n\nThey are available in the folder data/case_5\n\nLet's take a look into each of these files before linking them.\n\nIARA.time_series_dataframe(\n    joinpath(PATH_CASE, \"demand.csv\"),\n)\n\nIARA.link_time_series_to_file(\n    db,\n    \"DemandUnit\";\n    demand_ex_ante = \"demand\",\n)\n\nTo simplify our case, we are setting the inflow to zero, so we are only working with the initial volume of the first Hydro Unit.\n\nIARA.time_series_dataframe(\n    joinpath(PATH_CASE, \"inflow.csv\"),\n)\n\nIARA.link_time_series_to_file(\n    db,\n    \"HydroUnit\";\n    inflow_ex_ante = \"inflow\",\n)\n\nIARA.time_series_dataframe(\n    joinpath(PATH_CASE, \"virtual_reservoir_energy_bid.csv\"),\n)\n\nIARA.time_series_dataframe(\n    joinpath(PATH_CASE, \"virtual_reservoir_price_bid.csv\"),\n)\n\nIARA.link_time_series_to_file(\n    db,\n    \"VirtualReservoir\";\n    quantity_bid = \"virtual_reservoir_energy_bid\",\n    price_bid = \"virtual_reservoir_price_bid\",\n)","category":"section"},{"location":"tutorial/case_05_build_reservoir_case.html#Closing-the-study","page":"Virtual reservoir example","title":"Closing the study","text":"IARA.close_study!(db)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"tutorial/case_01_build_base_case.html#Base-Case-Building","page":"Case creation example","title":"Base Case - Building","text":"The data for this case is available in the folder data/case_1\n\nIn this tutorial, we will build a simple case containing some basic elements that can help us understand some of the functionalities of the IARA package.\n\nWe'll start by importing the necessary packages.\n\nusing Dates\nusing DataFrames\nusing IARA\n; #hide\nnothing #hide\n\nWe also need to define a directory to store the case.\n\nconst PATH_BASE_CASE = joinpath(@__DIR__, \"data\", \"case_1\")","category":"section"},{"location":"tutorial/case_01_build_base_case.html#Fundamental-elements","page":"Case creation example","title":"Fundamental elements","text":"","category":"section"},{"location":"tutorial/case_01_build_base_case.html#Parameters-indexed-in-time","page":"Case creation example","title":"Parameters indexed in time","text":"The parameters indexed in time in IARA model are defined by the number of periods and subperiods.\n\nA period represents a macro time period, such as a week, month, season or year. In each period, the model will solve an optimization problem that represents the decisions that need to be made based on available information.\n\nA subperiod represents a sub time period of the period, such as an hour, a day, or simply a collection of hours.\n\nA scenario in this context are defined as openings. Each period has a number of openings, and as the process evolves, the next period will have a number of openings that grow exponentially (e.g., if a period has 3 openings, the next period will have 3^2 = 9 possibilities). These openings represent possible future paths or branches in the decision process. For example, a node could represent a dry or wet season, a high or low demand, or a high or low price scenario.\n\nA Policy Graph is a representation of the decision making process in the model. There are two types of policy graphs: linear and cyclic.\n\nIn a linear policy graph, the periods are connected in a linear sequence, where the decisions made in one period affect the decisions in the next period.\n\nIn a cyclic policy graph, the periods are connected in a cyclic sequence, where the decisions made in the last period affect the decisions in the first period.\n\nFor more details, see the SDDP.jl documentation.\n\nFor this initial case, we will define a linear policy graph, with two periods (nodes) that will represent the Winter and Summer seasons and an yearly discount rate of 10%.\n\nAdditionally, each period will be consists of a single subperiod, with a duration of 24 hours.\n\nIn this case, we will define 4 scenarios.\n\nNow we can initialize our case, with the defined temporal parameters. The cycle duration in hours is the duration of a subproblem, given by the sum of the subperiod duration vector, times the number of periods.\n\nnumber_of_periods = 2\nnumber_of_subperiods = 1\nnumber_of_scenarios = 4\nsubperiod_duration_in_hours = [24.0]\ncycle_discount_rate = 0.1\ncycle_duration_in_hours = sum(subperiod_duration_in_hours) * number_of_periods\n; #hide\nnothing #hide\n\nUsing IARA.create_study! we can create a new study. This function will return a database reference that will store all the information about the case.\n\ndb = IARA.create_study!(PATH_BASE_CASE;\n    number_of_periods = number_of_periods,\n    number_of_scenarios = number_of_scenarios,\n    number_of_subperiods = number_of_subperiods,\n    subperiod_duration_in_hours = subperiod_duration_in_hours,\n    policy_graph_type = IARA.Configurations_PolicyGraphType.LINEAR,\n    number_of_nodes = number_of_periods,\n    cycle_discount_rate = cycle_discount_rate,\n    cycle_duration_in_hours = cycle_duration_in_hours,\n    demand_deficit_cost = 3000.0,\n    demand_scenarios_files = IARA.Configurations_UncertaintyScenariosFiles.ONLY_EX_ANTE,\n    renewable_scenarios_files = IARA.Configurations_UncertaintyScenariosFiles.ONLY_EX_ANTE,\n);\nnothing #hide","category":"section"},{"location":"tutorial/case_01_build_base_case.html#Spatial-Units","page":"Case creation example","title":"Spatial Units","text":"","category":"section"},{"location":"tutorial/case_01_build_base_case.html#Bus","page":"Case creation example","title":"Bus","text":"A bus is a connection point in a power system where multiple electrical components (such as generators, loads, transformers, or transmission lines) are set. Each bus need to be linked to a financial zone, which will be introduced in the next step.\n\nFor this case, we will have a single bus, named \"Island\", to which all the elements will be connected. We can add a bus to the database using the functionalities IARA.add_bus!.\n\nIARA.add_bus!(db; label = \"Island\")","category":"section"},{"location":"tutorial/case_01_build_base_case.html#Financial-elements","page":"Case creation example","title":"Financial elements","text":"","category":"section"},{"location":"tutorial/case_01_build_base_case.html#Zones","page":"Case creation example","title":"Zones","text":"A zone is a group of buses or a geographical area within a power system, often representing a specific region or subsystem. For this case, we will also define a single zone.\n\nWe can add a zone to the database using the method IARA.add_zone!.\n\nIARA.add_zone!(db; label = \"Island Zone\")\n\nNow we can link the bus to the zone, using the function IARA.update_bus_relation!.\n\nIARA.update_bus_relation!(\n    db,\n    \"Island\";\n    collection = \"Zone\",\n    relation_type = \"id\",\n    related_label = \"Island Zone\",\n)\n; #hide\nnothing #hide","category":"section"},{"location":"tutorial/case_01_build_base_case.html#Asset-Owners","page":"Case creation example","title":"Asset Owners","text":"In the bidding format, we need to define the asset owners that will participate in the market. These owners will be responsible for submitting bids for their assets, which will be represented by Bidding Groups. Each Bidding Group will be associated with a set of assets that belong to the same owner.\n\nFor now, we will define two asset owners: Thermal Owner and Price Taker. The first will assume the role of price maker, while the second will act as a price taker.\n\nWe can add an asset owner to the database using the functionalities IARA.add_asset_owner!.\n\nIARA.add_asset_owner!(\n    db;\n    label = \"Thermal Owner\",\n)\nIARA.add_asset_owner!(\n    db;\n    label = \"Price Taker\",\n)","category":"section"},{"location":"tutorial/case_01_build_base_case.html#Bidding-Groups","page":"Case creation example","title":"Bidding Groups","text":"Now we can define the Bidding Groups related to the asset owners that we have created earlier. Each Asset Owner will have a single Bidding Group, which will be associated with all their assets.\n\nIn each Bidding Group, we have to define the risk factor (mark-up) that will be applied to the cost of the assets. For this example, we will define a risk factor of 50% for both Bidding Groups.\n\nWe can add a Bidding Group to the database using the method IARA.add_bidding_group!.\n\nIARA.add_bidding_group!(\n    db;\n    label = \"Thermal Owner\",\n    assetowner_id = \"Thermal Owner\",\n    risk_factor = [0.5],\n    segment_fraction = [1.0],\n)\nIARA.add_bidding_group!(\n    db;\n    label = \"Price Taker\",\n    assetowner_id = \"Price Taker\",\n    risk_factor = [0.5],\n    segment_fraction = [1.0],\n)","category":"section"},{"location":"tutorial/case_01_build_base_case.html#Physical-Elements","page":"Case creation example","title":"Physical Elements","text":"","category":"section"},{"location":"tutorial/case_01_build_base_case.html#Demand","page":"Case creation example","title":"Demand","text":"This case will have three demand units. We can add them to the database using the function IARA.add_demand_unit!. We can enable or disable the demand unit. This can be changed by setting the existing attribute to 1 in the parameters time series DataFrame.\n\nThe demand over each period, subperiod and scenario will be defined by a time series file. We will define it at the end of this tutorial.\n\nFor this case, the demand will exist from the beginning.\n\nIARA.add_demand_unit!(db;\n    label = \"Demand1\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [1],\n    ),\n    bus_id = \"Island\",\n    max_demand = 1.8,\n)\n\nIARA.add_demand_unit!(db;\n    label = \"Demand2\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [1],\n    ),\n    bus_id = \"Island\",\n    max_demand = 0.72,\n)\n\nIARA.add_demand_unit!(db;\n    label = \"Demand3\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [1],\n    ),\n    bus_id = \"Island\",\n    max_demand = 0.36,\n)","category":"section"},{"location":"tutorial/case_01_build_base_case.html#Generation-Units","page":"Case creation example","title":"Generation Units","text":"Our case will have a mix of renewable and thermal units. In the table below, we can see some characteristics of each unit.\n\nTechnology Name Owner Maximum Generation (MW) Cost ($/MWh)\nRenewable Solar1 Price Taker 80 \nThermal Thermal1 Thermal Owner 20 10\nThermal Thermal2 Price Taker 20 30\nThermal Thermal3 Thermal Owner 20 100\nThermal Thermal4 Price Taker 20 300\nThermal Thermal5 Price Taker 50 1000\nThermal Thermal6 Price Taker 50 3000","category":"section"},{"location":"tutorial/case_01_build_base_case.html#Renewable-Units","page":"Case creation example","title":"Renewable Units","text":"We will start by adding a solar unit to the database, using IARA.add_renewable_unit!.\n\nIARA.add_renewable_unit!(\n    db;\n    label = \"Solar1\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [1],\n        max_generation = [80.0],\n        om_cost = [0.0],\n        curtailment_cost = [100.0],\n    ),\n    biddinggroup_id = \"Price Taker\",\n    bus_id = \"Island\",\n)\n\nThe generation of the solar unit requires a time series file. Like the demand, we will define it at the end of this tutorial.","category":"section"},{"location":"tutorial/case_01_build_base_case.html#Thermal-Units","page":"Case creation example","title":"Thermal Units","text":"Now we can add the thermal units to the database, using IARA.add_thermal_unit!.\n\nIARA.add_thermal_unit!(\n    db;\n    label = \"Thermal1\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [1],\n        max_generation = [20.0],\n        om_cost = [10.0],\n    ),\n    biddinggroup_id = \"Thermal Owner\",\n    bus_id = \"Island\",\n)\n\nIARA.add_thermal_unit!(\n    db;\n    label = \"Thermal2\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [1],\n        max_generation = [20.0],\n        om_cost = [30.0],\n    ),\n    biddinggroup_id = \"Price Taker\",\n    bus_id = \"Island\",\n)\n\nIARA.add_thermal_unit!(\n    db;\n    label = \"Thermal3\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [1],\n        max_generation = [20.0],\n        om_cost = [100.0],\n    ),\n    biddinggroup_id = \"Thermal Owner\",\n    bus_id = \"Island\",\n)\n\nIARA.add_thermal_unit!(\n    db;\n    label = \"Thermal4\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [1],\n        max_generation = [20.0],\n        om_cost = [300.0],\n    ),\n    biddinggroup_id = \"Price Taker\",\n    bus_id = \"Island\",\n)\n\nIARA.add_thermal_unit!(\n    db;\n    label = \"Thermal5\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [1],\n        max_generation = [50.0],\n        om_cost = [1000.0],\n    ),\n    biddinggroup_id = \"Price Taker\",\n    bus_id = \"Island\",\n)\n\nIARA.add_thermal_unit!(\n    db;\n    label = \"Thermal6\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [1],\n        max_generation = [50.0],\n        om_cost = [3000.0],\n    ),\n    biddinggroup_id = \"Price Taker\",\n    bus_id = \"Island\",\n)","category":"section"},{"location":"tutorial/case_01_build_base_case.html#Time-Series","page":"Case creation example","title":"Time Series","text":"note: Recap\nIn the beginning of this tutorial, we defined that there were 4 scenarios, 2 periods and 1 subperiod per period.","category":"section"},{"location":"tutorial/case_01_build_base_case.html#Loading-time-series-files","page":"Case creation example","title":"Loading time series files","text":"Using a text editor, we have created the following CSV files containing time series information about the demand and solar generation:\n\ndemands.csv\nsolar_generation.csv\n\nYou can find them in the data/case_1 folder.\n\nLet's take a quick look at the demand file using IARA.time_series_dataframe.\n\nIARA.time_series_dataframe(joinpath(PATH_BASE_CASE, \"demands.csv\"))\n\nand the solar generation file\n\nIARA.time_series_dataframe(joinpath(PATH_BASE_CASE, \"solar_generation.csv\"))\n\nNow, we have to link them to the database.\n\nIARA.link_time_series_to_file(\n    db,\n    \"RenewableUnit\";\n    generation_ex_ante = \"solar_generation\",\n)\n\nIARA.link_time_series_to_file(\n    db,\n    \"DemandUnit\";\n    demand_ex_ante = \"demands\",\n)","category":"section"},{"location":"tutorial/case_01_build_base_case.html#Closing-the-database","page":"Case creation example","title":"Closing the database","text":"Now that we have added all the elements and linked the time series files, we can close the database to run the case with the function IARA.close_study!.\n\nIARA.close_study!(db)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"tutorial/clearing_executions.html#Editing-clearing-options","page":"Editing clearing options","title":"Editing clearing options","text":"In this tutorial, it is described how to edit a case's clearing parameters, such as the market iterations considered in the execution (ex-ante and/or ex-post), the nature of these procedures (physical or commercial), and their dispatch criteria (cost-based or bid-based). For that, we will use as a starting point the boto_base_01 example case in its default configuration - that is, disregarding any changes carried out in previous tutorials. Firstly, we must rebuild this case from IARA's dataset (in order to \"reset\" its configuration) in the case_path previously informed (assuming that you have already gone through the previous tutorials). Then, we will load this study, using the IARA.load_study function, and store it in a variable named case_edit_clearing (including the read_only = false argument to indicate that we wish to modify the case).\n\nusing IARA # hide\nconst case_path = joinpath(@__DIR__, \"data\", \"ExampleCase_boto_base_01\") # hide\ncase_name = \"boto_base_01\"\nIARA.ExampleCases.build_example_case(case_path, case_name)\ncase_edit_clearing = IARA.load_study(case_path; read_only = false);\n#hide\n\nThe IARA model is capable of executing 4 dispatch types: (i) ex-ante physical dispatch, (ii) ex-ante commercial dispatch, (iii) ex-post physical dispatch, and (iv) ex-post commercial dispatch. These correspond to procedures that can be executed by system or market operators, depending on the regulatory framework and market design elements adopted, which vary case by case. For more information, click here to access a detailed conceptual description of these dispatch procedures.\n\nRegardless of the regulatory framework that is being represented, all 4 steps must have their corresponding dispatch criterion (or execution mode) defined, which can be: (i) skipped, when we do not want to represent the procedure, (ii) cost-based, when we wish to explictly represent the unit's physical characteristics in the modelling, (iii) bid-based, when the units' parameters and their owners' strategies are translated into price-quantity bids, or (iv) hybrid, when some agents are represented as cost-based, while other are represented as bid-based.\n\nIn its default definition, the example case under analysis presents the following characteristics:\n\nDispatch procedure Execution mode\nEx-ante physical Skip\nEx-ante commercial Skip\nEx-post physical Cost-based\nEx-post commercial Skip\n\nTaking this case as a starting point, in order to modify its clearing characteristics, we can use the function IARA.update_configuration! to adjust the execution mode of selected dispatch procedures (indicating firstly the variable in which the loaded case is stored). In the example below, we change the execution mode of the ex-ante physical dispatch, from skip to cost-based. This means that we are adding an ex-ante dispatch iteration to the study, which had a single ex-post iteration until this point - maintaining the cost-based nature of the study procedures.\n\nIARA.update_configuration!(\n    case_edit_clearing;\n    construction_type_ex_ante_physical = IARA.Configurations_ConstructionType.COST_BASED,\n)\n; #hide\nnothing #hide\n\nNow, the execution mode of each dispatch procedure comprised in the example case is as follows:\n\nDispatch procedure Execution mode\nEx-ante physical Cost-based\nEx-ante commercial Skip\nEx-post physical Cost-based\nEx-post commercial Skip\n\nNote that this modification means that a whole new set of results will be generated by the model, with the outputs from the ex-ante physical dispatch (alongside the ones from the ex-post physical dispatch, already discussed in the previous tutorials).\n\nWhen executing this case using the IARA.market_clearing function) - after closing the database and defining a path for the model to write the execution outputs -, we obtain marginal costs shown below for the ex-ante and ex-post physical dispatches, respectively. In the case of the ex-post dispatch, the results are the same ones shown in the first steps tutorial (which used the boto_base_01 example case in its default configuration), since no changes were made to this market iteration in the present analysis. Comparing these results with the ones obtained for the ex-ante procedure, it is noticeable that the latter presents marginal costs with lower dispersion among scenarios of a same period/subperiod. This is a natural consequence of the greater uncertainty inherent to real-time production and consumption (represented in the ex-post iteration) when contrasted with ex-ante forecasts, which tend to present lower variability.\n\nIARA.close_study!(case_edit_clearing)\npath03_edit_clearing = joinpath(case_path, \"03_edit_clearing\")\nIARA.market_clearing(case_path; output_path = path03_edit_clearing);\n#hide\n\ncmg_name_expost = \"load_marginal_cost_ex_post_physical.csv\"\ncmg_name_exante = \"load_marginal_cost_ex_ante_physical.csv\"\ncmg_path_expost = joinpath(path03_edit_clearing, cmg_name_expost)\ncmg_path_exante = joinpath(path03_edit_clearing, cmg_name_exante)\n; #hide\nIARA.custom_plot(cmg_path_expost, IARA.PlotTimeSeriesQuantiles)\nIARA.custom_plot(cmg_path_exante, IARA.PlotTimeSeriesQuantiles)\n\nThe next step of this Getting started tutorial describes the (heuristic bid pre-processing) applied to dispatches executed in bid-based mode.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"quiver_format.html#**Quiver-Format**","page":"Quiver","title":"Quiver Format","text":"Quiver is a data structure designed for representing time series data with multiple dimensions, such as periods, scenarios, subperiods, segments, and more. It is used in IARA for handling both inputs and outputs of the model.\n\nThe core concept of Quiver is to organize time series data using a set of dimensions for indexing and a set of attributes representing the values of the time series. This structure creates a table-like format that simplifies storage, retrieval, and analysis of time series data.\n\nQuiver files can be stored in any format that supports a structured table with accompanying metadata. The table is stored in a CSV or binary format, while the metadata is stored in a TOML file.","category":"section"},{"location":"quiver_format.html#**Metadata-(TOML-Format)**","page":"Quiver","title":"Metadata (TOML Format)","text":"Metadata for a Quiver file is stored in a TOML file with the following structure:\n\nField Description\nversion The Quiver file format version.\ndimensions Names of the dimensions used in the dataset.\ndimension_size Maximum number of elements in each dimension.\ninitial_date The start date of the time series.\ntime_dimension The dimension representing time.\nfrequency The time interval between data points (e.g., month, day, hour).\nunit The unit of measurement (e.g., MW, $, etc.).\nlabels Names of the time series agents.\n\n\n\nHere's an example of a metadata file:\n\nversion = 1\ndimensions = [\"period\", \"scenario\", \"subscenario\", \"subperiod\"]\ndimension_size = [6, 3, 4, 3]\ninitial_date = \"2024-01-01 00:00:00\"\ntime_dimension = \"period\"\nfrequency = \"monthly\"\nunit = \"$/MWh\"\nlabels = [\"Eastern\", \"Western\"]","category":"section"},{"location":"quiver_format.html#**Data-Storage-Format**","page":"Quiver","title":"Data Storage Format","text":"The actual time series data is stored in either:\n\nCSV format (human-readable)\nBinary format (efficient for large datasets)","category":"section"},{"location":"quiver_format.html#**CSV-Format-Example**","page":"Quiver","title":"CSV Format Example","text":"period,scenario,subscenario,subperiod,Eastern,Western\n1,1,1,1,10.0,10.0\n1,1,1,2,-0.0,-0.0\n1,1,1,3,50.0,300.0\n\nFor more information on how to read and write Quiver files, refer to the Quiver.jl documentation.","category":"section"},{"location":"tutorial/case_03_run_profile_base_case.html#Multi-hour-Bid-Running","page":"Multi-hour Bid - Running","title":"Multi-hour Bid - Running","text":"The data for this case is available in the folder data/case_3\n\nusing Dates\nusing DataFrames\nusing IARA\n; #hide\nnothing #hide","category":"section"},{"location":"tutorial/case_03_run_profile_base_case.html#Case-recap","page":"Multi-hour Bid - Running","title":"Case recap","text":"In the previous section, we have built a case containing two Bidding Groups, where one of them has a profile bid. Now we will run this case using the MARKET_CLEARING mode.\n\nLet's create a folder to store the output of the MARKET_CLEARING mode and define the path to the original case.\n\nconst PATH_EXECUTION = joinpath(@__DIR__, \"case_3_execution\")\n\nif !isdir(PATH_EXECUTION)\n    mkdir(PATH_EXECUTION)\nend\n\nconst PATH_ORIGINAL = joinpath(@__DIR__, \"data\", \"case_3\")\n\ncp(PATH_ORIGINAL, PATH_EXECUTION; force = true);\n#hide\n\nBefore running, let's load the case and update the run mode to MARKET_CLEARING.\n\ndb = IARA.load_study(PATH_EXECUTION; read_only = false)\n\nIARA.update_configuration!(\n    db;\n    construction_type_ex_ante_physical = IARA.Configurations_ConstructionType.HYBRID,\n    construction_type_ex_ante_commercial = IARA.Configurations_ConstructionType.HYBRID,\n    construction_type_ex_post_physical = IARA.Configurations_ConstructionType.HYBRID,\n    construction_type_ex_post_commercial = IARA.Configurations_ConstructionType.HYBRID,\n)\n\nIARA.close_study!(db)\n; #hide\nnothing #hide\n\nNow we are able to run the case with IARA.market_clearing.\n\nIARA.market_clearing(\n    PATH_EXECUTION;\n    delete_output_folder_before_execution = true,\n)","category":"section"},{"location":"tutorial/case_03_run_profile_base_case.html#Analyzing-the-results","page":"Multi-hour Bid - Running","title":"Analyzing the results","text":"The results are stored inside the case folder, in the outputs directory.\n\ncase_folder\n ├── outputs\n │    ├── plots\n │    │   └── ...\n │    └── ...\n └── ...\n\n<iframe src=\"case_3_execution\\\\outputs\\\\plots\\\\bidding_group_generation_ex_ante_commercial_all.html\" style=\"height:500px;width:100%;\"></iframe>\n\n<iframe src=\"case_3_execution\\\\outputs\\\\plots\\\\bidding_group_generation_profile_ex_ante_commercial_all.html\" style=\"height:500px;width:100%;\"></iframe>\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"tutorial/case_06_build_policy_graph.html#Policy-Graphs-Building","page":"Policy graphs example: building","title":"Policy Graphs - Building","text":"The data for this case is available in the folder data/case_6\n\nThe goal is to understand the differences between linear and cyclic policy graphs by running simulations with different numbers of periods. For this tutorial, we will:\n\nCompare linear and cyclic policy graphs.\nVary the number of periods (2 and 10).\nLink the case to inflow and demand time series files that match the number of periods.\nAnalyze the results to determine how the optimal solution changes depending on the policy graph type and the number of periods.\n\nWe'll start by importing the necessary packages.\n\nusing Dates\nusing DataFrames\nusing IARA\n; #hide\nnothing #hide\n\nWe also need to define a directory to store the case.\n\nconst PATH_CASE = joinpath(@__DIR__, \"data\", \"case_6\")\n\nDefine conversion factors and key parameters for the study.\n\n# Define basic parameters\nnumber_of_periods = 2\nnumber_of_subperiods = 1\nnumber_of_scenarios = 3\nsubperiod_duration_in_hours = [24.0]\nexpected_repeats = 5\ncycle_discount_rate = 1 / (expected_repeats - 1)\n; #hide\n\n# Let's define a few conversion factors that we will use later.\nm3_per_second_to_hm3_per_hour = 3600.0 / 1e6\n; #hide\nnothing #hide\n\nUsing IARA.create_study! we can create a new study.\n\ndb = IARA.create_study!(PATH_CASE;\n    number_of_periods = number_of_periods,\n    number_of_scenarios = number_of_scenarios,\n    number_of_subperiods = number_of_subperiods,\n    subperiod_duration_in_hours = subperiod_duration_in_hours,\n    number_of_nodes = number_of_periods,\n    cycle_discount_rate = cycle_discount_rate,\n    policy_graph_type = IARA.Configurations_PolicyGraphType.LINEAR,\n    demand_deficit_cost = 3000.0,\n    cycle_duration_in_hours = 48.0,\n    demand_scenarios_files = IARA.Configurations_UncertaintyScenariosFiles.ONLY_EX_ANTE,\n    inflow_scenarios_files = IARA.Configurations_UncertaintyScenariosFiles.ONLY_EX_ANTE,\n);\nnothing #hide","category":"section"},{"location":"tutorial/case_06_build_policy_graph.html#Zone-and-Bus","page":"Policy graphs example: building","title":"Zone and Bus","text":"IARA.add_zone!(db; label = \"Zone1\")\nIARA.add_bus!(db; label = \"Bus1\", zone_id = \"Zone1\")","category":"section"},{"location":"tutorial/case_06_build_policy_graph.html#Demand","page":"Policy graphs example: building","title":"Demand","text":"IARA.add_demand_unit!(db;\n    label = \"Demand1\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [1],\n    ),\n    bus_id = \"Bus1\",\n    max_demand = 3.6,\n)","category":"section"},{"location":"tutorial/case_06_build_policy_graph.html#Physical-Elements","page":"Policy graphs example: building","title":"Physical Elements","text":"","category":"section"},{"location":"tutorial/case_06_build_policy_graph.html#Thermal-Unit","page":"Policy graphs example: building","title":"Thermal Unit","text":"IARA.add_thermal_unit!(\n    db;\n    label = \"Thermal1\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [1],\n        max_generation = [25.0],\n        om_cost = [10.0],\n    ),\n    bus_id = \"Bus1\",\n)\n\nIARA.add_thermal_unit!(\n    db;\n    label = \"Thermal2\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [1],\n        max_generation = [50.0],\n        om_cost = [20.0],\n    ),\n    bus_id = \"Bus1\",\n)","category":"section"},{"location":"tutorial/case_06_build_policy_graph.html#Gauging-Station","page":"Policy graphs example: building","title":"Gauging Station","text":"IARA.add_gauging_station!(db;\n    label = \"gauging_station\",\n)","category":"section"},{"location":"tutorial/case_06_build_policy_graph.html#Hydro-Unit","page":"Policy graphs example: building","title":"Hydro Unit","text":"IARA.add_hydro_unit!(db;\n    label = \"Hydro1\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [1], # 1 = true\n        production_factor = [1.0], # MW/m³/s\n        max_generation = [150.0], # MW\n        max_turbining = [150.0], # m³/s\n        min_volume = [0.0], # hm³\n        max_volume = [100.0], # hm³\n        min_outflow = [0.0], # m³/s\n        om_cost = [0.0], # $/MWh\n    ),\n    initial_volume = 100.0 *\n                     m3_per_second_to_hm3_per_hour *\n                     subperiod_duration_in_hours[1],  # If it is full, it can generate for the whole year # hm³\n    gaugingstation_id = \"gauging_station\",\n    bus_id = \"Bus1\",\n)","category":"section"},{"location":"tutorial/case_06_build_policy_graph.html#Time-Series","page":"Policy graphs example: building","title":"Time Series","text":"","category":"section"},{"location":"tutorial/case_06_build_policy_graph.html#Loading-time-series-files","page":"Policy graphs example: building","title":"Loading time series files","text":"Using a text editor, we have created the following CSV files containing time series information about the demand and solar generation:\n\ndemands.csv\ninflow.csv\n\nLet's take a look at the first lines of each file, using the function IARA.time_series_dataframe.","category":"section"},{"location":"tutorial/case_06_build_policy_graph.html#Demand:","page":"Policy graphs example: building","title":"Demand:","text":"IARA.time_series_dataframe(joinpath(PATH_CASE, \"demands.csv\"))","category":"section"},{"location":"tutorial/case_06_build_policy_graph.html#Inflow:","page":"Policy graphs example: building","title":"Inflow:","text":"IARA.time_series_dataframe(joinpath(PATH_CASE, \"inflow.csv\"))","category":"section"},{"location":"tutorial/case_06_build_policy_graph.html#Linking-the-time-series","page":"Policy graphs example: building","title":"Linking the time series","text":"Now we need to link the time series with the function IARA.link_time_series_to_file.\n\nIARA.link_time_series_to_file(\n    db,\n    \"DemandUnit\";\n    demand_ex_ante = \"demands\",\n)\n\nIARA.link_time_series_to_file(\n    db,\n    \"HydroUnit\";\n    inflow_ex_ante = \"inflow\",\n)\n;\nnothing #hide","category":"section"},{"location":"tutorial/case_06_build_policy_graph.html#Closing-the-database","page":"Policy graphs example: building","title":"Closing the database","text":"Now that we have added all the elements and linked the time series files, we can close the database to run the case, with the function IARA.close_study!.\n\nIARA.close_study!(db)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"output_files.html#**Output-files**","page":"Output files","title":"Output files","text":"Here is a table of all the output files generated by the model related to the variables:\n\nCollection Filename Description Variable Unit Dimensions\nBatteryUnit battery_generation Battery unit generation g^B_j tau GWh period, scenario, subperiod\nBatteryUnit battery_storage Battery unit storage s^B_j tau GWh period, scenario, subperiod\nBatteryUnit battery_om_costs Battery total O&M costs   period, scenario, subperiod\nBiddingGroup bidding_group_generation Bidding group generation q_i n tau k GWh period, scenario, subperiod, bid_segment\nBiddingGroup bidding_group_generation_profile Bidding group generation profile q^M_i n tau k GWh period, scenario, subperiod, profile\nBranch branch_flow Branch flow f_j tau MW period, scenario, subperiod\nBus bus_voltage_angle Bus voltage angle theta_n tau rad period, scenario, subperiod\nDCLine dc_flow DC flow f_j tau MW period, scenario, subperiod\nDemandUnit demand Demand D_j tau(omega) GWh period, scenario, subperiod\nDemandUnit attended_elastic_demand Attended elastic demand d^E_j tau GWh period, scenario, subperiod\nDemandUnit attended_flexible_demand Attended flexible demand d^F_j tau GWh period, scenario, subperiod\nDemandUnit demand_curtailment Demand curtailment delta^F_j tau GWh period, scenario, subperiod\nDemandUnit deficit Deficit delta_j tau GWh period, scenario, subperiod\nHydroUnit hydro_turbining Hydro unit turbinig u_j tau m^3s period, scenario, subperiod\nHydroUnit hydro_generation Hydro generation g^H_j tau GWh period, scenario, subperiod\nHydroUnit hydro_initial_volume Hydro initial volume v^S_in_j hm^3 period, scenario, subperiod\nHydroUnit hydro_final_volume Hydro final volume v^S_out_j hm^3 period, scenario, subperiod\nHydroUnit hydro_commitment Hydro unit commitment x^H_j tau - period, scenario, subperiod\nHydroUnit hydro_spillage Hydro spillage z_j tau m^3s period, scenario, subperiod\nHydroUnit hydro_spillage_penalty Hydro spillage penalty   period, scenario, subperiod\nHydroUnit hydro_om_costs Hydro O&M costs   period, scenario, subperiod\nHydroUnit inflow Inflow a_j tau m^3s period, scenario, subperiod\nHydroUnit inflow_slack Inflow slack a^S_j tau m^3s period, scenario, subperiod\nHydroUnit hydro_om_costs Hydro O&M costs   period, scenario, subperiod\nInterconnection interconnection_flow Interconnection flow  MW period, scenario, subperiod\nRenewableUnit renewable_generation Renewable generation g^R_j tau GWh period, scenario, subperiod\nRenewableUnit renewable_curtailment Renewable curtailment z^r_j tau GWh period, scenario, subperiod\nRenewableUnit renewable_om_costs Renewable O&M costs   period, scenario, subperiod\nRenewableUnit renewable_curtailment_costs Renewable curtailment costs   period, scenario, subperiod\nThermalUnit thermal_generation Thermal generation g^T_j tau GWh period, scenario, subperiod\nThermalUnit thermal_om_costs Thermal O&M costs   period, scenario, subperiod\nThermalUnit thermal_commitment Thermal unit commitment x^T_j tau - period, scenario, subperiod\nVirtualReservoir virtual_reservoir_generation Virtual reservoir generation q^VR_r i k GWh period, scenario, bid_segment\n\nHere is a table of all the output files generated by the model related to the constraints:\n\nCollection Output Name Description Unit Dimensions\nHydroUnit hydro_opportunity_cost Hydro opportunity cost MWh period, scenario, subperiod\nLoad load_marginal_cost Load marginal cost MWh period, scenario, subperiod\n\nHere is a table of all the output files generated by the model related to the heuristic bids:\n\nCollection Output Name Description Parameter Unit Dimensions\nBiddingGroup bidding_group_energy_bid Bidding group quantity bid Q_i n tau k(omega) GWh period, scenario, subperiod, bid_segment\nBiddingGroup bidding_group_price_bid Bidding group price bid P_i n tau k(omega) MWh period, scenario, subperiod, bid_segment\nBiddingGroup bidding_group_no_markup_price_bid Bidding group price bid without markup on agents  MWh period, scenario, subperiod, bid_segment\nVirtualReservoir virtual_reservoir_energy_bid Virtual reservoir energy bid Q^VR_r i k(omega) GWh period, scenario, bid_segment\nVirtualReservoir virtual_reservoir_price_bid Virtual reservoir price bid P^VR_r i k(omega) MWh period, scenario, bid_segment","category":"section"},{"location":"clearing_procedure.html#Clearing-Formulation","page":"The market clearing structure","title":"Clearing Formulation","text":"One of the key features of IARA is the organization of the Market Clearing process into four subproblems: Ex-Ante Physical, Ex-Ante Commercial, Ex-post Physical, and Ex-post Commercial.\n\nThe typical structure according to which these four subproblems are structured is illustrated in the image below. Note that each iteration of the market clearing process involves solving all four subproblems (one instance of each of the ex ante subproblems and several instances of each of the ex post subproblems, one for each subscenario). The ending state of the previous period's optimization problem (T-1) is an input for all four subproblems, and the present period (T)'s ending state is also passed on to the next iteration of the market clearing process. Note that it is the final state of one of the instances of the ex post physical optimization problem that will typically be the driver of this ending state.\n\nOther arrows in the diagram below represent other input data (physical random variables and submitted bids) that are collected as part of IARA's main market clearing process, as well as output variables (assigned quantities and marginal costs). Converting the assigned quantities and marginal costs into a price signal is part of IARA's post-processing feature.\n\n(Image: Diagram)\n\nEven though the above diagram is the \"default\" structure for the market clearing process, which is quite flexible and able to accommodate a number of market designs, some market design choices might either omit some of these steps or introduce relationships between the subproblems. You can get started by exploring IARA's features for representing market design options that will affect the clearing process.","category":"section"},{"location":"clearing_procedure.html#Clearing-Procedures","page":"The market clearing structure","title":"Clearing Procedures","text":"","category":"section"},{"location":"clearing_procedure.html#Ex-Ante","page":"The market clearing structure","title":"Ex-Ante","text":"The Ex-Ante step is responsible for calculating the physical and commercial dispatches one day before the actual operation. The Ex-Ante step is divided into two steps: Ex-Ante Physical and Ex-Ante Commercial.  In the Virtual Reservoir, the allocation of predicted inflows for this agent is added to its balance.","category":"section"},{"location":"clearing_procedure.html#Ex-Ante-Physical","page":"The market clearing structure","title":"Ex-Ante Physical","text":"The Ex-Ante Physical step is responsible for calculating the physical generation amount that will be dispatched a day before the actual operation. The physical units are calculated based on the bids submitted by the agents and the constraints of the system. In the Virtual Reservoir, the allocation of predicted inflows for this agent is added to its balance. In this problem, the Market Clearing is calculated with all integer variables, and the result will generally be used in other subsequent problems.","category":"section"},{"location":"clearing_procedure.html#Ex-Ante-Commercial","page":"The market clearing structure","title":"Ex-Ante Commercial","text":"The Ex-Ante Commercial step is responsible for determining the clearing prices of the day-ahead market.\n\nThere are three approaches to calculate these prices:\n\nPost-MIP Solution Approach: After solving the Mixed-Integer Program (MIP), the binary variables are fixed according to the solution, and the resulting Linear Program (LP) is solved. The dual solution of this LP provides the clearing prices.\nLP with Fixed Binary Variables: This approach involves solving the LP that is derived by fixing the binary variables to specific values. Currently, the values of the binary variables are taken from the solution of the ex-ante physical problem.\nRelaxation of Integrality Constraints: In this method, the integrality constraints of the MIP are relaxed, and the resulting LP is solved to determine the clearing prices.","category":"section"},{"location":"clearing_procedure.html#Ex-Post","page":"The market clearing structure","title":"Ex-Post","text":"In ex-post problems, a set of sub-scenarios can be provided for each scenario verified in the ex-ante, representing shocks that simulate real-time variations. Each scenario can have their own set of sub-scenarios, but the number of sub-scenarios must be the same for all scenarios.\n\nThe first sub-scenario calculated in the ex-post is used to transmit the state variable information and the virtual reservoir balance to the next period.\n\nAt a given period, the Virtual Reservoir balance is added to the ex-post inflow allocation for this agent in its balance, and the bids accepted by the Operator are debited. After this operation, an adjustment can be made so that the Virtual Reservoir balance equals the Available Energy of the hydros that make up this reservoir.","category":"section"},{"location":"clearing_procedure.html#Ex-Post-Physical","page":"The market clearing structure","title":"Ex-Post Physical","text":"The Ex-Post Physical step is responsible for calculating the physical generation amount that will be dispatched in real-time. The physical units are determined based on the bids submitted by the agents and the system's constraints. In the Virtual Reservoir, the allocation of inflows for the agent is added to its balance.\n\nThe binary variable can be handled in the following ways:\n\nPost-MIP Solution Approach: The Mixed-Integer Program (MIP) fixes the binary variables, and then the program is run with these variables fixed.\nLP with Fixed Binary Variables: The Linear Program (LP) uses binary variables that are fixed based on the solution from a prior problem, such as the ex-ante physical or commercial problem.\nRelaxation of Integrality Constraints: The LP is run with relaxed integrality constraints, allowing for continuous variables instead of discrete binary variables.","category":"section"},{"location":"clearing_procedure.html#Ex-Post-Commercial","page":"The market clearing structure","title":"Ex-Post Commercial","text":"Ex-Post Commercial\n\nThe Ex-Post Commercial step is responsible for calculating the clearing prices of the real-time market.\n\nThere are three approaches to calculate these prices:\n\nPost-MIP Solution Approach: The Mixed-Integer Program (MIP) fixes the variables, and then the program is run with these variables fixed.\nLP with Fixed Binary Variables: The Linear Program (LP) receives binary variables that are fixed based on the solution of a prior problem. These variables can come from either the ex-ante or ex-post physical problems.\nRelaxation of Integrality Constraints: The LP is run with relaxed integrality constraints, allowing for continuous variables instead of binary ones.\n\nIn all procedures, it's possible to add the FCF from the MinCost module and a wave-guide curve as a tie-break for the Virtual Reservoir bids.","category":"section"},{"location":"clearing_procedure.html#Model-Clearing-model-types","page":"The market clearing structure","title":"Model Clearing model types","text":"The Market Clearing can be calculated in three ways:\n\nCost Based Dispatch: The dispatch is calculated based only on the physical attributes of the system. The objective is to minimize the total cost of the system. No bids are considered in this case.\nBid Based Dispatch: The dispatch is calculated based only on the bids submitted by the agents. The objective is to minimize the total cost of the bids accepted by the Operator. The physical constraints are not considered in this case.\nHybrid Dispatch: The dispatch is calculated based on the bids submitted by the agents and the physical constraints of the system serve as a limit for the accepted bids and a tie-break for the bids with the same cost. The objective is to minimize the total cost of the bids accepted by the Operator.\n\nAny step of the Market Clearing can be calculated with any of the three model types described above.","category":"section"},{"location":"clearing_procedure.html#Standard-Reservoir-settlement","page":"The market clearing structure","title":"Standard Reservoir settlement","text":"This is a post processing feature related to the revenue of the agents that isn't related to Virtual Reservoirs. Notation:\n\nomega in textex-ante textex-post\n: subproblem types.\nq^omega\n: primal variable representing the quantity of energy dispatched in the ex-ante or ex-post physical subproblem.\npi^omega\n: dual variable representing the marginal costs in the ex-ante or ex-post commercial subproblem.\n\nThe revenue of the agents is calculated as follows:\n\nSettlement Type Expression\nEX_POST q^textex-post pi^textex-post\nEX_ANTE q^textex-post pi^textex-ante\nTWO_SETTLEMENT q^textex-ante pi^textex-ante+(q^textex-post-q^textex-ante ) pi^textex-post\n\nThe default file for generation is the Physical Problem. If this file is unavailable due to being skipped, the model will use the Commercial Problem instead, but a warning will be generated to indicate a non-standard execution type.\nThe default file for marginal costs is the Commercial Problem. If this file is unavailable due to being skipped, the model will use the Physical Problem instead.\nIn EX_ANTE or TWO_SETTLEMENT settlements, if both the Ex Ante Physical and Ex Ante Commercial Problems or both Ex Post Physical and Ex Post Commercial Problems are skipped, an error will occur.\nIn EX_POST settlements, if both the Ex Post Physical and Ex Post Commercial Problems are skipped, an error will occur.","category":"section"},{"location":"supply_function_equilibrium.html#Supply-Function-Equilibrium","page":"Supply Function Equilibrium","title":"Supply Function Equilibrium","text":"","category":"section"},{"location":"supply_function_equilibrium.html#Introduction","page":"Supply Function Equilibrium","title":"Introduction","text":"Supply Function Equilibrium (SFE) is a methodology for computing strategic bidding curves in electricity markets. In IARA.jl, SFE is enabled by setting bid_processing = ITERATED_BIDS_FROM_SUPPLY_FUNCTION_EQUILIBRIUM.","category":"section"},{"location":"supply_function_equilibrium.html#Theoretical-Foundation","page":"Supply Function Equilibrium","title":"Theoretical Foundation","text":"SFE theory (Klemperer & Meyer, 1989) models competition where firms submit complete supply curves (a set of sequential price-quantity pairs) rather than single price-quantity pairs. Each market participant recognizes that their bid curve influences market prices, and strategic agents adjust curves to maximize their profits. At equilibrium, no agent can improve its result by unilaterally changing its supply function.","category":"section"},{"location":"supply_function_equilibrium.html#Input-Data-Sources","page":"Supply Function Equilibrium","title":"Input Data Sources","text":"Virtual Reservoirs: Reference curves are based on marginal water values from the hydro reference curve algorithm (see Heuristic bids for virtual reservoirs). These curves represent the opportunity cost of water use across different operating conditions.\n\nBidding Groups: Reference curves come from unit generation offers for thermal, renewable, and battery assets.","category":"section"},{"location":"supply_function_equilibrium.html#Configuration","page":"Supply Function Equilibrium","title":"Configuration","text":"","category":"section"},{"location":"supply_function_equilibrium.html#Required-Parameter","page":"Supply Function Equilibrium","title":"Required Parameter","text":"IARA.update_configuration!(db;\n    bid_processing = IARA.Configurations_BidProcessing.ITERATED_BIDS_FROM_SUPPLY_FUNCTION_EQUILIBRIUM,\n)","category":"section"},{"location":"supply_function_equilibrium.html#SFE-Parameters","page":"Supply Function Equilibrium","title":"SFE Parameters","text":"supply_function_equilibrium_extra_bid_quantity (Float64, default: 1.0) Determines the quantity value for the artificial bid added during SFE preprocessing.\nsupply_function_equilibrium_max_iterations (Int, default: 20) Maximum iterations for equilibrium computation within each period/scenario.\nsupply_function_equilibrium_tolerance (Float64, default: 0.000001) Minimum slope tolerance. Curves with slopes below this value trigger errors.\nsupply_function_equilibrium_max_cost_multiplier (Float64, default: 2.0) Maximum price cap as multiplier of deficit cost.\n\nExample:\n\nIARA.update_configuration!(db;\n    bid_processing = IARA.Configurations_BidProcessing.ITERATED_BIDS_FROM_SUPPLY_FUNCTION_EQUILIBRIUM,\n    reference_curve_number_of_segments = 10,\n    supply_function_equilibrium_extra_bid_quantity = 1.0,\n    supply_function_equilibrium_max_iterations = 20,\n    supply_function_equilibrium_tolerance = 0.000001,\n    supply_function_equilibrium_max_cost_multiplier = 2.0,\n    demand_deficit_cost = 3000.0,\n)","category":"section"},{"location":"supply_function_equilibrium.html#Mathematical-Formulation","page":"Supply Function Equilibrium","title":"Mathematical Formulation","text":"","category":"section"},{"location":"supply_function_equilibrium.html#Execution-Flow","page":"Supply Function Equilibrium","title":"Execution Flow","text":"STEP 1: Prepare Reference Curves\n    - Virtual Reservoirs: Generate from marginal water values\n    - Bidding Groups: Use unit generation offers\n    - Allocate to asset owners and serialize\n\nSTEP 2: Apply Supply Function Equilibrium\n    FOR each period and scenario:\n        - Read reference curves and initial bids\n        - Apply slope adjustment formula iteratively\n        - Compute equilibrium bid curves\n        - Write to outputs\n\nSTEP 3: Market Clearing\n    - Use equilibrium bids for clearing\n    - Generate spot prices and settlement","category":"section"},{"location":"supply_function_equilibrium.html#SFE-Algorithm","page":"Supply Function Equilibrium","title":"SFE Algorithm","text":"","category":"section"},{"location":"supply_function_equilibrium.html#Notation","page":"Supply Function Equilibrium","title":"Notation","text":"Sets:\n\nmathcalA: Set of agents (VR-AssetOwner pairs + BG-Bus pairs)\nK_i: Set of segments for agent i\nB(t): Set of subperiods in period t\n\nIndices:\n\ni in mathcalA: Agent index\nk in K_i: Segment index for agent i\ntau in B(t): Subperiod index\n\nParameters:\n\nC^max: Maximum cost multiplier\nC^delta: Demand deficit cost (MWh)\nQ_itau: Quantity for agent i at subperiod tau\nP_itau: Price for agent i at subperiod tau\n\nVariables:\n\nq_i(k): Cumulative quantity for agent i at segment k\np_i(k): Price for agent i at segment k\nb_i(k): Slope fracdpdq for agent i at segment k\nq_i^0(k) p_i^0(k) b_i^0(k): Original reference curve data\nq_i^*(k) p_i^*(k) b_i^*(k): Equilibrium curve data\np^*(k): Market price at segment k (common to all agents)","category":"section"},{"location":"supply_function_equilibrium.html#Data-Preprocessing","page":"Supply Function Equilibrium","title":"Data Preprocessing","text":"Bidding Groups: Aggregate bids across subperiods before equilibrium\nQ_iagg = sum_tau in B(t) Q_itau\nP_iagg = fracsum_tau in B(t) P_itau cdot Q_itauQ_iagg\nAll Agents: Convert segment quantities to cumulative points\nAll Agents: Reverse to descending price order and add high-price point at deficit cost\nAll Agents: Calculate slopes: b_i(k) = fracp_i(k+1) - p_i(k)q_i(k+1) - q_i(k) for all i in mathcalA","category":"section"},{"location":"supply_function_equilibrium.html#Iteration-Algorithm","page":"Supply Function Equilibrium","title":"Iteration Algorithm","text":"Initialization (segment k=1):\n\nq_i^*(1) = q_i^0(1) quad forall i in mathcalA\n\np^*(1) = C^max cdot C^delta\n\np_i^*(1) = p^*(1) quad forall i in mathcalA\n\nb_i^*(1) = b_i^0(1) quad forall i in mathcalA\n\nIteration for segments k = 1 2 ldots until all agents reach minimum quantity:\n\nGet available quantities: barq_i(k) = max(q_i^*(k) - q_i^0(k^+) 0) where k^+ is the next segment index for agent i\nCalculate price decrement: Delta p = minbarq_i(k) cdot b_i^*(k) mid barq_i(k)  0 i in mathcalA\nUpdate quantities and market price:\nq_i^*(k+1) = q_i^*(k) - fracDelta pb_i^*(k) quad forall i in mathcalA\np^*(k+1) = p^*(k) - Delta p\np_i^*(k+1) = p^*(k+1) quad forall i in mathcalA\nUpdate slopes using equilibrium formula","category":"section"},{"location":"supply_function_equilibrium.html#Slope-Update-Formula","page":"Supply Function Equilibrium","title":"Slope Update Formula","text":"For segment k with all agents in mathcalA:\n\nB_k = sum_i in mathcalA frac1b_i^*(k)\n\nb_i^*(k) = fracb_i^0(k)2 + frac1B_k + sqrtleft(fracb_i^0(k)2right)^2 + left(frac1B_kright)^2 quad forall i in mathcalA\n\nEconomic Interpretation:\n\nEach agent's optimal slope b_i^*(k) balances:\n\nCost structure: fracb_i^0(k)2 (marginal cost component)\nMarket responsiveness: frac1B_k (aggregate inverse slope)\nQuadratic adjustment ensuring stability\n\nIn competitive markets (large mathcalA, high B_k), slopes approach marginal costs. In concentrated markets, markups are substantial.","category":"section"},{"location":"supply_function_equilibrium.html#Virtual-Reservoirs-vs-Bidding-Groups","page":"Supply Function Equilibrium","title":"Virtual Reservoirs vs Bidding Groups","text":"The SFE algorithm treats both entity types in a unified framework with key differences:\n\nVirtual Reservoirs:\n\nPeriod-level aggregates (no subperiod dimension)\nReference curves from marginal water values\nEach VR-AssetOwner pair is an agent\n\nBidding Groups:\n\nHave subperiod dimension (intra-period variation)\nReference curves from unit offers\nAggregated across subperiods before SFE\nResults disaggregated back proportionally after equilibrium\nEach BG-Bus pair is an agent\n\nUnified Treatment: All agents processed together in same iteration loop, ensuring simultaneous equilibrium regardless of technology type.","category":"section"},{"location":"supply_function_equilibrium.html#Output-Files","page":"Supply Function Equilibrium","title":"Output Files","text":"SFE generates equilibrium curves for each period/scenario:\n\nVirtual Reservoir Outputs:\n\nvirtual_reservoir_sfe_quantity.csv - Equilibrium quantities (GWh)\nvirtual_reservoir_sfe_price.csv - Equilibrium prices ($/MWh)\nvirtual_reservoir_sfe_slope.csv - Equilibrium slopes ($/MWh²)\n\nBidding Group Outputs:\n\nbidding_group_sfe_quantity.csv - Equilibrium quantities (MWh)\nbidding_group_sfe_price.csv - Equilibrium prices ($/MWh)\nbidding_group_sfe_slope.csv - Equilibrium slopes ($/MWh²)\n\nAll outputs include dimensions for agents, sfe_iteration, and sfe_curve_segment.","category":"section"},{"location":"supply_function_equilibrium.html#Usage-Example","page":"Supply Function Equilibrium","title":"Usage Example","text":"","category":"section"},{"location":"supply_function_equilibrium.html#Setting-Up-a-Case-with-SFE","page":"Supply Function Equilibrium","title":"Setting Up a Case with SFE","text":"using IARA\nusing Dates\nusing DataFrames\n\n# Create study with SFE configuration\ndb = IARA.create_study!(\"path/to/case\";\n    number_of_periods = 3,\n    number_of_scenarios = 2,\n    number_of_subperiods = 4,\n    initial_date_time = \"2020\",\n    subperiod_duration_in_hours = [250.0, 250.0, 250.0, 250.0],\n    demand_deficit_cost = 500.0,\n    # Enable Supply Function Equilibrium\n    bid_processing = IARA.Configurations_BidProcessing.ITERATED_BIDS_FROM_SUPPLY_FUNCTION_EQUILIBRIUM,\n    reference_curve_number_of_segments = 10,\n)\n\n# Add buses and zones\nIARA.add_zone!(db; label = \"zone_1\")\nIARA.add_bus!(db; label = \"bus_1\", zone_id = \"zone_1\")\n\n# Add hydro units\nIARA.add_hydro_unit!(db;\n    label = \"hydro_1\",\n    initial_volume = 900.0,\n    bus_id = \"bus_1\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = Int(IARA.HydroUnit_Existence.EXISTS),\n        production_factor = 3.6,\n        max_generation = 400.0,\n        max_turbining = 0.4,\n        min_volume = 0.0,\n        max_volume = 2000.0,\n        om_cost = 10.0,\n    ),\n)\n\nIARA.add_hydro_unit!(db;\n    label = \"hydro_2\",\n    initial_volume = 0.0,\n    bus_id = \"bus_1\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = Int(IARA.HydroUnit_Existence.EXISTS),\n        production_factor = 3.6,\n        max_generation = 700.0,\n        max_turbining = 0.7,\n        min_volume = 0.0,\n        max_volume = 0.0,\n        om_cost = 10.0,\n    ),\n)\n\nIARA.set_hydro_turbine_to!(db, \"hydro_1\", \"hydro_2\")\n\n# Add asset owners (for SFE competition)\nIARA.add_asset_owner!(db;\n    label = \"utility_A\",\n    price_type = IARA.AssetOwner_PriceType.PRICE_MAKER,\n)\n\nIARA.add_asset_owner!(db;\n    label = \"utility_B\",\n    price_type = IARA.AssetOwner_PriceType.PRICE_MAKER,\n)\n\nIARA.add_asset_owner!(db;\n    label = \"utility_C\",\n    price_type = IARA.AssetOwner_PriceType.PRICE_MAKER,\n)\n\n# Create virtual reservoir with multiple owners\nIARA.add_virtual_reservoir!(db;\n    label = \"reservoir_1\",\n    assetowner_id = [\"utility_A\", \"utility_B\", \"utility_C\"],\n    inflow_allocation = [0.4, 0.3, 0.3],\n    initial_energy_account_share = [0.4, 0.3, 0.3],\n    hydrounit_id = [\"hydro_1\", \"hydro_2\"],\n)\n\nIARA.close_study!(db)\n\n# Run training and market clearing\nIARA.train_min_cost(\"path/to/case\")\nIARA.market_clearing(\"path/to/case\")","category":"section"},{"location":"supply_function_equilibrium.html#Modifying-an-Existing-Case","page":"Supply Function Equilibrium","title":"Modifying an Existing Case","text":"# Load existing case\ndb = IARA.load_study(\"path/to/case\"; read_only = false)\n\n# Enable SFE\nIARA.update_configuration!(db;\n    bid_processing = IARA.Configurations_BidProcessing.ITERATED_BIDS_FROM_SUPPLY_FUNCTION_EQUILIBRIUM,\n    reference_curve_number_of_segments = 10,\n)\n\n# Add more asset owners to existing virtual reservoir\nIARA.add_asset_owner!(db;\n    label = \"utility_D\",\n    price_type = IARA.AssetOwner_PriceType.PRICE_MAKER,\n)\n\n# Update virtual reservoir to include new owner\nIARA.delete_element!(db, \"VirtualReservoir\", \"reservoir_1\")\nIARA.add_virtual_reservoir!(db;\n    label = \"reservoir_1\",\n    assetowner_id = [\"utility_A\", \"utility_B\", \"utility_C\", \"utility_D\"],\n    inflow_allocation = [0.3, 0.3, 0.2, 0.2],\n    initial_energy_account_share = [0.3, 0.3, 0.2, 0.2],\n    hydrounit_id = [\"hydro_1\", \"hydro_2\"],\n)\n\nIARA.close_study!(db)\n\n# Run market clearing with SFE\nIARA.market_clearing(\"path/to/case\")","category":"section"},{"location":"supply_function_equilibrium.html#References","page":"Supply Function Equilibrium","title":"References","text":"Klemperer, P., & Meyer, M. (1989). \"Supply Function Equilibria in Oligopoly under Uncertainty.\" Econometrica, 57(6), 1243-1277.\nGreen, R. J., & Newbery, D. M. (1992). \"Competition in the British Electricity Spot Market.\" Journal of Political Economy, 100(5), 929-953.\nHolmberg, P. (2008). \"Unique Supply Function Equilibrium with Capacity Constraints.\" Energy Economics, 30(1), 148-172.\nResende, M. M. Equilíbrio de Nash em Mercados de Energia Elétrica com Formação de Preços por Ofertas. Master's Dissertation. (Portuguese)\nPeixoto, B. Arcabouço Iterativo para Resolução do Equilíbrio de Funções de Oferta em Mercados de Energia Elétrica. Master's Dissertation. (Portuguese)","category":"section"},{"location":"api_reference.html#IARA-API","page":"API Reference","title":"IARA API","text":"","category":"section"},{"location":"api_reference.html#IARA.Configurations_PolicyGraphType","page":"API Reference","title":"IARA.Configurations_PolicyGraphType","text":"Configurations_PolicyGraphType\n\nCYCLIC_WITH_NULL_ROOT: Cyclic policy graph starting at node 1 (0)\nLINEAR: Linear policy graph (1)\nCYCLIC_WITH_SEASON_ROOT: Cyclic policy graph with equal chance of starting at any node (2)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.RunMode","page":"API Reference","title":"IARA.RunMode","text":"RunMode\n\nTRAIN_MIN_COST: Centralized operation (0)\nMARKET_CLEARING: Market clearing (1)\nMIN_COST: Centralized operation simulation (2)\nSINGLE_PERIOD_MARKET_CLEARING: Single period market clearing (3)\nSINGLE_PERIOD_HEURISTIC_BID: Single period heuristic bid (4)\nINTERFACE_CALL: Interface call (5)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.Configurations_TimeSeriesStep","page":"API Reference","title":"IARA.Configurations_TimeSeriesStep","text":"Configurations_TimeSeriesStep\n\nONE_MONTH_PER_PERIOD: Monthly period (0)\nFROZEN_TIME: Frozen time (1)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.Configurations_BidPriceValidation","page":"API Reference","title":"IARA.Configurations_BidPriceValidation","text":"Configurations_BidPriceValidation\n\nDO_NOT_VALIDATE: (0)\nVALIDATE_WITH_DEFAULT_LIMIT: (1)\nVALIDATE_WITH_LIMIT_READ_FROM_FILE: (2)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.Configurations_BidProcessing","page":"API Reference","title":"IARA.Configurations_BidProcessing","text":"Configurations_BidProcessing\n\nREAD_BIDS_FROM_FILE: (0)\nPARAMETERIZED_HEURISTIC_BIDS: (1)\nITERATED_BIDS_FROM_SUPPLY_FUNCTION_EQUILIBRIUM: (2)\nITERATED_BIDS_FROM_MAXIMIZE_REVENUE_EQUILIBRIUM: (3)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.Configurations_MaxRevEquilibriumBusAggregationType","page":"API Reference","title":"IARA.Configurations_MaxRevEquilibriumBusAggregationType","text":"Configurations_MaxRevEquilibriumBusAggregationType\n\nDO_NOT_AGGREGATE: (0)\nAGGREGATE_ALL_BUSES: (1)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.Configurations_MaxRevEquilibriumBidInitialization","page":"API Reference","title":"IARA.Configurations_MaxRevEquilibriumBidInitialization","text":"Configurations_MaxRevEquilibriumBidInitialization\n\nREAD_BIDS_FROM_FILE: (0)\nPARAMETERIZED_HEURISTIC_BIDS: (1)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.Configurations_VariableAggregationType","page":"API Reference","title":"IARA.Configurations_VariableAggregationType","text":"Configurations_VariableAggregationType\n\nSUM: Sum (0)\nAVERAGE: Average (1)\nLAST_VALUE: Last value (2)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.HydroUnit_InitialVolumeDataType","page":"API Reference","title":"IARA.HydroUnit_InitialVolumeDataType","text":"HydroUnit_InitialVolumeDataType\n\nFRACTION_OF_USEFUL_VOLUME: Initial volume in per unit (0)\nABSOLUTE_VOLUME_IN_HM3: Initial volume in hm³ (2)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.DemandUnit_DemandType","page":"API Reference","title":"IARA.DemandUnit_DemandType","text":"DemandUnit_DemandType\n\nINELASTIC: Inelastic demand (0)\nELASTIC: Elastic demand (1)\nFLEXIBLE: Flexible demand (2)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.Branch_LineModel","page":"API Reference","title":"IARA.Branch_LineModel","text":"Branch_LineModel\n\nAC: AC line model (0)\nDC: DC line model (1)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.AssetOwner_PriceType","page":"API Reference","title":"IARA.AssetOwner_PriceType","text":"AssetOwner_PriceType\n\nPRICE_TAKER: Price taker (0)\nPRICE_MAKER: Price maker (1)\nSUPPLY_SECURITY_AGENT: Supply security agent (2)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.BiddingGroup_ExPostAdjustMode","page":"API Reference","title":"IARA.BiddingGroup_ExPostAdjustMode","text":"BiddingGroup_ExPostAdjustMode\n\n- `NO_ADJUSTMENT`: No adjustment (0)\n- `PROPORTIONAL_TO_EX_POST_GENERATION_OVER_EX_ANTE_GENERATION`: Adjust to ex-post availability (1)\n- `PROPORTIONAL_TO_EX_POST_GENERATION_OVER_EX_ANTE_BID`: Adjust to ex-ante bid (2)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.HydroUnit_IntraPeriodOperation","page":"API Reference","title":"IARA.HydroUnit_IntraPeriodOperation","text":"HydroUnit_IntraPeriodOperation\n\nSTATE_VARIABLE: Reservoir operation (0)\nCYCLIC_WITH_FLEXIBLE_START: Run of river operation (1)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.Configurations_IntegerVariableRepresentation","page":"API Reference","title":"IARA.Configurations_IntegerVariableRepresentation","text":"Configurations_IntegerVariableRepresentation\n\nCALCULATE_NORMALLY: Fixed (0)\nFROM_EX_ANTE_PHYSICAL: Fixed from previous step (1)\nLINEARIZE: Linearize (2)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.RunTime_ClearingSubproblem","page":"API Reference","title":"IARA.RunTime_ClearingSubproblem","text":"RunTime_ClearingSubproblem\n\nEX_ANTE_PHYSICAL: Ex-Ante physical (0)\nEX_ANTE_COMMERCIAL: Ex-Ante commercial (1)\nEX_POST_PHYSICAL: Ex-Post physical (2)\nEX_POST_COMMERCIAL: Ex-Post commercial (3)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.Configurations_ConstructionType","page":"API Reference","title":"IARA.Configurations_ConstructionType","text":"Configurations_ConstructionType\n\nSKIP: Skip (-1)\nCOST_BASED: Cost based (0)\nBID_BASED: Bid based (1)\nHYBRID: Hybrid (2)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.Configurations_FinancialSettlementType","page":"API Reference","title":"IARA.Configurations_FinancialSettlementType","text":"Configurations_FinancialSettlementType\n\nNONE: None (-1)\nEX_ANTE: Ex-ante (0)\nEX_POST: Ex-post (1)\nTWO_SETTLEMENT: Double (2)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.Configurations_ThermalUnitIntraPeriodOperation","page":"API Reference","title":"IARA.Configurations_ThermalUnitIntraPeriodOperation","text":"Configurations_ThermalUnitIntraPeriodOperation\n\nCYCLIC_WITH_FLEXIBLE_START: Consider subperiods loop for thermal constraints (1)\nFLEXIBLE_START_FLEXIBLE_END: Do not consider subperiods loop for thermal constraints (0)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.Configurations_NetworkRepresentation","page":"API Reference","title":"IARA.Configurations_NetworkRepresentation","text":"Configurations_NetworkRepresentation\n\nNODAL: Nodal representation (0)\nZONAL: Zonal representation (1)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.Configurations_UncertaintyScenariosFiles","page":"API Reference","title":"IARA.Configurations_UncertaintyScenariosFiles","text":"Configurations_UncertaintyScenariosFiles\n\nFIT_PARP_MODEL_FROM_DATA: Fit PAR(p) model from data (0)\nONLY_EX_ANTE: Only ex-ante (1)\nONLY_EX_POST: Only ex-post (2)\nEX_ANTE_AND_EX_POST: Ex-ante and ex-post (3)\nREAD_PARP_COEFFICIENTS: Read PAR(p) coefficients (4)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.BatteryUnit_Existence","page":"API Reference","title":"IARA.BatteryUnit_Existence","text":"BatteryUnit_Existence\n\nEXISTS: Battery Unit exists (1)\nDOES_NOT_EXIST: Battery Unit does not exist (0)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.Branch_Existence","page":"API Reference","title":"IARA.Branch_Existence","text":"Branch_Existence\n\nEXISTS: Branch exists (1)\nDOES_NOT_EXIST: Branch does not exist (0)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.DCLine_Existence","page":"API Reference","title":"IARA.DCLine_Existence","text":"DCLine_Existence\n\nEXISTS: DC Line exists (1)\nDOES_NOT_EXIST: DC Line does not exist (0)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.Interconnection_Existence","page":"API Reference","title":"IARA.Interconnection_Existence","text":"Interconnection_Existence\n\nEXISTS: Interconnection exists (1)\nDOES_NOT_EXIST: Interconnection does not exist (0)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.DemandUnit_Existence","page":"API Reference","title":"IARA.DemandUnit_Existence","text":"DemandUnit_Existence\n\nEXISTS: Demand exists (1)\nDOES_NOT_EXIST: Demand does not exist (0)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.HydroUnit_Existence","page":"API Reference","title":"IARA.HydroUnit_Existence","text":"HydroUnit_Existence\n\nEXISTS: Hydro Unit exists (1)\nDOES_NOT_EXIST: Hydro Unit does not exist (0)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.RenewableUnit_Existence","page":"API Reference","title":"IARA.RenewableUnit_Existence","text":"RenewableUnit_Existence\n\nEXISTS: Renewable Unit exists (1)\nDOES_NOT_EXIST: Renewable Unit does not exist (0)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.ThermalUnit_Existence","page":"API Reference","title":"IARA.ThermalUnit_Existence","text":"ThermalUnit_Existence\n\nEXISTS: Thermal Unit exists (1)\nDOES_NOT_EXIST: Thermal Unit does not exist (0)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.HydroUnit_HasCommitment","page":"API Reference","title":"IARA.HydroUnit_HasCommitment","text":"HydroUnit_HasCommitment\n\nHAS_COMMITMENT: Hydro Unit has commitment (1)\nNO_COMMITMENT: Hydro Unit has no commitment (0)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.ThermalUnit_HasCommitment","page":"API Reference","title":"IARA.ThermalUnit_HasCommitment","text":"ThermalUnit_HasCommitment\n\nHAS_COMMITMENT: Thermal Unit has commitment (1)\nNO_COMMITMENT: Thermal Unit has no commitment (0)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.ThermalUnit_CommitmentInitialCondition","page":"API Reference","title":"IARA.ThermalUnit_CommitmentInitialCondition","text":"ThermalUnit_CommitmentInitialCondition\n\nON: Initial condition is ON (1)\nOFF: Initial condition is OFF (0)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.ExampleCases.list_of_available_cases","page":"API Reference","title":"IARA.ExampleCases.list_of_available_cases","text":"list_of_available_cases()\n\nReturn a list of available cases to be loaded.\n\n\n\n\n\n","category":"function"},{"location":"api_reference.html#IARA.ExampleCases.build_example_case","page":"API Reference","title":"IARA.ExampleCases.build_example_case","text":"build_example_case(\n    path::AbstractString, \n    case_name::String;\n    force::Bool = false,\n)\n\nBuild the case with the name case_name in the directory path. If the directory does not exist, it will be created. If the directory exists and is not empty, an error will be thrown. The force parameter can be used to overwrite the content of the directory.\n\nthe available cases are listed in the function list_of_available_cases().\n\n\n\n\n\n","category":"function"},{"location":"api_reference.html#IARA.GaugingStation_InflowInitialStateVariationType","page":"API Reference","title":"IARA.GaugingStation_InflowInitialStateVariationType","text":"GaugingStation_InflowInitialStateVariationType\n\nCONSTANT_VALUE: Inflow initial state is given by the last stages of the inflow history (0)\nBY_SCENARIO: Inflow initial state is given by a separate file, and varies by scenario (1)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.HydroUnit_InitialVolumeVariationType","page":"API Reference","title":"IARA.HydroUnit_InitialVolumeVariationType","text":"HydroUnit_InitialVolumeVariationType\n\nCONSTANT_VALUE: Initial volume is given by a parameter in the hydro unit (0)\nBY_SCENARIO: Initial volume is given by a separate file, and varies by scenario (1)\n\n\n\n\n\n","category":"module"},{"location":"api_reference.html#IARA.AssetOwner","page":"API Reference","title":"IARA.AssetOwner","text":"AssetOwner\n\nCollection representing the asset owners in the problem.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.BatteryUnit","page":"API Reference","title":"IARA.BatteryUnit","text":"BatteryUnit\n\nCollection representing the battery unit in the system.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.BiddingGroup","page":"API Reference","title":"IARA.BiddingGroup","text":"BiddingGroup\n\nCollection representing the bidding groups in the system.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.BidsView","page":"API Reference","title":"IARA.BidsView","text":"BidsView\n\nCollection representing the bids data read from external files in chunks.\n\nDimensions cached in bid time series files are static:\n\n1 - Bidding group\n2 - Bus\n3 - Bid segment\n4 - Subperiod\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.Branch","page":"API Reference","title":"IARA.Branch","text":"Branch\n\nCollection representing the Branches in the system.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.Bus","page":"API Reference","title":"IARA.Bus","text":"Bus\n\nCollection representing the buses in the system.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.Collections","page":"API Reference","title":"IARA.Collections","text":"Collections\n\nStruct of all input collections.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.Configurations","page":"API Reference","title":"IARA.Configurations","text":"Configurations\n\nConfigurations for the problem.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.DCLine","page":"API Reference","title":"IARA.DCLine","text":"DCLine\n\nCollection representing the DC lines in the system.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.DemandUnit","page":"API Reference","title":"IARA.DemandUnit","text":"DemandUnit\n\nDemandUnit collection definition.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.ExAnteAndExPostTimeSeriesView","page":"API Reference","title":"IARA.ExAnteAndExPostTimeSeriesView","text":"ExAnteAndExPostTimeSeriesView{T, N}\n\nSome time series can come in two flavours:\n\n1 - Ex-Ante time series: These are time series that are available before the periods of operation. They are used to make decisions for the next period. 2 - Ex-Post time series: These are time series that are available on the period of operation. They are used to make decisions for the current period.\n\nIn some use cases it is necessary to have both time series available. This view is used to store both time series in a single object. If the Ex-Post time series is nit available it will default to use the Ex-Ante time series.\n\nBesides the conceptual idea about the time of availability of the data there is one concrete difference between the two time series: The Ex-Post time series always have one dimension more than the Ex-Ante time series. This extra dimension is called subscenario. For a given period and scenario that the model made a decision we can use multiple new scenarios of the Ex-Post time series. This is the subscenario dimension.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.GaugingStation","page":"API Reference","title":"IARA.GaugingStation","text":"GaugingStation\n\nCollection representing the gauging stations in the system.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.HourSubperiodMapping","page":"API Reference","title":"IARA.HourSubperiodMapping","text":"HourSubperiodMapping\n\nA struct to store the mapping between hours and subperiods. This struct is used to store the mapping between hours and subperiods in the external time series data. It only stores the mapping for one period at a time\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.HydroUnit","page":"API Reference","title":"IARA.HydroUnit","text":"HydroUnit\n\nHydro units are high-level data structures that represent hydro electricity generation.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.InitializeOutput","page":"API Reference","title":"IARA.InitializeOutput","text":"InitializeOutput\n\nAbstract type for problem actions that initialize the output.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.Inputs","page":"API Reference","title":"IARA.Inputs","text":"Inputs\n\nStruct of all input data.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.Interconnection","page":"API Reference","title":"IARA.Interconnection","text":"Interconnection\n\nCollection representing the Interconnections in the system.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.Outputs","page":"API Reference","title":"IARA.Outputs","text":"Outputs\n\nStruct to store parameters related to the outputs of the optimization problem.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.PlotConfig","page":"API Reference","title":"IARA.PlotConfig","text":"PlotConfig\n\nConfiguration for a plot.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.PlotTechnologyHistogram","page":"API Reference","title":"IARA.PlotTechnologyHistogram","text":"PlotTechnologyHistogram\n\nType for plotting a histogram where the observations are the total of generation for a technology, considering all scenarios, periods and subperiods.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.PlotTechnologyHistogramPeriod","page":"API Reference","title":"IARA.PlotTechnologyHistogramPeriod","text":"PlotTechnologyHistogramPeriod\n\nType for plotting a histogram where the observations are the total of generation for a technology at period i, considering all scenarios and subperiods.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.PlotTechnologyHistogramPeriodSubperiod","page":"API Reference","title":"IARA.PlotTechnologyHistogramPeriodSubperiod","text":"PlotTechnologyHistogramPeriodSubperiod\n\nType for plotting a histogram where the observations are the total of generation for a technology at subperiod i, period j, considering all scenarios.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.PlotTechnologyHistogramSubperiod","page":"API Reference","title":"IARA.PlotTechnologyHistogramSubperiod","text":"PlotTechnologyHistogramSubperiod\n\nType for plotting a histogram where the observations are the total of generation for a technology at subperiod i, considering all scenarios and periods.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.PlotTimeSeriesAll","page":"API Reference","title":"IARA.PlotTimeSeriesAll","text":"PlotTimeSeriesAll\n\nType for a time series plot with all scenarios.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.PlotTimeSeriesQuantiles","page":"API Reference","title":"IARA.PlotTimeSeriesQuantiles","text":"PlotTimeSeriesQuantiles\n\nType for a time series plot with P10, P50, and P90 quantiles of scenarios.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.PlotTimeSeriesStackedMean","page":"API Reference","title":"IARA.PlotTimeSeriesStackedMean","text":"PlotTimeSeriesStackedMean\n\nType for a time series plot with the mean of scenarios with all agents stacked.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.PlotType","page":"API Reference","title":"IARA.PlotType","text":"PlotType\n\nAbstract type for a plot type.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.RenewableUnit","page":"API Reference","title":"IARA.RenewableUnit","text":"RenewableUnit\n\nRenewable units are high-level data structures that represent non-dispatchable electricity generation.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.SubproblemBuild","page":"API Reference","title":"IARA.SubproblemBuild","text":"SubproblemBuild\n\nAbstract type for subproblem actions that build the subproblem model.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.SubproblemUpdate","page":"API Reference","title":"IARA.SubproblemUpdate","text":"SubproblemUpdate\n\nAbstract type for subproblem actions that update the subproblem model.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.ThermalUnit","page":"API Reference","title":"IARA.ThermalUnit","text":"ThermalUnit\n\nThermal units are high-level data structures that represent thermal electricity generation.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.TimeSeriesView","page":"API Reference","title":"IARA.TimeSeriesView","text":"TimeSeriesView{T, N}\n\nCollection representing the time series data read from external files in chunks.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.TimeSeriesViewsFromExternalFiles","page":"API Reference","title":"IARA.TimeSeriesViewsFromExternalFiles","text":"TimeSeriesViewsFromExternalFiles\n\nStruct holding all the time series data that is read from external files. All fields only store a reference to the data, which is read from the files in chunks.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.ViewFromExternalFile","page":"API Reference","title":"IARA.ViewFromExternalFile","text":"ViewFromExternalFile\n\nAn abstract type that represents a view of a time series that is stored in an external file. A view represents a chunck of the data in the file. The implementation goal is to avoid loading the entire file into memory.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.VirtualReservoir","page":"API Reference","title":"IARA.VirtualReservoir","text":"VirtualReservoir\n\nCollection representing the virtual reservoir.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.VirtualReservoirBidsView","page":"API Reference","title":"IARA.VirtualReservoirBidsView","text":"VirtualReservoirBidsView\n\nCollection representing the virtual reservoirs' bids data read from external files in chunks.\n\nDimensions cached in virtual reservoir bid time series files are static:\n\n1 - Virtual reservoir\n2 - Asset owner\n3 - Bid segment\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA.WriteOutput","page":"API Reference","title":"IARA.WriteOutput","text":"WriteOutput\n\nAbstract type for problem actions that write the output.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#IARA._extract_bus_idx-Tuple{Any, Any}","page":"API Reference","title":"IARA._extract_bus_idx","text":"_extract_bus_idx(bus_label::String, bus_collection) -> Int\n\nGet the index of a bus given its label.\n\nArguments\n\nbus_label: The bus label to look up\nbus_collection: The bus collection containing labels and indices\n\nReturns\n\nThe index of the bus in the collection\n\nThrows\n\nError if the bus label is not found\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA._extract_bus_label-Tuple{String}","page":"API Reference","title":"IARA._extract_bus_label","text":"_extract_bus_label(gen_label::String) -> String\n\nExtract the bus label from a generation label.\n\nArguments\n\ngen_label: Generation label in format \"bgX - busY\"\n\nReturns\n\nThe bus label (e.g., \"bus_Y\")\n\nThrows\n\nError if the generation label format is invalid\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.add_asset_owner!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite}","page":"API Reference","title":"IARA.add_asset_owner!","text":"add_asset_owner!(db::DatabaseSQLite; kwargs...)\n\nAdd an asset owner to the database.\n\nRequired arguments:\n\nlabel::String: Label of the asset owner\n\nprice_type::Int64: Price type of the asset owner\n0 [Price Taker]\n1 [Price Maker] <default> \n\nminimum_virtual_reservoir_purchase_bid_quantity_in_mw::Float64\n\nvirtual_reservoir_energy_account_upper_bound::Vector{Float64}\n\nrisk_factor_for_virtual_reservoir_bids::Vector{Float64}\n\npurchase_discount_rate::Vector{Float64}\n\nExample:\n\nIARA.add_asset_owner!(\n    db;\n    label = \"AssetOwner1\",\n    price_type = IARA.AssetOwner_PriceType.PRICE_MAKER,\n)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.add_battery_unit!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite}","page":"API Reference","title":"IARA.add_battery_unit!","text":"add_battery_unit!(db::DatabaseSQLite; kwargs...)\n\nAdd a Battery Unit to the database.\n\nRequired arguments:\n\nlabel::String: Label of the battery unit\n\nparameters::DataFrames.DataFrame: A dataframe containing time series attributes (described below).\n\nOptional arguments:\n\ninitial_storage::Float64: Initial storage of the battery unit\n\nbiddinggroup_id::Int64: Bidding group of the battery unit\n\nbus_id::Int64: Bus of the battery unit\n\n\n\nTime Series Attributes\n\nGroup parameters:\n\ndate_time::Vector{DateTime}: date and time of the time series \nexisting::Vector{Int64}: Existing of the battery unit\n0 [Does Not Exist]\n1 [Exists]\nmin_storage::Vector{Float64}: Min storage of the battery unit\nmax_storage::Vector{Float64}: Max storage of the battery unit\nmax_capacity::Vector{Float64}: Max capacity of the battery unit\nom_cost::Vector{Float64}: OM cost of the battery unit [$/MWh]\n\nnote: Note\nbiddinggroup_id is ignored if the IARA.RunMode is set to TRAIN_MIN_COST.\n\nExample:\n\nIARA.add_battery_unit!(db;\n    label = \"bat_1\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [Int(IARA.BatteryUnit_Existence.EXISTS)],\n        min_storage = [0.0],\n        max_storage = [10.0] * 1e3,\n        max_capacity = [0.5],\n        om_cost = [1.0],\n    ),\n    initial_storage = 0.0,\n    bus_id = \"bus_2\",\n)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.add_bidding_group!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite}","page":"API Reference","title":"IARA.add_bidding_group!","text":"add_bidding_group!(db::DatabaseSQLite; kwargs...)\n\nAdd a BiddingGroup to the database.\n\nRequired arguments:\n\nlabel::String: Label of the bidding group\n\nex_post_adjust_mode::Int64\n\nfixed_cost::Float64\n\nOptional arguments:\n\nassetowner_id::Int64: Asset owner of the bidding group\n\nrisk_factor::Vector{Float64}: Risk factor markup of the bidding group\n\nsegment_fraction::Vector{Float64}: Segment fraction of the bidding group\n\nExample:\n\nIARA.add_bidding_group!(\n    db;\n    label = \"bg_1\",\n    assetowner_id = \"asset_owner_1\",\n    risk_factor = [0.5],\n    segment_fraction = [1.0],\n    independent_bid_max_segments = 2,\n)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.add_branch!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite}","page":"API Reference","title":"IARA.add_branch!","text":"add_branch!(db::DatabaseSQLite; kwargs...)\n\nAdd a Branch to the database.\n\nRequired arguments:\n\nlabel::String: Label of the branch\n\nline_model::Int64: Line model of the branch\n0 [AC] <default> \n1 [DC]\n\nparameters::DataFrames.DataFrame: A dataframe containing time series attributes (described below).\n\nOptional arguments:\n\nbus_from::Int64: Bus from of the branch\n\nbus_to::Int64: Bus to of the branch\n\n\n\nTime Series Attributes\n\nGroup parameters:\n\ndate_time::Vector{DateTime}: date and time of the time series \nexisting::Vector{Int64}: Existing of the branch\n0 [Does Not Exist]\n1 [Exists]\ncapacity::Vector{Float64}: Capacity of the branch [MW]\nreactance::Vector{Float64}: Reactance of the branch [p.u.]\n\nnote: Note\nreactance is ignored if the line_model is set to DC.\n\nExample:\n\nIARA.add_branch!(db;\n    label = \"ac_3\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [Int(IARA.Branch_Existence.EXISTS)],\n        capacity = [15.0],\n        reactance = [0.4],\n    ),\n    bus_from = \"bus_2\",\n    bus_to = \"bus_3\",\n)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.add_bus!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite}","page":"API Reference","title":"IARA.add_bus!","text":"add_bus!(db::DatabaseSQLite; kwargs...)\n\nAdd a bus to the database.\n\nRequired arguments:\n\nlabel::String: Label of the bus\n\nOptional arguments:\n\nlatitude::Float64: Latitude of the bus\n\nlongitude::Float64: Longitude of the bus\n\nzone_id::Int64: Zone of the bus\n\nExample:\n\nIARA.add_bus!(db;\n    label = \"bus_1\",\n    zone_id = \"zone_1\",\n)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.add_dc_line!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite}","page":"API Reference","title":"IARA.add_dc_line!","text":"add_dc_line!(db::DatabaseSQLite; kwargs...)\n\nAdd a DC Line to the database.\n\nRequired arguments:\n\nlabel::String: Label of the DC line\n\nparameters::DataFrames.DataFrame: A dataframe containing time series attributes (described below).\n\nOptional arguments:\n\nbus_from::Int64: Bus from of the DC line\n\nbus_to::Int64: Bus to of the DC line\n\n\n\nTime Series Attributes\n\nGroup parameters:\n\ndate_time::Vector{DateTime}: date and time of the time series \nexisting::Vector{Int64}: Existing of the DC line\n0 [Does Not Exist]\n1 [Exists]\ncapacity_to::Vector{Float64}: Capacity to of the DC line [MW]\ncapacity_from::Vector{Float64}: Capacity from of the DC line [MW]\n\nExample:\n\nIARA.add_dc_line!(db;\n    label = \"dc_1\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [Int(IARA.DCLine_Existence.EXISTS)],\n        capacity_to = [5.5],\n        capacity_from = [5.5],\n    ),\n    bus_from = \"bus_1\",\n    bus_to = \"bus_2\",\n)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.add_demand_unit!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite}","page":"API Reference","title":"IARA.add_demand_unit!","text":"add_demand_unit!(db::DatabaseSQLite; kwargs...)\n\nAdd a Demand to the database.\n\nRequired arguments:\n\nlabel::String: Label of the demand unit\n\ndemand_unit_type::Int64: Demand type of the demand unit\n0 [Inelastic] <default> \n1 [Elastic]\n2 [Flexible]\n\nmax_demand::Float64: Max demand of the demand unit [MW]\n\nparameters::DataFrames.DataFrame: A dataframe containing time series attributes (described below).\n\nOptional arguments:\n\nmax_shift_up_flexible_demand::Float64: Max shift up of the demand unit\n\nmax_shift_down_flexible_demand::Float64: Max shift down of the demand unit\n\ncurtailment_cost_flexible_demand::Float64: Curtailment cost of the demand unit (if flexible demand) [$/MWh]\n\nmax_curtailment_flexible_demand::Float64: Max curtailment of the demand unit (if flexible demand)\n\nbiddinggroup_id::Int64\n\nbus_id::Int64: Bus of the demand unit\n\n\n\nTime Series Attributes\n\nGroup parameters:\n\ndate_time::Vector{DateTime}: date and time of the time series \nexisting::Vector{Int64}: Existing of the demand unit\n0 [Does Not Exist]\n1 [Exists]\n\nExample:\n\nIARA.add_demand_unit!(db;\n    label = \"Demand1\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [1],\n    ),\n    bus_id = \"Island\",\n)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.add_gauging_station!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite}","page":"API Reference","title":"IARA.add_gauging_station!","text":"add_gauging_station!(db::DatabaseSQLite; kwargs...)\n\nAdd a Gauging Station to the database.\n\nRequired arguments:\n\nlabel::String: Label of the gauging station\n\ninflow_initial_state_variation_type::Int64\n\nhistorical_inflow::DataFrames.DataFrame: A dataframe containing time series attributes (described below).\n\nOptional arguments:\n\ngaugingstation_downstream::Int64: Gauging station downstream of the gauging station\n\n\n\nTime Series Attributes\n\nGroup historical_inflow:\n\ndate_time::Vector{DateTime}: date and time of the time series \nhistorical_inflow::Vector{Float64}:\n\nnote: Note\nhistorical_inflow is required if Configuration.inflow_scenarios_files is set to FIT_PARP_MODEL_FROM_DATA\n\nExample:\n\nIARA.add_gauging_station!(db;\n    label = \"gauging_station\",\n)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.add_hydro_unit!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite}","page":"API Reference","title":"IARA.add_hydro_unit!","text":"add_hydro_unit!(db::DatabaseSQLite; kwargs...)\n\nAdd a Hydro Unit to the database.\n\nRequired arguments:\n\nlabel::String: Label of the hydro unit\n\ninitial_volume_variation_type::Int64\n\nspillage_cost::Float64\n\nminimum_outflow_violation_benchmark::Float64\n\nparameters::DataFrames.DataFrame: A dataframe containing time series attributes (described below).\n\nOptional arguments:\n\ninitial_volume::Float64: Initial volume of the hydro unit\n\ninitial_volume_type::Int64: Initial volume type of the hydro unit\n0 [Per Unit]\n2 [Volume] <default> \n\nhas_commitment::Int64: Has commitment of the hydro unit\n0 [No Commitment] <default> \n1 [Has Commitment]\n\nintra_period_operation::Int64: Operation type of the hydro unit\n0 [Reservoir] <default> \n1 [Run of River]\n\nminimum_outflow_violation_cost::Float64\n\nhydrounit_spill_to::Int64: Spill to of the hydro unit\n\nhydrounit_turbine_to::Int64: Turbine to of the hydro unit\n\ngaugingstation_id::Int64: Gauging station of the hydro unit\n\nbiddinggroup_id::Int64: Bidding group of the hydro unit\n\nbus_id::Int64: Bus of the hydro unit\n\n\n\nTime Series Attributes\n\nGroup parameters:\n\ndate_time::Vector{DateTime}: date and time of the time series \nexisting::Vector{Int64}: Existing of the hydro unit\n0 [Does Not Exist]\n1 [Exists]\nproduction_factor::Vector{Float64}: Production factor of the hydro unit [MW/m³/s]\nmin_generation::Vector{Float64}: Min generation of the hydro unit [MW]\nmax_generation::Vector{Float64}: Max generation of the hydro unit [MW]\nmax_turbining::Vector{Float64}: Max turbining of the hydro unit [m³/s]\nmin_volume::Vector{Float64}: Min volume of the hydro unit [hm³]\nmax_volume::Vector{Float64}: Max volume of the hydro unit [hm³]\nmin_outflow::Vector{Float64}: Min outflow of the hydro unit [m³/s]\nom_cost::Vector{Float64}: O&M cost of the hydro unit [$/MWh]\n\nnote: Note\nbidding_group_id is required if the run mode is not set to TRAIN_MIN_COST.\nmin_generation is required if has_commitment is set to 1.\n\nExample:\n\nIARA.add_hydro_unit!(db;\n    label = \"Hydro1\",\n    intra_period_operation = IARA.HydroUnit_IntraPeriodOperation.CYCLIC_WITH_FLEXIBLE_START,\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [IARA.HydroUnit_Existence.EXISTS], # 1 = true\n        production_factor = [1.0], # MW/m³/s\n        max_generation = [100.0], # MW\n        max_turbining = [100.0], # m³/s\n        min_volume = [0.0], # hm³\n        max_volume = [0.0], # hm³\n        min_outflow = [0.0], # m³/s\n        om_cost = [0.0], # $/MWh\n    ),\n    initial_volume = 0.0, # hm³\n    gaugingstation_id = \"gauging_station\",\n    biddinggroup_id = \"Hydro Owner\",\n    bus_id = \"Island\",\n)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.add_interconnection!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite}","page":"API Reference","title":"IARA.add_interconnection!","text":"add_interconnection!(db::DatabaseSQLite; kwargs...)\n\nAdd a Interconnection to the database.\n\nRequired arguments:\n\nlabel::String: Label of the interconnection\n\nparameters::DataFrames.DataFrame: A dataframe containing time series attributes (described below).\n\nOptional arguments:\n\nzone_from::Int64: Zone from of the interconnection\n\nzone_to::Int64: Zone to of the interconnection\n\n\n\nTime Series Attributes\n\nGroup parameters:\n\ndate_time::Vector{DateTime}: date and time of the time series \nexisting::Vector{Int64}: Existing of the interconnection\n0 [Does Not Exist]\n1 [Exists]\ncapacity_to::Vector{Float64}: Capacity to of the interconnection [MW]\ncapacity_from::Vector{Float64}: Capacity from of the interconnection [MW]\n\nExample:\n\nIARA.add_interconnection!(db;\n    label = \"dc_1\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [Int(IARA.Interconnection_Existence.EXISTS)],\n        capacity_to = [5.5],\n        capacity_from = [5.5],\n    ),\n    zone_from = \"Zone_1\",\n    zone_to = \"Zone_2\",\n)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.add_renewable_unit!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite}","page":"API Reference","title":"IARA.add_renewable_unit!","text":"add_renewable_unit!(db::DatabaseSQLite; kwargs...)\n\nAdd a Renewable Unit to the database.\n\nRequired arguments:\n\nlabel::String: Label of the renewable unit\n\nparameters::DataFrames.DataFrame: A dataframe containing time series attributes (described below).\n\nOptional arguments:\n\ntechnology_type::Int64: Technology type of the renewable unit\n\nbiddinggroup_id::Int64: Bidding group of the renewable unit\n\nbus_id::Int64: Bus of the renewable unit\n\n\n\nTime Series Attributes\n\nGroup parameters:\n\ndate_time::Vector{DateTime}: date and time of the time series \nexisting::Vector{Int64}: Existing of the renewable unit\n0 [Does Not Exist]\n1 [Exists]\nmax_generation::Vector{Float64}: Max generation of the renewable unit [MW]\nom_cost::Vector{Float64}: O&M cost of the renewable unit [$/MWh]\ncurtailment_cost::Vector{Float64}: Curtailment cost of the renewable unit [$/MWh]\n\nExample:\n\nIARA.add_renewable_unit!(\n    db;\n    label = \"Solar1\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [1],\n        max_generation = [80.0],\n        om_cost = [0.0],\n        curtailment_cost = [100.0],\n    ),\n    biddinggroup_id = \"Price Taker\",\n    bus_id = \"Island\",\n)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.add_thermal_unit!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite}","page":"API Reference","title":"IARA.add_thermal_unit!","text":"add_thermal_unit!(db::DatabaseSQLite; kwargs...)\n\nAdd a Thermal Unit to the database.\n\nRequired arguments:\n\nlabel::String: Label of the thermal unit\n\nhas_commitment::Int64: Has commitment of the thermal unit\n0 [No Commitment] <default> \n1 [Has Commitment]\n\nshutdown_cost::Float64: Shutdown cost of the thermal unit [$/event] <default 0.0> \ncommitment_initial_condition::Int64: Commitment initial condition of the thermal unit\n0 [Off]\n1 [On]\n2 [Undefined] <default> \n\nparameters::DataFrames.DataFrame: A dataframe containing time series attributes (described below).\n\nOptional arguments:\n\nmax_ramp_up::Float64: Max ramp up of the thermal unit [MW/h]\n\nmax_ramp_down::Float64: Max ramp down of the thermal unit [MW/h]\n\nmin_uptime::Float64: Min uptime of the thermal unit [h]\n\nmax_uptime::Float64: Max uptime of the thermal unit [h]\n\nmin_downtime::Float64: Min downtime of the thermal unit [h]\n\nmax_startups::Int64: Max startups of the thermal unit\n\nmax_shutdowns::Int64: Max shutdowns of the thermal unit\n\ngeneration_initial_condition::Float64: Generation initial condition for ramping of the thermal unit [MW]\n\nuptime_initial_condition::Float64: Uptime initial condition of the thermal unit [h]\n\ndowntime_initial_condition::Float64: Downtime initial condition of the thermal unit [h]\n\nbiddinggroup_id::Int64: Bidding group of the thermal unit\n\nbus_id::Int64: Bus of the thermal unit\n\n\n\nTime Series Attributes\n\nGroup parameters:\n\ndate_time::Vector{DateTime}: date and time of the time series \nexisting::Vector{Int64}: Existing of the thermal unit\n0 [Does Not Exist]\n1 [Exists]\nstartup_cost::Vector{Float64}: Startup cost of the thermal unit [$/event]\nmin_generation::Vector{Float64}: Min generation of the thermal unit [MW]\nmax_generation::Vector{Float64}: Max generation of the thermal unit [MW]\nom_cost::Vector{Float64}: O&M cost of the thermal unit [$/MWh]\n\nnote: Note\nbiddinggroup_id is required if IARA.RunMode is not set to TRAIN_MIN_COST.\nmin_generation is ignored if has_commitment is set to 0.\n\nExample:\n\nIARA.add_thermal_unit!(\n    db;\n    label = \"Thermal1\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [1],\n        max_generation = [20.0],\n        om_cost = [10.0],\n    ),\n    biddinggroup_id = \"Thermal Owner\",\n    bus_id = \"Island\",\n)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.add_virtual_reservoir!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite}","page":"API Reference","title":"IARA.add_virtual_reservoir!","text":"add_virtual_reservoir!(db::DatabaseSQLite; kwargs...)\n\nAdd a VirtualReservoir to the database.\n\nRequired arguments:\n\nlabel::String: Label of the virtual reservoir\n\ninflow_allocation::Vector{Float64}: Inflow allocation of the virtual reservoir\n\nOptional arguments:\n\ninitial_energy_account_share::Vector{Float64}\n\nassetowner_id::Vector{Int64}: Asset owner of the virtual reservoir\n\nhydrounit_id::Vector{Int64}: Hydro unit of the virtual reservoir\n\nExample:\n\nIARA.add_virtual_reservoir!(db;\n    label = \"reservoir_1\",\n    assetowner_id = [\"asset_owner_1\", \"asset_owner_2\"],\n    inflow_allocation = [0.4, 0.6],\n    initial_energy_account_share = [0.3, 0.7],\n    hydrounit_id = [\"hydro_1\", \"hydro_2\"],\n)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.add_zone!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite}","page":"API Reference","title":"IARA.add_zone!","text":"add_zone!(db::DatabaseSQLite; kwargs...)\n\nAdd a zone to the database.\n\nRequired arguments:\n\nlabel::String: Label of the zone\n\nExample:\n\nIARA.add_zone!(db; label = \"Island Zone\")\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.advanced_validations-Tuple{IARA.Inputs}","page":"API Reference","title":"IARA.advanced_validations","text":"advanced_validations(inputs::Inputs)\n\nValidate the problem inputs' relations.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.advanced_validations-Tuple{PSRBridge.AbstractInputs, IARA.AssetOwner}","page":"API Reference","title":"IARA.advanced_validations","text":"advanced_validations(inputs::AbstractInputs, asset_owner::AssetOwner)\n\nValidate the AssetOwner within the inputs context. Return the number of errors found.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.advanced_validations-Tuple{PSRBridge.AbstractInputs, IARA.BatteryUnit}","page":"API Reference","title":"IARA.advanced_validations","text":"advanced_validations(inputs::AbstractInputs, battery_unit::BatteryUnit)\n\nValidate the Battery's context within the inputs. Return the number of errors found.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.advanced_validations-Tuple{PSRBridge.AbstractInputs, IARA.BiddingGroup}","page":"API Reference","title":"IARA.advanced_validations","text":"advanced_validations(inputs::AbstractInputs, bidding_group::BiddingGroup)\n\nValidate the BiddingGroup's context within the inputs. Return the number of errors found.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.advanced_validations-Tuple{PSRBridge.AbstractInputs, IARA.Branch}","page":"API Reference","title":"IARA.advanced_validations","text":"advanced_validations(inputs::AbstractInputs, branch::Branch)\n\nValidate the Branch within the inputs context. Return the number of errors found.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.advanced_validations-Tuple{PSRBridge.AbstractInputs, IARA.Bus}","page":"API Reference","title":"IARA.advanced_validations","text":"advanced_validations(inputs::AbstractInputs, bus::Bus)\n\nValidate the Bus within the inputs context. Return the number of errors found.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.advanced_validations-Tuple{PSRBridge.AbstractInputs, IARA.Configurations}","page":"API Reference","title":"IARA.advanced_validations","text":"advanced_validations(inputs::AbstractInputs, configurations::Configurations)\n\nValidate the Configurations' context within the inputs. Return the number of errors found.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.advanced_validations-Tuple{PSRBridge.AbstractInputs, IARA.DCLine}","page":"API Reference","title":"IARA.advanced_validations","text":"advanced_validations(inputs::AbstractInputs, dc_line::DCLine)\n\nValidate the DCLine within the inputs context. Return the number of errors found.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.advanced_validations-Tuple{PSRBridge.AbstractInputs, IARA.DemandUnit}","page":"API Reference","title":"IARA.advanced_validations","text":"advanced_validations(inputs::AbstractInputs, demand_unit::DemandUnit)\n\nValidate the Demand's context within the inputs. Return the number of errors found.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.advanced_validations-Tuple{PSRBridge.AbstractInputs, IARA.GaugingStation}","page":"API Reference","title":"IARA.advanced_validations","text":"advanced_validations(inputs::AbstractInputs, gauging_station::GaugingStation)\n\nValidate the GaugingStation within the inputs context. Return the number of errors found.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.advanced_validations-Tuple{PSRBridge.AbstractInputs, IARA.Interconnection}","page":"API Reference","title":"IARA.advanced_validations","text":"advanced_validations(inputs::AbstractInputs, interconnection::Interconnection)\n\nValidate the Interconnection within the inputs context. Return the number of errors found.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.advanced_validations-Tuple{PSRBridge.AbstractInputs, IARA.RenewableUnit}","page":"API Reference","title":"IARA.advanced_validations","text":"advanced_validations(inputs::AbstractInputs, renewable_unit::RenewableUnit)\n\nValidate the Renewable Units' context within the inputs. Return the number of errors found.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.advanced_validations-Tuple{PSRBridge.AbstractInputs, IARA.ThermalUnit}","page":"API Reference","title":"IARA.advanced_validations","text":"advanced_validations(inputs::AbstractInputs, thermal_unit::ThermalUnit)\n\nValidate the Thermal Unit within the inputs context. Return the number of errors found.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.advanced_validations-Tuple{PSRBridge.AbstractInputs, IARA.VirtualReservoir}","page":"API Reference","title":"IARA.advanced_validations","text":"advanced_validations(inputs::AbstractInputs, virtual_reservoir::VirtualReservoir)\n\nValidate the VirtualReservoir within the inputs context. Return the number of errors found.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.advanced_validations-Tuple{PSRBridge.AbstractInputs, IARA.Zone}","page":"API Reference","title":"IARA.advanced_validations","text":"advanced_validations(inputs::AbstractInputs, zone::Zone)\n\nValidate the Zone within the inputs context. Return the number of errors found.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.agent_mean_and_sd_in_scenarios-Tuple{Type{IARA.PlotTimeSeriesStackedMean}, Array{<:AbstractFloat, 3}, Vector{String}}","page":"API Reference","title":"IARA.agent_mean_and_sd_in_scenarios","text":"agent_mean_and_sd_in_scenarios(::Type{PlotTimeSeriesStackedMean}, data::Array{<:AbstractFloat, 3}, agent_names::Vector{String}; kwargs...)\n\nCalculate the mean and standard deviation of the data across scenarios.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.agent_quantile_in_scenarios-Tuple{Type{IARA.PlotTimeSeriesQuantiles}, Array{<:AbstractFloat, 3}, Vector{String}}","page":"API Reference","title":"IARA.agent_quantile_in_scenarios","text":"agent_quantile_in_scenarios(::Type{PlotTimeSeriesQuantiles}, data::Array{<:AbstractFloat, 3}, agent_names::Vector{String}; kwargs...)\n\nCalculate the P10, P50, and P90 quantiles of the data across scenarios.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.any_valid_elements-Tuple{IARA.Inputs, IARA.RunTimeOptions, Type{<:PSRBridge.AbstractCollection}, Type{<:IARA.AbstractAction}}","page":"API Reference","title":"IARA.any_valid_elements","text":"any_valid_elements(\n    inputs::Inputs,\n    run_time_options::RunTimeOptions,\n    collection::Type{<:AbstractCollection},\n    action::Type{<:AbstractAction};\n    filters::Vector{<:Function} = Function[]\n)\n\nCheck if there are any valid elements in the collection for the given action.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_label-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.asset_owner_label","text":"asset_owner_label(asset_owner::AbstractCollection, i::Integer)\n\nGet the label field from the AssetOwner collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_label-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.asset_owner_label","text":"asset_owner_label(collections::AbstractCollections, i::Integer)\n\nGet the label field from the AssetOwner collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_label-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.asset_owner_label","text":"asset_owner_label(collections::AbstractCollections)\n\nGet the label field from the AssetOwner collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_label-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.asset_owner_label","text":"asset_owner_label(asset_owner::AbstractCollection)\n\nGet the label field from the AssetOwner collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_label-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.asset_owner_label","text":"asset_owner_label(inputs::AbstractInputs, i::Integer)\n\nGet the label field from the AssetOwner collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_label-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.asset_owner_label","text":"asset_owner_label(inputs::AbstractInputs)\n\nGet the label field from the AssetOwner collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_max_convex_hull_length-Tuple{PSRBridge.AbstractInputs, Int64, Int64}","page":"API Reference","title":"IARA.asset_owner_max_convex_hull_length","text":"asset_owner_max_convex_hull_length(inputs::AbstractInputs, bus::Int, subperiod::Int)\n\nReturn the maximum number of points in the revenue convex hull cache at a given bus and subperiod.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_minimum_virtual_reservoir_purchase_bid_quantity_in_mw-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.asset_owner_minimum_virtual_reservoir_purchase_bid_quantity_in_mw","text":"asset_owner_minimum_virtual_reservoir_purchase_bid_quantity_in_mw(asset_owner::AbstractCollection, i::Integer)\n\nGet the minimumvirtualreservoirpurchasebidquantityin_mw field from the AssetOwner collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_minimum_virtual_reservoir_purchase_bid_quantity_in_mw-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.asset_owner_minimum_virtual_reservoir_purchase_bid_quantity_in_mw","text":"asset_owner_minimum_virtual_reservoir_purchase_bid_quantity_in_mw(collections::AbstractCollections, i::Integer)\n\nGet the minimumvirtualreservoirpurchasebidquantityin_mw field from the AssetOwner collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_minimum_virtual_reservoir_purchase_bid_quantity_in_mw-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.asset_owner_minimum_virtual_reservoir_purchase_bid_quantity_in_mw","text":"asset_owner_minimum_virtual_reservoir_purchase_bid_quantity_in_mw(collections::AbstractCollections)\n\nGet the minimum_virtual_reservoir_purchase_bid_quantity_in_mw field from the AssetOwner collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_minimum_virtual_reservoir_purchase_bid_quantity_in_mw-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.asset_owner_minimum_virtual_reservoir_purchase_bid_quantity_in_mw","text":"asset_owner_minimum_virtual_reservoir_purchase_bid_quantity_in_mw(asset_owner::AbstractCollection)\n\nGet the minimum_virtual_reservoir_purchase_bid_quantity_in_mw field from the AssetOwner collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_minimum_virtual_reservoir_purchase_bid_quantity_in_mw-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.asset_owner_minimum_virtual_reservoir_purchase_bid_quantity_in_mw","text":"asset_owner_minimum_virtual_reservoir_purchase_bid_quantity_in_mw(inputs::AbstractInputs, i::Integer)\n\nGet the minimumvirtualreservoirpurchasebidquantityin_mw field from the AssetOwner collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_minimum_virtual_reservoir_purchase_bid_quantity_in_mw-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.asset_owner_minimum_virtual_reservoir_purchase_bid_quantity_in_mw","text":"asset_owner_minimum_virtual_reservoir_purchase_bid_quantity_in_mw(inputs::AbstractInputs)\n\nGet the minimum_virtual_reservoir_purchase_bid_quantity_in_mw field from the AssetOwner collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_price_type-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.asset_owner_price_type","text":"asset_owner_price_type(asset_owner::AbstractCollection, i::Integer)\n\nGet the price_type field from the AssetOwner collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_price_type-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.asset_owner_price_type","text":"asset_owner_price_type(collections::AbstractCollections, i::Integer)\n\nGet the price_type field from the AssetOwner collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_price_type-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.asset_owner_price_type","text":"asset_owner_price_type(collections::AbstractCollections)\n\nGet the price_type field from the AssetOwner collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_price_type-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.asset_owner_price_type","text":"asset_owner_price_type(asset_owner::AbstractCollection)\n\nGet the price_type field from the AssetOwner collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_price_type-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.asset_owner_price_type","text":"asset_owner_price_type(inputs::AbstractInputs, i::Integer)\n\nGet the price_type field from the AssetOwner collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_price_type-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.asset_owner_price_type","text":"asset_owner_price_type(inputs::AbstractInputs)\n\nGet the price_type field from the AssetOwner collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_purchase_discount_rate-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.asset_owner_purchase_discount_rate","text":"asset_owner_purchase_discount_rate(asset_owner::AbstractCollection, i::Integer)\n\nGet the purchasediscountrate field from the AssetOwner collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_purchase_discount_rate-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.asset_owner_purchase_discount_rate","text":"asset_owner_purchase_discount_rate(collections::AbstractCollections, i::Integer)\n\nGet the purchasediscountrate field from the AssetOwner collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_purchase_discount_rate-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.asset_owner_purchase_discount_rate","text":"asset_owner_purchase_discount_rate(collections::AbstractCollections)\n\nGet the purchase_discount_rate field from the AssetOwner collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_purchase_discount_rate-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.asset_owner_purchase_discount_rate","text":"asset_owner_purchase_discount_rate(asset_owner::AbstractCollection)\n\nGet the purchase_discount_rate field from the AssetOwner collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_purchase_discount_rate-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.asset_owner_purchase_discount_rate","text":"asset_owner_purchase_discount_rate(inputs::AbstractInputs, i::Integer)\n\nGet the purchasediscountrate field from the AssetOwner collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_purchase_discount_rate-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.asset_owner_purchase_discount_rate","text":"asset_owner_purchase_discount_rate(inputs::AbstractInputs)\n\nGet the purchase_discount_rate field from the AssetOwner collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_revenue_convex_hull-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.asset_owner_revenue_convex_hull","text":"asset_owner_revenue_convex_hull(asset_owner::AbstractCollection, i::Integer)\n\nGet the revenueconvexhull field from the AssetOwner collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_revenue_convex_hull-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.asset_owner_revenue_convex_hull","text":"asset_owner_revenue_convex_hull(collections::AbstractCollections, i::Integer)\n\nGet the revenueconvexhull field from the AssetOwner collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_revenue_convex_hull-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.asset_owner_revenue_convex_hull","text":"asset_owner_revenue_convex_hull(collections::AbstractCollections)\n\nGet the revenue_convex_hull field from the AssetOwner collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_revenue_convex_hull-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.asset_owner_revenue_convex_hull","text":"asset_owner_revenue_convex_hull(asset_owner::AbstractCollection)\n\nGet the revenue_convex_hull field from the AssetOwner collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_revenue_convex_hull-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.asset_owner_revenue_convex_hull","text":"asset_owner_revenue_convex_hull(inputs::AbstractInputs, i::Integer)\n\nGet the revenueconvexhull field from the AssetOwner collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_revenue_convex_hull-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.asset_owner_revenue_convex_hull","text":"asset_owner_revenue_convex_hull(inputs::AbstractInputs)\n\nGet the revenue_convex_hull field from the AssetOwner collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_revenue_convex_hull_point-Tuple{PSRBridge.AbstractInputs, Int64, Int64, Int64}","page":"API Reference","title":"IARA.asset_owner_revenue_convex_hull_point","text":"asset_owner_revenue_convex_hull_point(inputs::AbstractInputs, bus::Int, subperiod::Int, point_idx::Int)\n\nReturn a point in the revenue convex hull cache at a given bus and subperiod.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_risk_factor_for_virtual_reservoir_bids-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.asset_owner_risk_factor_for_virtual_reservoir_bids","text":"asset_owner_risk_factor_for_virtual_reservoir_bids(asset_owner::AbstractCollection, i::Integer)\n\nGet the riskfactorforvirtualreservoir_bids field from the AssetOwner collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_risk_factor_for_virtual_reservoir_bids-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.asset_owner_risk_factor_for_virtual_reservoir_bids","text":"asset_owner_risk_factor_for_virtual_reservoir_bids(collections::AbstractCollections, i::Integer)\n\nGet the riskfactorforvirtualreservoir_bids field from the AssetOwner collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_risk_factor_for_virtual_reservoir_bids-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.asset_owner_risk_factor_for_virtual_reservoir_bids","text":"asset_owner_risk_factor_for_virtual_reservoir_bids(collections::AbstractCollections)\n\nGet the risk_factor_for_virtual_reservoir_bids field from the AssetOwner collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_risk_factor_for_virtual_reservoir_bids-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.asset_owner_risk_factor_for_virtual_reservoir_bids","text":"asset_owner_risk_factor_for_virtual_reservoir_bids(asset_owner::AbstractCollection)\n\nGet the risk_factor_for_virtual_reservoir_bids field from the AssetOwner collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_risk_factor_for_virtual_reservoir_bids-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.asset_owner_risk_factor_for_virtual_reservoir_bids","text":"asset_owner_risk_factor_for_virtual_reservoir_bids(inputs::AbstractInputs, i::Integer)\n\nGet the riskfactorforvirtualreservoir_bids field from the AssetOwner collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_risk_factor_for_virtual_reservoir_bids-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.asset_owner_risk_factor_for_virtual_reservoir_bids","text":"asset_owner_risk_factor_for_virtual_reservoir_bids(inputs::AbstractInputs)\n\nGet the risk_factor_for_virtual_reservoir_bids field from the AssetOwner collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_virtual_reservoir_energy_account_upper_bound-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.asset_owner_virtual_reservoir_energy_account_upper_bound","text":"asset_owner_virtual_reservoir_energy_account_upper_bound(asset_owner::AbstractCollection, i::Integer)\n\nGet the virtualreservoirenergyaccountupper_bound field from the AssetOwner collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_virtual_reservoir_energy_account_upper_bound-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.asset_owner_virtual_reservoir_energy_account_upper_bound","text":"asset_owner_virtual_reservoir_energy_account_upper_bound(collections::AbstractCollections, i::Integer)\n\nGet the virtualreservoirenergyaccountupper_bound field from the AssetOwner collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_virtual_reservoir_energy_account_upper_bound-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.asset_owner_virtual_reservoir_energy_account_upper_bound","text":"asset_owner_virtual_reservoir_energy_account_upper_bound(collections::AbstractCollections)\n\nGet the virtual_reservoir_energy_account_upper_bound field from the AssetOwner collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_virtual_reservoir_energy_account_upper_bound-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.asset_owner_virtual_reservoir_energy_account_upper_bound","text":"asset_owner_virtual_reservoir_energy_account_upper_bound(asset_owner::AbstractCollection)\n\nGet the virtual_reservoir_energy_account_upper_bound field from the AssetOwner collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_virtual_reservoir_energy_account_upper_bound-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.asset_owner_virtual_reservoir_energy_account_upper_bound","text":"asset_owner_virtual_reservoir_energy_account_upper_bound(inputs::AbstractInputs, i::Integer)\n\nGet the virtualreservoirenergyaccountupper_bound field from the AssetOwner collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.asset_owner_virtual_reservoir_energy_account_upper_bound-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.asset_owner_virtual_reservoir_energy_account_upper_bound","text":"asset_owner_virtual_reservoir_energy_account_upper_bound(inputs::AbstractInputs)\n\nGet the virtual_reservoir_energy_account_upper_bound field from the AssetOwner collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_balance!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.battery_unit_balance!","text":"battery_unit_balance!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the battery unit balance constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_bidding_group_index-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.battery_unit_bidding_group_index","text":"battery_unit_bidding_group_index(battery_unit::AbstractCollection, i::Integer)\n\nGet the biddinggroupindex field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_bidding_group_index-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.battery_unit_bidding_group_index","text":"battery_unit_bidding_group_index(collections::AbstractCollections, i::Integer)\n\nGet the biddinggroupindex field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_bidding_group_index-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.battery_unit_bidding_group_index","text":"battery_unit_bidding_group_index(collections::AbstractCollections)\n\nGet the bidding_group_index field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_bidding_group_index-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.battery_unit_bidding_group_index","text":"battery_unit_bidding_group_index(battery_unit::AbstractCollection)\n\nGet the bidding_group_index field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_bidding_group_index-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.battery_unit_bidding_group_index","text":"battery_unit_bidding_group_index(inputs::AbstractInputs, i::Integer)\n\nGet the biddinggroupindex field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_bidding_group_index-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.battery_unit_bidding_group_index","text":"battery_unit_bidding_group_index(inputs::AbstractInputs)\n\nGet the bidding_group_index field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_bus_index-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.battery_unit_bus_index","text":"battery_unit_bus_index(battery_unit::AbstractCollection, i::Integer)\n\nGet the bus_index field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_bus_index-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.battery_unit_bus_index","text":"battery_unit_bus_index(collections::AbstractCollections, i::Integer)\n\nGet the bus_index field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_bus_index-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.battery_unit_bus_index","text":"battery_unit_bus_index(collections::AbstractCollections)\n\nGet the bus_index field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_bus_index-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.battery_unit_bus_index","text":"battery_unit_bus_index(battery_unit::AbstractCollection)\n\nGet the bus_index field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_bus_index-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.battery_unit_bus_index","text":"battery_unit_bus_index(inputs::AbstractInputs, i::Integer)\n\nGet the bus_index field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_bus_index-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.battery_unit_bus_index","text":"battery_unit_bus_index(inputs::AbstractInputs)\n\nGet the bus_index field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_existing-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.battery_unit_existing","text":"battery_unit_existing(battery_unit::AbstractCollection, i::Integer)\n\nGet the existing field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_existing-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.battery_unit_existing","text":"battery_unit_existing(collections::AbstractCollections, i::Integer)\n\nGet the existing field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_existing-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.battery_unit_existing","text":"battery_unit_existing(collections::AbstractCollections)\n\nGet the existing field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_existing-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.battery_unit_existing","text":"battery_unit_existing(battery_unit::AbstractCollection)\n\nGet the existing field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_existing-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.battery_unit_existing","text":"battery_unit_existing(inputs::AbstractInputs, i::Integer)\n\nGet the existing field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_existing-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.battery_unit_existing","text":"battery_unit_existing(inputs::AbstractInputs)\n\nGet the existing field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_generation!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, IARA.SimulationResultsFromPeriodScenario, Int64, Int64, Int64, Type{IARA.WriteOutput}}","page":"API Reference","title":"IARA.battery_unit_generation!","text":"battery_unit_generation!(outputs, inputs::Inputs, run_time_options::RunTimeOptions, simulation_results::SimulationResultsFromPeriodScenario, period::Int, scenario::Int, subscenario::Int, ::Type{WriteOutput})\n\nWrite the battery unit generation variables' values to the output.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_generation!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.InitializeOutput}}","page":"API Reference","title":"IARA.battery_unit_generation!","text":"battery_unit_generation!(outputs::Outputs, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{InitializeOutput})\n\nInitialize the output file to store the battery unit generation variables' values.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_generation!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.battery_unit_generation!","text":"battery_unit_generation!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the battery unit generation variables to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_initial_storage-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.battery_unit_initial_storage","text":"battery_unit_initial_storage(battery_unit::AbstractCollection, i::Integer)\n\nGet the initial_storage field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_initial_storage-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.battery_unit_initial_storage","text":"battery_unit_initial_storage(collections::AbstractCollections, i::Integer)\n\nGet the initial_storage field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_initial_storage-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.battery_unit_initial_storage","text":"battery_unit_initial_storage(collections::AbstractCollections)\n\nGet the initial_storage field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_initial_storage-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.battery_unit_initial_storage","text":"battery_unit_initial_storage(battery_unit::AbstractCollection)\n\nGet the initial_storage field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_initial_storage-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.battery_unit_initial_storage","text":"battery_unit_initial_storage(inputs::AbstractInputs, i::Integer)\n\nGet the initial_storage field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_initial_storage-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.battery_unit_initial_storage","text":"battery_unit_initial_storage(inputs::AbstractInputs)\n\nGet the initial_storage field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_label-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.battery_unit_label","text":"battery_unit_label(battery_unit::AbstractCollection, i::Integer)\n\nGet the label field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_label-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.battery_unit_label","text":"battery_unit_label(collections::AbstractCollections, i::Integer)\n\nGet the label field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_label-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.battery_unit_label","text":"battery_unit_label(collections::AbstractCollections)\n\nGet the label field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_label-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.battery_unit_label","text":"battery_unit_label(battery_unit::AbstractCollection)\n\nGet the label field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_label-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.battery_unit_label","text":"battery_unit_label(inputs::AbstractInputs, i::Integer)\n\nGet the label field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_label-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.battery_unit_label","text":"battery_unit_label(inputs::AbstractInputs)\n\nGet the label field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_max_capacity-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.battery_unit_max_capacity","text":"battery_unit_max_capacity(battery_unit::AbstractCollection, i::Integer)\n\nGet the max_capacity field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_max_capacity-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.battery_unit_max_capacity","text":"battery_unit_max_capacity(collections::AbstractCollections, i::Integer)\n\nGet the max_capacity field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_max_capacity-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.battery_unit_max_capacity","text":"battery_unit_max_capacity(collections::AbstractCollections)\n\nGet the max_capacity field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_max_capacity-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.battery_unit_max_capacity","text":"battery_unit_max_capacity(battery_unit::AbstractCollection)\n\nGet the max_capacity field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_max_capacity-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.battery_unit_max_capacity","text":"battery_unit_max_capacity(inputs::AbstractInputs, i::Integer)\n\nGet the max_capacity field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_max_capacity-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.battery_unit_max_capacity","text":"battery_unit_max_capacity(inputs::AbstractInputs)\n\nGet the max_capacity field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_max_storage-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.battery_unit_max_storage","text":"battery_unit_max_storage(battery_unit::AbstractCollection, i::Integer)\n\nGet the max_storage field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_max_storage-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.battery_unit_max_storage","text":"battery_unit_max_storage(collections::AbstractCollections, i::Integer)\n\nGet the max_storage field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_max_storage-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.battery_unit_max_storage","text":"battery_unit_max_storage(collections::AbstractCollections)\n\nGet the max_storage field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_max_storage-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.battery_unit_max_storage","text":"battery_unit_max_storage(battery_unit::AbstractCollection)\n\nGet the max_storage field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_max_storage-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.battery_unit_max_storage","text":"battery_unit_max_storage(inputs::AbstractInputs, i::Integer)\n\nGet the max_storage field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_max_storage-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.battery_unit_max_storage","text":"battery_unit_max_storage(inputs::AbstractInputs)\n\nGet the max_storage field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_min_storage-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.battery_unit_min_storage","text":"battery_unit_min_storage(battery_unit::AbstractCollection, i::Integer)\n\nGet the min_storage field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_min_storage-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.battery_unit_min_storage","text":"battery_unit_min_storage(collections::AbstractCollections, i::Integer)\n\nGet the min_storage field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_min_storage-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.battery_unit_min_storage","text":"battery_unit_min_storage(collections::AbstractCollections)\n\nGet the min_storage field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_min_storage-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.battery_unit_min_storage","text":"battery_unit_min_storage(battery_unit::AbstractCollection)\n\nGet the min_storage field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_min_storage-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.battery_unit_min_storage","text":"battery_unit_min_storage(inputs::AbstractInputs, i::Integer)\n\nGet the min_storage field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_min_storage-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.battery_unit_min_storage","text":"battery_unit_min_storage(inputs::AbstractInputs)\n\nGet the min_storage field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_om_cost-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.battery_unit_om_cost","text":"battery_unit_om_cost(battery_unit::AbstractCollection, i::Integer)\n\nGet the om_cost field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_om_cost-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.battery_unit_om_cost","text":"battery_unit_om_cost(collections::AbstractCollections, i::Integer)\n\nGet the om_cost field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_om_cost-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.battery_unit_om_cost","text":"battery_unit_om_cost(collections::AbstractCollections)\n\nGet the om_cost field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_om_cost-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.battery_unit_om_cost","text":"battery_unit_om_cost(battery_unit::AbstractCollection)\n\nGet the om_cost field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_om_cost-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.battery_unit_om_cost","text":"battery_unit_om_cost(inputs::AbstractInputs, i::Integer)\n\nGet the om_cost field from the BatteryUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_om_cost-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.battery_unit_om_cost","text":"battery_unit_om_cost(inputs::AbstractInputs)\n\nGet the om_cost field from the BatteryUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_storage!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, IARA.SimulationResultsFromPeriodScenario, Int64, Int64, Int64, Type{IARA.WriteOutput}}","page":"API Reference","title":"IARA.battery_unit_storage!","text":"battery_unit_storage!(outputs, inputs::Inputs, run_time_options::RunTimeOptions, simulation_results::SimulationResultsFromPeriodScenario, period::Int, scenario::Int, subscenario::Int, ::Type{WriteOutput})\n\nWrite the battery unit storage variables' values to the output.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_storage!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.InitializeOutput}}","page":"API Reference","title":"IARA.battery_unit_storage!","text":"battery_unit_storage!(outputs::Outputs, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{InitializeOutput})\n\nInitialize the output file to store the battery unit storage variables' values.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.battery_unit_storage!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.battery_unit_storage!","text":"battery_unit_storage!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the battery unit storage variables to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bid_based_market_clearing_model_action-Tuple","page":"API Reference","title":"IARA.bid_based_market_clearing_model_action","text":"bid_based_market_clearing_model_action(args...)\n\nBid based market clearing model action.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bid_price_limit_high_reference-Tuple{Any}","page":"API Reference","title":"IARA.bid_price_limit_high_reference","text":"bid_price_limit_high_reference(inputs)\n\nReturn the high reference price for bid price limits.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bid_price_limit_low_reference-Tuple{Any}","page":"API Reference","title":"IARA.bid_price_limit_low_reference","text":"bid_price_limit_low_reference(inputs)\n\nReturn the low reference price for bid price limits.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bid_price_limit_markup_justified_independent-Tuple{Any}","page":"API Reference","title":"IARA.bid_price_limit_markup_justified_independent","text":"bid_price_limit_markup_justified_independent(inputs)\n\nReturn the bid price limit markup for justified independent bids.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bid_price_limit_markup_justified_profile-Tuple{Any}","page":"API Reference","title":"IARA.bid_price_limit_markup_justified_profile","text":"bid_price_limit_markup_justified_profile(inputs)\n\nReturn the bid price limit markup for justified profile bids.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bid_price_limit_markup_non_justified_independent-Tuple{Any}","page":"API Reference","title":"IARA.bid_price_limit_markup_non_justified_independent","text":"bid_price_limit_markup_non_justified_independent(inputs)\n\nReturn the bid price limit markup for non-justified independent bids.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bid_price_limit_markup_non_justified_profile-Tuple{Any}","page":"API Reference","title":"IARA.bid_price_limit_markup_non_justified_profile","text":"bid_price_limit_markup_non_justified_profile(inputs)\n\nReturn the bid price limit markup for non-justified profile bids.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bid_price_validation-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.bid_price_validation","text":"bid_price_validation(inputs::AbstractInputs)\n\nReturn the bid price validation strategy.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bid_processing-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.bid_processing","text":"bid_processing(inputs::AbstractInputs)\n\nReturn the bid processing strategy.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_asset_owner_index-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.bidding_group_asset_owner_index","text":"bidding_group_asset_owner_index(bidding_group::AbstractCollection, i::Integer)\n\nGet the assetownerindex field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_asset_owner_index-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.bidding_group_asset_owner_index","text":"bidding_group_asset_owner_index(collections::AbstractCollections, i::Integer)\n\nGet the assetownerindex field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_asset_owner_index-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.bidding_group_asset_owner_index","text":"bidding_group_asset_owner_index(collections::AbstractCollections)\n\nGet the asset_owner_index field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_asset_owner_index-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.bidding_group_asset_owner_index","text":"bidding_group_asset_owner_index(bidding_group::AbstractCollection)\n\nGet the asset_owner_index field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_asset_owner_index-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.bidding_group_asset_owner_index","text":"bidding_group_asset_owner_index(inputs::AbstractInputs, i::Integer)\n\nGet the assetownerindex field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_asset_owner_index-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.bidding_group_asset_owner_index","text":"bidding_group_asset_owner_index(inputs::AbstractInputs)\n\nGet the asset_owner_index field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_justifications_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.bidding_group_bid_justifications_file","text":"bidding_group_bid_justifications_file(bidding_group::AbstractCollection, i::Integer)\n\nGet the bidjustificationsfile field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_justifications_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.bidding_group_bid_justifications_file","text":"bidding_group_bid_justifications_file(collections::AbstractCollections, i::Integer)\n\nGet the bidjustificationsfile field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_justifications_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.bidding_group_bid_justifications_file","text":"bidding_group_bid_justifications_file(collections::AbstractCollections)\n\nGet the bid_justifications_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_justifications_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.bidding_group_bid_justifications_file","text":"bidding_group_bid_justifications_file(bidding_group::AbstractCollection)\n\nGet the bid_justifications_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_justifications_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.bidding_group_bid_justifications_file","text":"bidding_group_bid_justifications_file(inputs::AbstractInputs, i::Integer)\n\nGet the bidjustificationsfile field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_justifications_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.bidding_group_bid_justifications_file","text":"bidding_group_bid_justifications_file(inputs::AbstractInputs)\n\nGet the bid_justifications_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_price_limit_justified_independent_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.bidding_group_bid_price_limit_justified_independent_file","text":"bidding_group_bid_price_limit_justified_independent_file(bidding_group::AbstractCollection, i::Integer)\n\nGet the bidpricelimitjustifiedindependent_file field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_price_limit_justified_independent_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.bidding_group_bid_price_limit_justified_independent_file","text":"bidding_group_bid_price_limit_justified_independent_file(collections::AbstractCollections, i::Integer)\n\nGet the bidpricelimitjustifiedindependent_file field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_price_limit_justified_independent_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.bidding_group_bid_price_limit_justified_independent_file","text":"bidding_group_bid_price_limit_justified_independent_file(collections::AbstractCollections)\n\nGet the bid_price_limit_justified_independent_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_price_limit_justified_independent_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.bidding_group_bid_price_limit_justified_independent_file","text":"bidding_group_bid_price_limit_justified_independent_file(bidding_group::AbstractCollection)\n\nGet the bid_price_limit_justified_independent_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_price_limit_justified_independent_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.bidding_group_bid_price_limit_justified_independent_file","text":"bidding_group_bid_price_limit_justified_independent_file(inputs::AbstractInputs, i::Integer)\n\nGet the bidpricelimitjustifiedindependent_file field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_price_limit_justified_independent_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.bidding_group_bid_price_limit_justified_independent_file","text":"bidding_group_bid_price_limit_justified_independent_file(inputs::AbstractInputs)\n\nGet the bid_price_limit_justified_independent_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_price_limit_justified_profile_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.bidding_group_bid_price_limit_justified_profile_file","text":"bidding_group_bid_price_limit_justified_profile_file(bidding_group::AbstractCollection, i::Integer)\n\nGet the bidpricelimitjustifiedprofile_file field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_price_limit_justified_profile_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.bidding_group_bid_price_limit_justified_profile_file","text":"bidding_group_bid_price_limit_justified_profile_file(collections::AbstractCollections, i::Integer)\n\nGet the bidpricelimitjustifiedprofile_file field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_price_limit_justified_profile_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.bidding_group_bid_price_limit_justified_profile_file","text":"bidding_group_bid_price_limit_justified_profile_file(collections::AbstractCollections)\n\nGet the bid_price_limit_justified_profile_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_price_limit_justified_profile_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.bidding_group_bid_price_limit_justified_profile_file","text":"bidding_group_bid_price_limit_justified_profile_file(bidding_group::AbstractCollection)\n\nGet the bid_price_limit_justified_profile_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_price_limit_justified_profile_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.bidding_group_bid_price_limit_justified_profile_file","text":"bidding_group_bid_price_limit_justified_profile_file(inputs::AbstractInputs, i::Integer)\n\nGet the bidpricelimitjustifiedprofile_file field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_price_limit_justified_profile_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.bidding_group_bid_price_limit_justified_profile_file","text":"bidding_group_bid_price_limit_justified_profile_file(inputs::AbstractInputs)\n\nGet the bid_price_limit_justified_profile_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_price_limit_non_justified_independent_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.bidding_group_bid_price_limit_non_justified_independent_file","text":"bidding_group_bid_price_limit_non_justified_independent_file(bidding_group::AbstractCollection, i::Integer)\n\nGet the bidpricelimitnonjustifiedindependentfile field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_price_limit_non_justified_independent_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.bidding_group_bid_price_limit_non_justified_independent_file","text":"bidding_group_bid_price_limit_non_justified_independent_file(collections::AbstractCollections, i::Integer)\n\nGet the bidpricelimitnonjustifiedindependentfile field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_price_limit_non_justified_independent_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.bidding_group_bid_price_limit_non_justified_independent_file","text":"bidding_group_bid_price_limit_non_justified_independent_file(collections::AbstractCollections)\n\nGet the bid_price_limit_non_justified_independent_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_price_limit_non_justified_independent_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.bidding_group_bid_price_limit_non_justified_independent_file","text":"bidding_group_bid_price_limit_non_justified_independent_file(bidding_group::AbstractCollection)\n\nGet the bid_price_limit_non_justified_independent_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_price_limit_non_justified_independent_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.bidding_group_bid_price_limit_non_justified_independent_file","text":"bidding_group_bid_price_limit_non_justified_independent_file(inputs::AbstractInputs, i::Integer)\n\nGet the bidpricelimitnonjustifiedindependentfile field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_price_limit_non_justified_independent_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.bidding_group_bid_price_limit_non_justified_independent_file","text":"bidding_group_bid_price_limit_non_justified_independent_file(inputs::AbstractInputs)\n\nGet the bid_price_limit_non_justified_independent_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_price_limit_non_justified_profile_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.bidding_group_bid_price_limit_non_justified_profile_file","text":"bidding_group_bid_price_limit_non_justified_profile_file(bidding_group::AbstractCollection, i::Integer)\n\nGet the bidpricelimitnonjustifiedprofilefile field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_price_limit_non_justified_profile_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.bidding_group_bid_price_limit_non_justified_profile_file","text":"bidding_group_bid_price_limit_non_justified_profile_file(collections::AbstractCollections, i::Integer)\n\nGet the bidpricelimitnonjustifiedprofilefile field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_price_limit_non_justified_profile_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.bidding_group_bid_price_limit_non_justified_profile_file","text":"bidding_group_bid_price_limit_non_justified_profile_file(collections::AbstractCollections)\n\nGet the bid_price_limit_non_justified_profile_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_price_limit_non_justified_profile_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.bidding_group_bid_price_limit_non_justified_profile_file","text":"bidding_group_bid_price_limit_non_justified_profile_file(bidding_group::AbstractCollection)\n\nGet the bid_price_limit_non_justified_profile_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_price_limit_non_justified_profile_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.bidding_group_bid_price_limit_non_justified_profile_file","text":"bidding_group_bid_price_limit_non_justified_profile_file(inputs::AbstractInputs, i::Integer)\n\nGet the bidpricelimitnonjustifiedprofilefile field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_bid_price_limit_non_justified_profile_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.bidding_group_bid_price_limit_non_justified_profile_file","text":"bidding_group_bid_price_limit_non_justified_profile_file(inputs::AbstractInputs)\n\nGet the bid_price_limit_non_justified_profile_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_complementary_grouping_profile_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.bidding_group_complementary_grouping_profile_file","text":"bidding_group_complementary_grouping_profile_file(bidding_group::AbstractCollection, i::Integer)\n\nGet the complementarygroupingprofile_file field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_complementary_grouping_profile_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.bidding_group_complementary_grouping_profile_file","text":"bidding_group_complementary_grouping_profile_file(collections::AbstractCollections, i::Integer)\n\nGet the complementarygroupingprofile_file field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_complementary_grouping_profile_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.bidding_group_complementary_grouping_profile_file","text":"bidding_group_complementary_grouping_profile_file(collections::AbstractCollections)\n\nGet the complementary_grouping_profile_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_complementary_grouping_profile_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.bidding_group_complementary_grouping_profile_file","text":"bidding_group_complementary_grouping_profile_file(bidding_group::AbstractCollection)\n\nGet the complementary_grouping_profile_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_complementary_grouping_profile_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.bidding_group_complementary_grouping_profile_file","text":"bidding_group_complementary_grouping_profile_file(inputs::AbstractInputs, i::Integer)\n\nGet the complementarygroupingprofile_file field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_complementary_grouping_profile_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.bidding_group_complementary_grouping_profile_file","text":"bidding_group_complementary_grouping_profile_file(inputs::AbstractInputs)\n\nGet the complementary_grouping_profile_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_energy_bid!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, IARA.SimulationResultsFromPeriodScenario, Int64, Int64, Int64, Type{IARA.WriteOutput}}","page":"API Reference","title":"IARA.bidding_group_energy_bid!","text":"bidding_group_energy_bid!(outputs, inputs::Inputs, run_time_options::RunTimeOptions, simulation_results::SimulationResultsFromPeriodScenario, period::Int, scenario::Int, subscenario::Int, ::Type{WriteOutput})\n\nWrite the bidding group energy bid variable values to the output.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_energy_bid!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.InitializeOutput}}","page":"API Reference","title":"IARA.bidding_group_energy_bid!","text":"bidding_group_energy_bid!(outputs::Outputs, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{InitializeOutput})\n\nInitialize the output file to store the bidding group energy bid variable values.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_energy_bid!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Int64, Int64, Int64, Int64, Type{IARA.SubproblemUpdate}}","page":"API Reference","title":"IARA.bidding_group_energy_bid!","text":"bidding_group_energy_bid!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemUpdate})\n\nUpdates the objective function coefficients for the bidding group energy bid variables.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_energy_bid!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.bidding_group_energy_bid!","text":"bidding_group_energy_bid!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the bidding group energy bid variables to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_ex_post_adjust_mode-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.bidding_group_ex_post_adjust_mode","text":"bidding_group_ex_post_adjust_mode(bidding_group::AbstractCollection, i::Integer)\n\nGet the expostadjust_mode field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_ex_post_adjust_mode-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.bidding_group_ex_post_adjust_mode","text":"bidding_group_ex_post_adjust_mode(collections::AbstractCollections, i::Integer)\n\nGet the expostadjust_mode field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_ex_post_adjust_mode-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.bidding_group_ex_post_adjust_mode","text":"bidding_group_ex_post_adjust_mode(collections::AbstractCollections)\n\nGet the ex_post_adjust_mode field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_ex_post_adjust_mode-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.bidding_group_ex_post_adjust_mode","text":"bidding_group_ex_post_adjust_mode(bidding_group::AbstractCollection)\n\nGet the ex_post_adjust_mode field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_ex_post_adjust_mode-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.bidding_group_ex_post_adjust_mode","text":"bidding_group_ex_post_adjust_mode(inputs::AbstractInputs, i::Integer)\n\nGet the expostadjust_mode field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_ex_post_adjust_mode-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.bidding_group_ex_post_adjust_mode","text":"bidding_group_ex_post_adjust_mode(inputs::AbstractInputs)\n\nGet the ex_post_adjust_mode field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_fixed_cost-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.bidding_group_fixed_cost","text":"bidding_group_fixed_cost(bidding_group::AbstractCollection, i::Integer)\n\nGet the fixed_cost field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_fixed_cost-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.bidding_group_fixed_cost","text":"bidding_group_fixed_cost(collections::AbstractCollections, i::Integer)\n\nGet the fixed_cost field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_fixed_cost-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.bidding_group_fixed_cost","text":"bidding_group_fixed_cost(collections::AbstractCollections)\n\nGet the fixed_cost field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_fixed_cost-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.bidding_group_fixed_cost","text":"bidding_group_fixed_cost(bidding_group::AbstractCollection)\n\nGet the fixed_cost field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_fixed_cost-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.bidding_group_fixed_cost","text":"bidding_group_fixed_cost(inputs::AbstractInputs, i::Integer)\n\nGet the fixed_cost field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_fixed_cost-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.bidding_group_fixed_cost","text":"bidding_group_fixed_cost(inputs::AbstractInputs)\n\nGet the fixed_cost field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_generation!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, IARA.SimulationResultsFromPeriodScenario, Int64, Int64, Int64, Type{IARA.WriteOutput}}","page":"API Reference","title":"IARA.bidding_group_generation!","text":"bidding_group_generation!(outputs, inputs::Inputs, run_time_options::RunTimeOptions, simulation_results::SimulationResultsFromPeriodScenario, period::Int, scenario::Int, subscenario::Int, ::Type{WriteOutput})\n\nWrite the bidding group generation variable values to the output.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_generation!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.InitializeOutput}}","page":"API Reference","title":"IARA.bidding_group_generation!","text":"bidding_group_generation!(outputs::Outputs, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{InitializeOutput})\n\nInitialize the output file to store the bidding group generation variable values.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_generation!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Int64, Int64, Int64, Int64, Type{IARA.SubproblemUpdate}}","page":"API Reference","title":"IARA.bidding_group_generation!","text":"bidding_group_generation!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, scenario, subscenario, ::Type{SubproblemUpdate})\n\nUpdates the objective function coefficients for the bidding group generation variables.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_generation!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.bidding_group_generation!","text":"bidding_group_generation!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the bidding group generation variables to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_generation_bound_by_bid!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.bidding_group_generation_bound_by_bid!","text":"bidding_group_generation_bound_by_bid!(\n    model,\n    inputs,\n    run_time_options,\n    ::Type{SubproblemBuild},\n)\n\nAdd the bidding group generation bound by bid constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_label-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.bidding_group_label","text":"bidding_group_label(bidding_group::AbstractCollection, i::Integer)\n\nGet the label field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_label-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.bidding_group_label","text":"bidding_group_label(collections::AbstractCollections, i::Integer)\n\nGet the label field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_label-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.bidding_group_label","text":"bidding_group_label(collections::AbstractCollections)\n\nGet the label field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_label-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.bidding_group_label","text":"bidding_group_label(bidding_group::AbstractCollection)\n\nGet the label field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_label-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.bidding_group_label","text":"bidding_group_label(inputs::AbstractInputs, i::Integer)\n\nGet the label field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_label-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.bidding_group_label","text":"bidding_group_label(inputs::AbstractInputs)\n\nGet the label field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_markup_bids_for_period_scenario-Tuple{IARA.Inputs, IARA.RunTimeOptions, Int64, Int64}","page":"API Reference","title":"IARA.bidding_group_markup_bids_for_period_scenario","text":"bidding_group_markup_bids_for_period_scenario(\n    inputs::Inputs, outputs::Outputs, \n    run_time_options::RunTimeOptions, \n    period::Int, \n    scenario::Int\n)\n\nGenerate heuristic bids for the bidding groups and write them to the output files.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_minimum_activation_level_profile_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.bidding_group_minimum_activation_level_profile_file","text":"bidding_group_minimum_activation_level_profile_file(bidding_group::AbstractCollection, i::Integer)\n\nGet the minimumactivationlevelprofilefile field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_minimum_activation_level_profile_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.bidding_group_minimum_activation_level_profile_file","text":"bidding_group_minimum_activation_level_profile_file(collections::AbstractCollections, i::Integer)\n\nGet the minimumactivationlevelprofilefile field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_minimum_activation_level_profile_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.bidding_group_minimum_activation_level_profile_file","text":"bidding_group_minimum_activation_level_profile_file(collections::AbstractCollections)\n\nGet the minimum_activation_level_profile_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_minimum_activation_level_profile_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.bidding_group_minimum_activation_level_profile_file","text":"bidding_group_minimum_activation_level_profile_file(bidding_group::AbstractCollection)\n\nGet the minimum_activation_level_profile_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_minimum_activation_level_profile_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.bidding_group_minimum_activation_level_profile_file","text":"bidding_group_minimum_activation_level_profile_file(inputs::AbstractInputs, i::Integer)\n\nGet the minimumactivationlevelprofilefile field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_minimum_activation_level_profile_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.bidding_group_minimum_activation_level_profile_file","text":"bidding_group_minimum_activation_level_profile_file(inputs::AbstractInputs)\n\nGet the minimum_activation_level_profile_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_parent_profile_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.bidding_group_parent_profile_file","text":"bidding_group_parent_profile_file(bidding_group::AbstractCollection, i::Integer)\n\nGet the parentprofilefile field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_parent_profile_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.bidding_group_parent_profile_file","text":"bidding_group_parent_profile_file(collections::AbstractCollections, i::Integer)\n\nGet the parentprofilefile field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_parent_profile_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.bidding_group_parent_profile_file","text":"bidding_group_parent_profile_file(collections::AbstractCollections)\n\nGet the parent_profile_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_parent_profile_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.bidding_group_parent_profile_file","text":"bidding_group_parent_profile_file(bidding_group::AbstractCollection)\n\nGet the parent_profile_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_parent_profile_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.bidding_group_parent_profile_file","text":"bidding_group_parent_profile_file(inputs::AbstractInputs, i::Integer)\n\nGet the parentprofilefile field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_parent_profile_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.bidding_group_parent_profile_file","text":"bidding_group_parent_profile_file(inputs::AbstractInputs)\n\nGet the parent_profile_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_price_bid_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.bidding_group_price_bid_file","text":"bidding_group_price_bid_file(bidding_group::AbstractCollection, i::Integer)\n\nGet the pricebidfile field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_price_bid_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.bidding_group_price_bid_file","text":"bidding_group_price_bid_file(collections::AbstractCollections, i::Integer)\n\nGet the pricebidfile field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_price_bid_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.bidding_group_price_bid_file","text":"bidding_group_price_bid_file(collections::AbstractCollections)\n\nGet the price_bid_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_price_bid_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.bidding_group_price_bid_file","text":"bidding_group_price_bid_file(bidding_group::AbstractCollection)\n\nGet the price_bid_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_price_bid_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.bidding_group_price_bid_file","text":"bidding_group_price_bid_file(inputs::AbstractInputs, i::Integer)\n\nGet the pricebidfile field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_price_bid_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.bidding_group_price_bid_file","text":"bidding_group_price_bid_file(inputs::AbstractInputs)\n\nGet the price_bid_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_price_bid_profile_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.bidding_group_price_bid_profile_file","text":"bidding_group_price_bid_profile_file(bidding_group::AbstractCollection, i::Integer)\n\nGet the pricebidprofile_file field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_price_bid_profile_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.bidding_group_price_bid_profile_file","text":"bidding_group_price_bid_profile_file(collections::AbstractCollections, i::Integer)\n\nGet the pricebidprofile_file field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_price_bid_profile_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.bidding_group_price_bid_profile_file","text":"bidding_group_price_bid_profile_file(collections::AbstractCollections)\n\nGet the price_bid_profile_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_price_bid_profile_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.bidding_group_price_bid_profile_file","text":"bidding_group_price_bid_profile_file(bidding_group::AbstractCollection)\n\nGet the price_bid_profile_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_price_bid_profile_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.bidding_group_price_bid_profile_file","text":"bidding_group_price_bid_profile_file(inputs::AbstractInputs, i::Integer)\n\nGet the pricebidprofile_file field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_price_bid_profile_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.bidding_group_price_bid_profile_file","text":"bidding_group_price_bid_profile_file(inputs::AbstractInputs)\n\nGet the price_bid_profile_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_profile_complementary_profile!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.bidding_group_profile_complementary_profile!","text":"bidding_group_profile_complementary_profile!(\n    model,\n    inputs,\n    run_time_options,\n    ::Type{SubproblemBuild},\n)\n\nAdd the bidding group profile complementary profile constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_profile_energy_bid!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, IARA.SimulationResultsFromPeriodScenario, Int64, Int64, Int64, Type{IARA.WriteOutput}}","page":"API Reference","title":"IARA.bidding_group_profile_energy_bid!","text":"bidding_group_profile_energy_bid!(outputs, inputs::Inputs, run_time_options::RunTimeOptions, simulation_results::SimulationResultsFromPeriodScenario, period::Int, scenario::Int, subscenario::Int, ::Type{WriteOutput})\n\nWrite the bidding group profile energy bid variables' values to the output.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_profile_energy_bid!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.InitializeOutput}}","page":"API Reference","title":"IARA.bidding_group_profile_energy_bid!","text":"bidding_group_profile_energy_bid!(outputs::Outputs, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{InitializeOutput})\n\nInitialize the output file to store the bidding group profile energy bid variable values.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_profile_energy_bid!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Int64, Int64, Int64, Int64, Type{IARA.SubproblemUpdate}}","page":"API Reference","title":"IARA.bidding_group_profile_energy_bid!","text":"bidding_group_profile_energy_bid!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemUpdate})\n\nUpdates the objective function coefficients for the bidding group profile energy bid variables.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_profile_energy_bid!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.bidding_group_profile_energy_bid!","text":"bidding_group_profile_energy_bid!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the bidding group profile energy bid variables to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_profile_generation_bound_by_bid!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.bidding_group_profile_generation_bound_by_bid!","text":"bidding_group_profile_generation_bound_by_bid!(\n    model,\n    inputs,\n    run_time_options,\n    ::Type{SubproblemBuild},\n)\n\nAdd the bidding group profile generation bound by bid constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_profile_minimum_activation!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.bidding_group_profile_minimum_activation!","text":"bidding_group_profile_minimum_activation!(\n    model,\n    inputs,\n    run_time_options,\n    ::Type{SubproblemBuild},\n)\n\nAdd the bidding group profile minimum activation constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_profile_precedence!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.bidding_group_profile_precedence!","text":"bidding_group_profile_precedence!(\n    model,\n    inputs,\n    run_time_options,\n    ::Type{SubproblemBuild},\n)\n\nAdd the bidding group profile precedence constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_quantity_bid_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.bidding_group_quantity_bid_file","text":"bidding_group_quantity_bid_file(bidding_group::AbstractCollection, i::Integer)\n\nGet the quantitybidfile field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_quantity_bid_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.bidding_group_quantity_bid_file","text":"bidding_group_quantity_bid_file(collections::AbstractCollections, i::Integer)\n\nGet the quantitybidfile field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_quantity_bid_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.bidding_group_quantity_bid_file","text":"bidding_group_quantity_bid_file(collections::AbstractCollections)\n\nGet the quantity_bid_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_quantity_bid_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.bidding_group_quantity_bid_file","text":"bidding_group_quantity_bid_file(bidding_group::AbstractCollection)\n\nGet the quantity_bid_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_quantity_bid_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.bidding_group_quantity_bid_file","text":"bidding_group_quantity_bid_file(inputs::AbstractInputs, i::Integer)\n\nGet the quantitybidfile field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_quantity_bid_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.bidding_group_quantity_bid_file","text":"bidding_group_quantity_bid_file(inputs::AbstractInputs)\n\nGet the quantity_bid_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_quantity_bid_profile_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.bidding_group_quantity_bid_profile_file","text":"bidding_group_quantity_bid_profile_file(bidding_group::AbstractCollection, i::Integer)\n\nGet the quantitybidprofile_file field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_quantity_bid_profile_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.bidding_group_quantity_bid_profile_file","text":"bidding_group_quantity_bid_profile_file(collections::AbstractCollections, i::Integer)\n\nGet the quantitybidprofile_file field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_quantity_bid_profile_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.bidding_group_quantity_bid_profile_file","text":"bidding_group_quantity_bid_profile_file(collections::AbstractCollections)\n\nGet the quantity_bid_profile_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_quantity_bid_profile_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.bidding_group_quantity_bid_profile_file","text":"bidding_group_quantity_bid_profile_file(bidding_group::AbstractCollection)\n\nGet the quantity_bid_profile_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_quantity_bid_profile_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.bidding_group_quantity_bid_profile_file","text":"bidding_group_quantity_bid_profile_file(inputs::AbstractInputs, i::Integer)\n\nGet the quantitybidprofile_file field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_quantity_bid_profile_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.bidding_group_quantity_bid_profile_file","text":"bidding_group_quantity_bid_profile_file(inputs::AbstractInputs)\n\nGet the quantity_bid_profile_file field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_risk_factor-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.bidding_group_risk_factor","text":"bidding_group_risk_factor(bidding_group::AbstractCollection, i::Integer)\n\nGet the risk_factor field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_risk_factor-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.bidding_group_risk_factor","text":"bidding_group_risk_factor(collections::AbstractCollections, i::Integer)\n\nGet the risk_factor field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_risk_factor-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.bidding_group_risk_factor","text":"bidding_group_risk_factor(collections::AbstractCollections)\n\nGet the risk_factor field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_risk_factor-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.bidding_group_risk_factor","text":"bidding_group_risk_factor(bidding_group::AbstractCollection)\n\nGet the risk_factor field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_risk_factor-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.bidding_group_risk_factor","text":"bidding_group_risk_factor(inputs::AbstractInputs, i::Integer)\n\nGet the risk_factor field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_risk_factor-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.bidding_group_risk_factor","text":"bidding_group_risk_factor(inputs::AbstractInputs)\n\nGet the risk_factor field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_segment_fraction-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.bidding_group_segment_fraction","text":"bidding_group_segment_fraction(bidding_group::AbstractCollection, i::Integer)\n\nGet the segment_fraction field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_segment_fraction-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.bidding_group_segment_fraction","text":"bidding_group_segment_fraction(collections::AbstractCollections, i::Integer)\n\nGet the segment_fraction field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_segment_fraction-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.bidding_group_segment_fraction","text":"bidding_group_segment_fraction(collections::AbstractCollections)\n\nGet the segment_fraction field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_segment_fraction-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.bidding_group_segment_fraction","text":"bidding_group_segment_fraction(bidding_group::AbstractCollection)\n\nGet the segment_fraction field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_segment_fraction-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.bidding_group_segment_fraction","text":"bidding_group_segment_fraction(inputs::AbstractInputs, i::Integer)\n\nGet the segment_fraction field from the BiddingGroup collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bidding_group_segment_fraction-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.bidding_group_segment_fraction","text":"bidding_group_segment_fraction(inputs::AbstractInputs)\n\nGet the segment_fraction field from the BiddingGroup collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_bus_from-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.branch_bus_from","text":"branch_bus_from(branch::AbstractCollection, i::Integer)\n\nGet the bus_from field from the Branch collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_bus_from-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.branch_bus_from","text":"branch_bus_from(collections::AbstractCollections, i::Integer)\n\nGet the bus_from field from the Branch collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_bus_from-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.branch_bus_from","text":"branch_bus_from(collections::AbstractCollections)\n\nGet the bus_from field from the Branch collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_bus_from-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.branch_bus_from","text":"branch_bus_from(branch::AbstractCollection)\n\nGet the bus_from field from the Branch collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_bus_from-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.branch_bus_from","text":"branch_bus_from(inputs::AbstractInputs, i::Integer)\n\nGet the bus_from field from the Branch collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_bus_from-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.branch_bus_from","text":"branch_bus_from(inputs::AbstractInputs)\n\nGet the bus_from field from the Branch collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_bus_to-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.branch_bus_to","text":"branch_bus_to(branch::AbstractCollection, i::Integer)\n\nGet the bus_to field from the Branch collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_bus_to-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.branch_bus_to","text":"branch_bus_to(collections::AbstractCollections, i::Integer)\n\nGet the bus_to field from the Branch collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_bus_to-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.branch_bus_to","text":"branch_bus_to(collections::AbstractCollections)\n\nGet the bus_to field from the Branch collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_bus_to-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.branch_bus_to","text":"branch_bus_to(branch::AbstractCollection)\n\nGet the bus_to field from the Branch collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_bus_to-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.branch_bus_to","text":"branch_bus_to(inputs::AbstractInputs, i::Integer)\n\nGet the bus_to field from the Branch collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_bus_to-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.branch_bus_to","text":"branch_bus_to(inputs::AbstractInputs)\n\nGet the bus_to field from the Branch collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_capacity-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.branch_capacity","text":"branch_capacity(branch::AbstractCollection, i::Integer)\n\nGet the capacity field from the Branch collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_capacity-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.branch_capacity","text":"branch_capacity(collections::AbstractCollections, i::Integer)\n\nGet the capacity field from the Branch collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_capacity-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.branch_capacity","text":"branch_capacity(collections::AbstractCollections)\n\nGet the capacity field from the Branch collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_capacity-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.branch_capacity","text":"branch_capacity(branch::AbstractCollection)\n\nGet the capacity field from the Branch collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_capacity-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.branch_capacity","text":"branch_capacity(inputs::AbstractInputs, i::Integer)\n\nGet the capacity field from the Branch collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_capacity-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.branch_capacity","text":"branch_capacity(inputs::AbstractInputs)\n\nGet the capacity field from the Branch collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_existing-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.branch_existing","text":"branch_existing(branch::AbstractCollection, i::Integer)\n\nGet the existing field from the Branch collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_existing-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.branch_existing","text":"branch_existing(collections::AbstractCollections, i::Integer)\n\nGet the existing field from the Branch collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_existing-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.branch_existing","text":"branch_existing(collections::AbstractCollections)\n\nGet the existing field from the Branch collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_existing-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.branch_existing","text":"branch_existing(branch::AbstractCollection)\n\nGet the existing field from the Branch collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_existing-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.branch_existing","text":"branch_existing(inputs::AbstractInputs, i::Integer)\n\nGet the existing field from the Branch collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_existing-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.branch_existing","text":"branch_existing(inputs::AbstractInputs)\n\nGet the existing field from the Branch collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_flow!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, IARA.SimulationResultsFromPeriodScenario, Int64, Int64, Int64, Type{IARA.WriteOutput}}","page":"API Reference","title":"IARA.branch_flow!","text":"branch_flow!(outputs, inputs::Inputs, run_time_options::RunTimeOptions, simulation_results::SimulationResultsFromPeriodScenario, period::Int, scenario::Int, subscenario::Int, ::Type{WriteOutput})\n\nWrite the branch flow variables' values to the output file.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_flow!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.InitializeOutput}}","page":"API Reference","title":"IARA.branch_flow!","text":"branch_flow!(outputs::Outputs, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{InitializeOutput})\n\nInitialize the output file to store the branch flow variables' values.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_flow!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.branch_flow!","text":"branch_flow!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the branch flow variables to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_label-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.branch_label","text":"branch_label(branch::AbstractCollection, i::Integer)\n\nGet the label field from the Branch collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_label-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.branch_label","text":"branch_label(collections::AbstractCollections, i::Integer)\n\nGet the label field from the Branch collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_label-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.branch_label","text":"branch_label(collections::AbstractCollections)\n\nGet the label field from the Branch collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_label-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.branch_label","text":"branch_label(branch::AbstractCollection)\n\nGet the label field from the Branch collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_label-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.branch_label","text":"branch_label(inputs::AbstractInputs, i::Integer)\n\nGet the label field from the Branch collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_label-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.branch_label","text":"branch_label(inputs::AbstractInputs)\n\nGet the label field from the Branch collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_line_model-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.branch_line_model","text":"branch_line_model(branch::AbstractCollection, i::Integer)\n\nGet the line_model field from the Branch collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_line_model-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.branch_line_model","text":"branch_line_model(collections::AbstractCollections, i::Integer)\n\nGet the line_model field from the Branch collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_line_model-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.branch_line_model","text":"branch_line_model(collections::AbstractCollections)\n\nGet the line_model field from the Branch collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_line_model-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.branch_line_model","text":"branch_line_model(branch::AbstractCollection)\n\nGet the line_model field from the Branch collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_line_model-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.branch_line_model","text":"branch_line_model(inputs::AbstractInputs, i::Integer)\n\nGet the line_model field from the Branch collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_line_model-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.branch_line_model","text":"branch_line_model(inputs::AbstractInputs)\n\nGet the line_model field from the Branch collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_reactance-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.branch_reactance","text":"branch_reactance(branch::AbstractCollection, i::Integer)\n\nGet the reactance field from the Branch collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_reactance-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.branch_reactance","text":"branch_reactance(collections::AbstractCollections, i::Integer)\n\nGet the reactance field from the Branch collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_reactance-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.branch_reactance","text":"branch_reactance(collections::AbstractCollections)\n\nGet the reactance field from the Branch collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_reactance-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.branch_reactance","text":"branch_reactance(branch::AbstractCollection)\n\nGet the reactance field from the Branch collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_reactance-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.branch_reactance","text":"branch_reactance(inputs::AbstractInputs, i::Integer)\n\nGet the reactance field from the Branch collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.branch_reactance-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.branch_reactance","text":"branch_reactance(inputs::AbstractInputs)\n\nGet the reactance field from the Branch collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.build_clearing_outputs-Tuple{IARA.Inputs}","page":"API Reference","title":"IARA.build_clearing_outputs","text":"build_clearing_outputs(inputs::Inputs)\n\nBuild the outputs for the clearing subproblem.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.build_demand_bids!-Tuple{IARA.Inputs, Int64, Array{Float64, 4}, Array{Float64, 4}, Array{Float64, 4}, Vector{Vector{Int64}}, Int64, Vector{Int64}, Matrix{Float64}}","page":"API Reference","title":"IARA.build_demand_bids!","text":"build_demand_bids!(\n    inputs::Inputs, \n    bg_index::Int, \n    quantity_bids::Array{Float64, 4},\n    price_bids::Array{Float64, 4},\n    no_markup_price_bids::Array{Float64, 4},\n    demand_unit_indexes_per_bus::Vector{Vector{Int}},\n    number_of_risk_factors::Int,\n    segment_offset_per_bus::Vector{Int},\n)\n\nBuild the quantity and price bids for demand units associated with a bidding group.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.build_graph-Tuple{IARA.Inputs}","page":"API Reference","title":"IARA.build_graph","text":"build_graph(inputs::Inputs)\n\nBuilds a graph based on the inputs.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.build_hydro_bids!-Tuple{IARA.Inputs, Int64, Array{Float64, 4}, Array{Float64, 4}, Array{Float64, 4}, Vector{Vector{Int64}}, Int64, Vector{Int64}, Union{Nothing, Vector{Float64}}}","page":"API Reference","title":"IARA.build_hydro_bids!","text":"build_hydro_bids!(\n    inputs::Inputs, \n    bg_index::Int, \n    hydro_unit_indexes::Vector{Int}, \n    number_of_risk_factors::Int, \n    available_energy::Union{Vector{Float64}, Nothing}\n)\n\nBuild the quantity and price bids for hydro units associated with a bidding group.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.build_plot_output-Tuple{IARA.Inputs, String, String, String, IARA.PlotConfig}","page":"API Reference","title":"IARA.build_plot_output","text":"build_plot_output(inputs::Inputs, plots_path::String, outputs_path::String, plot_config::PlotConfig)\n\nBuild the plot output for a specific plot configuration.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.build_plots-Tuple{IARA.Inputs}","page":"API Reference","title":"IARA.build_plots","text":"build_plots(inputs::Inputs)\n\nBuild plots for the outputs of the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.build_renewable_bids!-Tuple{IARA.Inputs, Int64, Array{Float64, 4}, Array{Float64, 4}, Array{Float64, 4}, Vector{Vector{Int64}}, Int64, Vector{Int64}, Matrix{Float64}}","page":"API Reference","title":"IARA.build_renewable_bids!","text":"build_renewable_bids(\n    inputs::Inputs, \n    bg_index::Int, \n    renewable_unit_indexes::Vector{Int}, \n    number_of_risk_factors::Int\n)\n\nBuild the quantity and price bids for renewable units associated with a bidding group.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.build_sql_typed_kwargs-Tuple{Any}","page":"API Reference","title":"IARA.build_sql_typed_kwargs","text":"build_sql_typed_kwargs(kwargs::Dict{Symbol, T}) where T\n\nConverts Enum values in the kwargs to their corresponding Int values for SQL purposes, keeping other values unchanged.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.build_subproblem_model-Tuple{IARA.Inputs, IARA.RunTimeOptions, Int64}","page":"API Reference","title":"IARA.build_subproblem_model","text":"build_subproblem_model(\n    inputs::Inputs,\n    run_time_options::RunTimeOptions,\n    period::Int;\n    jump_model = JuMP.Model(),\n)\n\nBuild the subproblem model for the given period.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.build_thermal_bids!-Tuple{IARA.Inputs, Int64, Array{Float64, 4}, Array{Float64, 4}, Array{Float64, 4}, Vector{Vector{Int64}}, Int64, Vector{Int64}}","page":"API Reference","title":"IARA.build_thermal_bids!","text":"build_thermal_bids(\n    inputs::Inputs, \n    bg_index::Int, \n    thermal_unit_indexes::Vector{Int}, \n    number_of_risk_factors::Int\n)\n\nBuild the quantity and price bids for thermal units associated with a bidding group.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_label-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.bus_label","text":"bus_label(bus::AbstractCollection, i::Integer)\n\nGet the label field from the Bus collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_label-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.bus_label","text":"bus_label(collections::AbstractCollections, i::Integer)\n\nGet the label field from the Bus collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_label-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.bus_label","text":"bus_label(collections::AbstractCollections)\n\nGet the label field from the Bus collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_label-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.bus_label","text":"bus_label(bus::AbstractCollection)\n\nGet the label field from the Bus collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_label-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.bus_label","text":"bus_label(inputs::AbstractInputs, i::Integer)\n\nGet the label field from the Bus collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_label-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.bus_label","text":"bus_label(inputs::AbstractInputs)\n\nGet the label field from the Bus collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_latitude-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.bus_latitude","text":"bus_latitude(bus::AbstractCollection, i::Integer)\n\nGet the latitude field from the Bus collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_latitude-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.bus_latitude","text":"bus_latitude(collections::AbstractCollections, i::Integer)\n\nGet the latitude field from the Bus collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_latitude-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.bus_latitude","text":"bus_latitude(collections::AbstractCollections)\n\nGet the latitude field from the Bus collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_latitude-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.bus_latitude","text":"bus_latitude(bus::AbstractCollection)\n\nGet the latitude field from the Bus collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_latitude-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.bus_latitude","text":"bus_latitude(inputs::AbstractInputs, i::Integer)\n\nGet the latitude field from the Bus collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_latitude-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.bus_latitude","text":"bus_latitude(inputs::AbstractInputs)\n\nGet the latitude field from the Bus collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_longitude-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.bus_longitude","text":"bus_longitude(bus::AbstractCollection, i::Integer)\n\nGet the longitude field from the Bus collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_longitude-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.bus_longitude","text":"bus_longitude(collections::AbstractCollections, i::Integer)\n\nGet the longitude field from the Bus collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_longitude-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.bus_longitude","text":"bus_longitude(collections::AbstractCollections)\n\nGet the longitude field from the Bus collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_longitude-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.bus_longitude","text":"bus_longitude(bus::AbstractCollection)\n\nGet the longitude field from the Bus collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_longitude-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.bus_longitude","text":"bus_longitude(inputs::AbstractInputs, i::Integer)\n\nGet the longitude field from the Bus collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_longitude-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.bus_longitude","text":"bus_longitude(inputs::AbstractInputs)\n\nGet the longitude field from the Bus collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_voltage_angle!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, IARA.SimulationResultsFromPeriodScenario, Int64, Int64, Int64, Type{IARA.WriteOutput}}","page":"API Reference","title":"IARA.bus_voltage_angle!","text":"bus_voltage_angle!(outputs, inputs::Inputs, run_time_options::RunTimeOptions, simulation_results::SimulationResultsFromPeriodScenario, period::Int, scenario::Int, subscenario::Int, ::Type{WriteOutput})\n\nWrite the bus voltage angle variables' values to the output file.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_voltage_angle!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.InitializeOutput}}","page":"API Reference","title":"IARA.bus_voltage_angle!","text":"bus_voltage_angle!(outputs::Outputs, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{InitializeOutput})\n\nInitialize the output file to store the bus voltage angle variables' values.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_voltage_angle!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.bus_voltage_angle!","text":"bus_voltage_angle!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the bus voltage angle variables to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_zone_index-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.bus_zone_index","text":"bus_zone_index(bus::AbstractCollection, i::Integer)\n\nGet the zone_index field from the Bus collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_zone_index-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.bus_zone_index","text":"bus_zone_index(collections::AbstractCollections, i::Integer)\n\nGet the zone_index field from the Bus collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_zone_index-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.bus_zone_index","text":"bus_zone_index(collections::AbstractCollections)\n\nGet the zone_index field from the Bus collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_zone_index-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.bus_zone_index","text":"bus_zone_index(bus::AbstractCollection)\n\nGet the zone_index field from the Bus collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_zone_index-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.bus_zone_index","text":"bus_zone_index(inputs::AbstractInputs, i::Integer)\n\nGet the zone_index field from the Bus collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.bus_zone_index-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.bus_zone_index","text":"bus_zone_index(inputs::AbstractInputs)\n\nGet the zone_index field from the Bus collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.buses_represented_for_strategic_bidding-Tuple{Any}","page":"API Reference","title":"IARA.buses_represented_for_strategic_bidding","text":"buses_represented_for_strategic_bidding(inputs::Inputs)\n\nIf the 'iterationwithaggregate_buses' attribute is set to AGGREGATE, return [1]. Otherwise, return the index of all Buses.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.calculate_incremental_inflow-Tuple{IARA.Inputs, Vector{Vector{Float64}}}","page":"API Reference","title":"IARA.calculate_incremental_inflow","text":"calculate_incremental_inflow(inputs::Inputs, total_inflow::Vector{Vector{Float64}})\n\nCalculate incremental inflow from total inflow.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.calculate_profits_settlement-Tuple{IARA.Inputs, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.calculate_profits_settlement","text":"calculate_profits_settlement(inputs, run_time_options)\n\nCalculate the profits of the bidding groups for the different settlement types.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.clearing_has_parp_variables-Tuple{IARA.Inputs, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.clearing_has_parp_variables","text":"clearing_has_parp_variables(inputs::Inputs, run_time_options::RunTimeOptions)\n\nCheck if the clearing has PAR(p) normalized inflow state variables.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.clearing_has_physical_variables-Tuple{IARA.Inputs, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.clearing_has_physical_variables","text":"clearing_has_physical_variables(inputs::Inputs)\n\nCheck if the market clearing has physical variables in at least one of its problems.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.clearing_has_state_variables-Tuple{IARA.Inputs, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.clearing_has_state_variables","text":"clearing_has_state_variables(inputs::Inputs, run_time_options::RunTimeOptions)\n\nCheck if the clearing has any representation that requires state variables.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.clearing_has_volume_variables-Tuple{IARA.Inputs, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.clearing_has_volume_variables","text":"clearing_has_volume_variables(inputs::Inputs, run_time_options::RunTimeOptions)\n\nCheck if the clearing has volume variables.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.close_study!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite}","page":"API Reference","title":"IARA.close_study!","text":"close_study!(db::DatabaseSQLite)\n\nCloses the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.constraint_dual_recorder-Tuple{IARA.Inputs, Symbol}","page":"API Reference","title":"IARA.constraint_dual_recorder","text":"constraint_dual_recorder(constraint_name::Symbol)\n\nReturn a function that retrieves the dual value of a constraint with the provided name.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.construction_type-Tuple{IARA.Inputs, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.construction_type","text":"construction_type(inputs::Inputs, run_time_options::RunTimeOptions)\n\nDetermine the clearing model type.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.construction_type_ex_ante_commercial-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.construction_type_ex_ante_commercial","text":"construction_type_ex_ante_commercial(inputs::AbstractInputs)\n\nReturn the ex-ante commercial clearing model type.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.construction_type_ex_ante_physical-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.construction_type_ex_ante_physical","text":"construction_type_ex_ante_physical(inputs::AbstractInputs)\n\nReturn the ex-ante physical clearing model type.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.construction_type_ex_post_commercial-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.construction_type_ex_post_commercial","text":"construction_type_ex_post_commercial(inputs::AbstractInputs)\n\nReturn the ex-post commercial clearing model type.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.construction_type_ex_post_physical-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.construction_type_ex_post_physical","text":"construction_type_ex_post_physical(inputs::AbstractInputs)\n\nReturn the ex-post physical clearing model type.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.convex_hull_coefficients!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Int64, Int64, Int64, Int64, Type{IARA.SubproblemUpdate}}","page":"API Reference","title":"IARA.convex_hull_coefficients!","text":"convex_hull_coefficients!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemUpdate})\n\nUpdates the objective function coefficients for the convex hull coefficients variables.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.convex_hull_coefficients!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.convex_hull_coefficients!","text":"convex_hull_coefficients!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the convex hull coefficients variables to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.cost_based_market_clearing_model_action-Tuple","page":"API Reference","title":"IARA.cost_based_market_clearing_model_action","text":"cost_based_market_clearing_model_action(args...)\n\nCost based market clearing model action.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.create_bidding_group_cost_files-Tuple{IARA.Inputs, IARA.Outputs, IARA.OutputReaders, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.create_bidding_group_cost_files","text":"create_bidding_group_cost_files(inputs::Inputs, outputs_post_processing::Outputs, model_outputs_time_serie::OutputReaders, run_time_options::RunTimeOptions)\n\nCreate the bidding group cost files for ex-ante and ex-post data (physical and commercial).\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.create_bidding_group_generation_files-Tuple{IARA.Inputs, IARA.Outputs, IARA.OutputReaders, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.create_bidding_group_generation_files","text":"create_bidding_group_generation_files(inputs::Inputs, outputs_post_processing::Outputs, model_outputs_time_serie::OutputReaders, run_time_options::RunTimeOptions)\n\nCreate the bidding group generation files for ex-ante and ex-post data (physical and commercial).\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.create_study!-Tuple{String}","page":"API Reference","title":"IARA.create_study!","text":"create_study!(\n    case_path::String; \n    kwargs...\n)\n\ncreate_study! creates a new study and returns a PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite object.\n\nRequired arguments:\n\nlabel::String: Label of the configuration <default \"Configuration\"> \nnumber_of_subscenarios::Int64: Number of subscenarios in the configuration <default 1> \ninitial_date_time::String: Initial date time of the configuration [yyyy-MM-dd HH:mm] <default \"2024-01-01\"> \ntime_series_step::Int64: Time series step of the configuration <default 0> \ncycle_discount_rate::Float64: Cycle discount rate of the configuration\n\ncycle_duration_in_hours::Float64: Cycle duration in hours of the configuration <default 8760.0> \nex_post_physical_hydro_representation::Int64: Ex post physical hydro representation of the configuration <default 0> \nclearing_integer_variables::Int64: Clearing integer variables of the configuration <default 0> \nsettlement_type::Int64: Settlement type of the configuration <default 0> \nmake_whole_payments::Int64: Make whole payments of the configuration <default 0> \nnumber_of_periods::Int64: Number of periods in the configuration <default 1> \nnumber_of_scenarios::Int64: Number of scenarios in the configuration <default 1> \nnumber_of_subperiods::Int64: Number of subperiods in the configuration <default 1> \ndemand_deficit_cost::Float64: Demand deficit cost of the configuration <default 1.0e6> \npolicy_graph_type::Int64: Policy graph type of the configuration\n0 [Cyclic With Null Root] <default> \n1 [Linear]\n2 [Cyclic With Season Root]\n\nmarket_clearing_tiebreaker_weight_for_om_costs::Float64: Market clearing tiebreaker weight of the configuration <default 0.001> \nbid_price_limit_markup_non_justified_profile::Float64\n\nbid_price_limit_markup_justified_profile::Float64\n\nbid_price_limit_markup_non_justified_independent::Float64\n\nbid_price_limit_markup_justified_independent::Float64\n\nbid_price_limit_high_reference::Float64\n\nreference_curve_number_of_segments::Int64\n\nreference_curve_final_segment_price_markup::Float64\n\nmax_iteration_nash_equilibrium::Int64\n\nbid_price_validation::Int64\n\nbid_processing::Int64\n\nmax_rev_equilibrium_bus_aggregation_type::Int64\n\nmax_rev_equilibrium_bid_initialization::Int64\n\ninflow_model::Int64\n\ninflow_scenarios_files::Int64: Inflow scenarios files of the configuration\n0 [PAR(p)]\n1 [Only Ex Ante]\n2 [Only Ex Post] <default> \n3 [Ex Ante And Ex Post]\n\ndemand_scenarios_files::Int64: Demand scenarios files of the configuration\n0 [PAR(p)]\n1 [Only Ex Ante]\n2 [Only Ex Post] <default> \n3 [Ex Ante And Ex Post]\n\nrenewable_scenarios_files::Int64: Renewable scenarios files of the configuration\n0 [PAR(p)]\n1 [Only Ex Ante]\n2 [Only Ex Post] <default> \n3 [Ex Ante And Ex Post]\n\nmarket_clearing_tiebreaker_weight_for_fcf::Float64\n\nvirtual_reservoir_residual_revenue_split_type::Int64\n\nOptional arguments:\n\nnumber_of_nodes::Int64: Number of nodes in the configuration\n\ntrain_mincost_iteration_limit::Int64\n\nhydro_balance_subperiod_resolution::Int64: Hydro balance subperiod resolution of the configuration <default 0> \nthermal_unit_intra_period_operation::Int64: Loop subperiods for thermal constraints of the configuration\n\naggregate_buses_for_strategic_bidding::Int64: Aggregate buses for strategic bidding of the configuration\n\nparp_max_lags::Int64: PARP max lags of the configuration <default 6> \nconstruction_type_ex_ante_physical::Int64: Construction type ex ante physical of the configuration <default -1> \nconstruction_type_ex_ante_commercial::Int64: Construction type ex ante commercial of the configuration <default -1> \nconstruction_type_ex_post_physical::Int64: Construction type ex post physical of the configuration <default -1> \nconstruction_type_ex_post_commercial::Int64: Construction type ex post commercial of the configuration <default -1> \ninteger_variable_representation_ex_ante_physical::Int64: Integer variable representation ex ante physical of the configuration <default 0> \ninteger_variable_representation_ex_ante_commercial::Int64: Integer variable representation ex ante commercial of the configuration <default 0> \ninteger_variable_representation_ex_post_physical::Int64: Integer variable representation ex post physical of the configuration <default 0> \ninteger_variable_representation_ex_post_commercial::Int64: Integer variable representation ex post commercial of the configuration <default 0> \nspot_price_floor::Float64: Spot price floor of the configuration\n\nspot_price_cap::Float64: Spot price cap of the configuration\n\nvirtual_reservoir_correspondence_type::Int64: Virtual reservoir correspondence type of the configuration <default 1> \ninteger_variable_representation_mincost::Int64: Integer variable representation min cost of the configuration <default 0> \nnetwork_representation_mincost::Int64: Network representation min cost of the configuration <default 0> \nnetwork_representation_ex_ante_physical::Int64: Network representation ex ante physical of the configuration\n0 [Nodal] <default> \n1 [Zonal]\n\nnetwork_representation_ex_ante_commercial::Int64: Network representation ex ante commercial of the configuration\n0 [Nodal] <default> \n1 [Zonal]\n\nnetwork_representation_ex_post_physical::Int64: Network representation ex post physical of the configuration\n0 [Nodal] <default> \n1 [Zonal]\n\nnetwork_representation_ex_post_commercial::Int64: Network representation ex post commercial of the configuration\n0 [Nodal] <default> \n1 [Zonal]\n\nlanguage::String\n\ntrain_mincost_time_limit_sec::Int64\n\nbid_price_limit_low_reference::Float64\n\nsupply_function_equilibrium_extra_bid_quantity::Float64\n\nsupply_function_equilibrium_tolerance::Float64\n\nsupply_function_equilibrium_max_iterations::Int64\n\nsupply_function_equilibrium_max_cost_multiplier::Float64\n\nsubperiod_duration_in_hours::Vector{Float64}: Subperiod duration in hours of the configuration\n\nexpected_number_of_repeats_per_node::Vector{Float64}:\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.custom_plot-Tuple{PlotlyLight.Plot, PlotlyLight.Plot}","page":"API Reference","title":"IARA.custom_plot","text":"IARA.custom_plot(plot_a::Plot, plot_b::Plot; title::String = \"Plot\")\n\nCreate a customized plot from two plots.\n\nIt requires a vector of plots that you have already created with IARA.custom_plot.\nThe x-axis of the two plots must be the same.\n\nExample:\n\npath_1 = \"path/to/file.csv\"\npath_2 = \"path/to/another_file.csv\"\n\n\nplot_1 = IARA.custom_plot(path_1, IARA.PlotTimeSeriesQuantiles; subperiod = 1:10, agents=[\"hydro\"])\nplot_2 = IARA.custom_plot(path_2, IARA.PlotTimeSeriesQuantiles; subperiod = 1:10, agents=[\"thermal\"])\n\nIARA.custom_plot(plot_1, plot_2; title = \"Custom Plot\")\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.custom_plot-Tuple{String, Type{<:IARA.PlotType}}","page":"API Reference","title":"IARA.custom_plot","text":"custom_plot(\n    filepath::String, \n    plot_type::Type{<:PlotType}; \n    plot_path::String = \"\",\n    agents::Vector{String} = Vector{String}(), \n    title::String = \"Plot\", \n    kwargs...\n)\n\nCreate a customized plot from a time series file.\n\nIt requires a plot type [PlotType] and a file path to a time series file. \nThe plot_path argument is used to set the path where the plot will be saved. If it is not provided, the plot will not be saved.\nThe agents argument is used to filter the agents to be plotted. If it is not provided, all agents will be plotted.\nThe title argument is used to set the title of the plot, which is \"Plot\" by default.\nThe kwargs arguments are used to filter the time series by its dimensions.\n\nExample:\n\npath = \"path/to/file.csv\"\nIARA.custom_plot(path, PlotTimeSeriesQuantiles; subperiod = 1:10, agents=[\"hydro\"])\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.cycle_discount_rate-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.cycle_discount_rate","text":"cycle_discount_rate(inputs::AbstractInputs)\n\nReturn the cycle discount rate.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.cycle_duration_in_hours-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.cycle_duration_in_hours","text":"cycle_duration_in_hours(inputs::AbstractInputs)\n\nReturn the cycle duration in hours.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.cyclic_policy_graph-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.cyclic_policy_graph","text":"cyclic_policy_graph(inputs::AbstractInputs)\n\nReturn whether the policy graph is cyclic.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_flow!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, IARA.SimulationResultsFromPeriodScenario, Int64, Int64, Int64, Type{IARA.WriteOutput}}","page":"API Reference","title":"IARA.dc_flow!","text":"dc_flow!(outputs, inputs::Inputs, run_time_options::RunTimeOptions, simulation_results::SimulationResultsFromPeriodScenario, period::Int, scenario::Int, subscenario::Int, ::Type{WriteOutput})\n\nWrite the DC flow variables' values to the output file.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_flow!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.InitializeOutput}}","page":"API Reference","title":"IARA.dc_flow!","text":"dc_flow!(outputs::Outputs, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{InitializeOutput})\n\nInitialize output file to store the DC flow variables' values.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_flow!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.dc_flow!","text":"dc_flow!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the DC flow variables to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_bus_from-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.dc_line_bus_from","text":"dc_line_bus_from(dc_line::AbstractCollection, i::Integer)\n\nGet the bus_from field from the DCLine collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_bus_from-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.dc_line_bus_from","text":"dc_line_bus_from(collections::AbstractCollections, i::Integer)\n\nGet the bus_from field from the DCLine collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_bus_from-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.dc_line_bus_from","text":"dc_line_bus_from(collections::AbstractCollections)\n\nGet the bus_from field from the DCLine collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_bus_from-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.dc_line_bus_from","text":"dc_line_bus_from(dc_line::AbstractCollection)\n\nGet the bus_from field from the DCLine collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_bus_from-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.dc_line_bus_from","text":"dc_line_bus_from(inputs::AbstractInputs, i::Integer)\n\nGet the bus_from field from the DCLine collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_bus_from-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.dc_line_bus_from","text":"dc_line_bus_from(inputs::AbstractInputs)\n\nGet the bus_from field from the DCLine collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_bus_to-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.dc_line_bus_to","text":"dc_line_bus_to(dc_line::AbstractCollection, i::Integer)\n\nGet the bus_to field from the DCLine collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_bus_to-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.dc_line_bus_to","text":"dc_line_bus_to(collections::AbstractCollections, i::Integer)\n\nGet the bus_to field from the DCLine collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_bus_to-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.dc_line_bus_to","text":"dc_line_bus_to(collections::AbstractCollections)\n\nGet the bus_to field from the DCLine collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_bus_to-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.dc_line_bus_to","text":"dc_line_bus_to(dc_line::AbstractCollection)\n\nGet the bus_to field from the DCLine collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_bus_to-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.dc_line_bus_to","text":"dc_line_bus_to(inputs::AbstractInputs, i::Integer)\n\nGet the bus_to field from the DCLine collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_bus_to-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.dc_line_bus_to","text":"dc_line_bus_to(inputs::AbstractInputs)\n\nGet the bus_to field from the DCLine collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_capacity_from-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.dc_line_capacity_from","text":"dc_line_capacity_from(dc_line::AbstractCollection, i::Integer)\n\nGet the capacity_from field from the DCLine collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_capacity_from-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.dc_line_capacity_from","text":"dc_line_capacity_from(collections::AbstractCollections, i::Integer)\n\nGet the capacity_from field from the DCLine collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_capacity_from-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.dc_line_capacity_from","text":"dc_line_capacity_from(collections::AbstractCollections)\n\nGet the capacity_from field from the DCLine collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_capacity_from-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.dc_line_capacity_from","text":"dc_line_capacity_from(dc_line::AbstractCollection)\n\nGet the capacity_from field from the DCLine collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_capacity_from-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.dc_line_capacity_from","text":"dc_line_capacity_from(inputs::AbstractInputs, i::Integer)\n\nGet the capacity_from field from the DCLine collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_capacity_from-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.dc_line_capacity_from","text":"dc_line_capacity_from(inputs::AbstractInputs)\n\nGet the capacity_from field from the DCLine collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_capacity_to-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.dc_line_capacity_to","text":"dc_line_capacity_to(dc_line::AbstractCollection, i::Integer)\n\nGet the capacity_to field from the DCLine collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_capacity_to-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.dc_line_capacity_to","text":"dc_line_capacity_to(collections::AbstractCollections, i::Integer)\n\nGet the capacity_to field from the DCLine collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_capacity_to-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.dc_line_capacity_to","text":"dc_line_capacity_to(collections::AbstractCollections)\n\nGet the capacity_to field from the DCLine collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_capacity_to-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.dc_line_capacity_to","text":"dc_line_capacity_to(dc_line::AbstractCollection)\n\nGet the capacity_to field from the DCLine collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_capacity_to-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.dc_line_capacity_to","text":"dc_line_capacity_to(inputs::AbstractInputs, i::Integer)\n\nGet the capacity_to field from the DCLine collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_capacity_to-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.dc_line_capacity_to","text":"dc_line_capacity_to(inputs::AbstractInputs)\n\nGet the capacity_to field from the DCLine collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_existing-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.dc_line_existing","text":"dc_line_existing(dc_line::AbstractCollection, i::Integer)\n\nGet the existing field from the DCLine collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_existing-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.dc_line_existing","text":"dc_line_existing(collections::AbstractCollections, i::Integer)\n\nGet the existing field from the DCLine collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_existing-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.dc_line_existing","text":"dc_line_existing(collections::AbstractCollections)\n\nGet the existing field from the DCLine collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_existing-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.dc_line_existing","text":"dc_line_existing(dc_line::AbstractCollection)\n\nGet the existing field from the DCLine collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_existing-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.dc_line_existing","text":"dc_line_existing(inputs::AbstractInputs, i::Integer)\n\nGet the existing field from the DCLine collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_existing-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.dc_line_existing","text":"dc_line_existing(inputs::AbstractInputs)\n\nGet the existing field from the DCLine collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_label-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.dc_line_label","text":"dc_line_label(dc_line::AbstractCollection, i::Integer)\n\nGet the label field from the DCLine collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_label-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.dc_line_label","text":"dc_line_label(collections::AbstractCollections, i::Integer)\n\nGet the label field from the DCLine collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_label-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.dc_line_label","text":"dc_line_label(collections::AbstractCollections)\n\nGet the label field from the DCLine collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_label-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.dc_line_label","text":"dc_line_label(dc_line::AbstractCollection)\n\nGet the label field from the DCLine collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_label-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.dc_line_label","text":"dc_line_label(inputs::AbstractInputs, i::Integer)\n\nGet the label field from the DCLine collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.dc_line_label-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.dc_line_label","text":"dc_line_label(inputs::AbstractInputs)\n\nGet the label field from the DCLine collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.debug_path-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.debug_path","text":"debug_path(inputs::AbstractInputs)\n\nReturn the debug path for the case.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.delete_element!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String, String}","page":"API Reference","title":"IARA.delete_element!","text":"delete_element!(db::DatabaseSQLite, collection::String, label::String)\n\nDeletes an element from a collection in the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, IARA.SimulationResultsFromPeriodScenario, Int64, Int64, Int64, Type{IARA.WriteOutput}}","page":"API Reference","title":"IARA.demand!","text":"demand!(outputs, inputs::Inputs, run_time_options::RunTimeOptions, simulation_results::SimulationResultsFromPeriodScenario, period::Int, scenario::Int, subscenario::Int, ::Type{WriteOutput})\n\nWrite the demand and deficit variables' values to the output file.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.InitializeOutput}}","page":"API Reference","title":"IARA.demand!","text":"demand!(outputs::Outputs, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{InitializeOutput})\n\nInitialize the output file to store the demand and deficit variables' values.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Int64, Int64, Int64, Int64, Type{IARA.SubproblemUpdate}}","page":"API Reference","title":"IARA.demand!","text":"demand!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, scenario, subscenario, ::Type{SubproblemUpdate})\n\nUpdates the demand variables in the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.demand!","text":"demand!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the demand variables to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_deficit_cost-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.demand_deficit_cost","text":"demand_deficit_cost(inputs::AbstractInputs)\n\nReturn the deficit cost of demands.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_scenarios_files-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.demand_scenarios_files","text":"demand_scenarios_files(inputs::AbstractInputs)\n\nReturn which demand scenarios files should be read.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_bidding_group_index-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.demand_unit_bidding_group_index","text":"demand_unit_bidding_group_index(demand_unit::AbstractCollection, i::Integer)\n\nGet the biddinggroupindex field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_bidding_group_index-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.demand_unit_bidding_group_index","text":"demand_unit_bidding_group_index(collections::AbstractCollections, i::Integer)\n\nGet the biddinggroupindex field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_bidding_group_index-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.demand_unit_bidding_group_index","text":"demand_unit_bidding_group_index(collections::AbstractCollections)\n\nGet the bidding_group_index field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_bidding_group_index-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.demand_unit_bidding_group_index","text":"demand_unit_bidding_group_index(demand_unit::AbstractCollection)\n\nGet the bidding_group_index field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_bidding_group_index-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.demand_unit_bidding_group_index","text":"demand_unit_bidding_group_index(inputs::AbstractInputs, i::Integer)\n\nGet the biddinggroupindex field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_bidding_group_index-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.demand_unit_bidding_group_index","text":"demand_unit_bidding_group_index(inputs::AbstractInputs)\n\nGet the bidding_group_index field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_bus_index-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.demand_unit_bus_index","text":"demand_unit_bus_index(demand_unit::AbstractCollection, i::Integer)\n\nGet the bus_index field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_bus_index-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.demand_unit_bus_index","text":"demand_unit_bus_index(collections::AbstractCollections, i::Integer)\n\nGet the bus_index field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_bus_index-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.demand_unit_bus_index","text":"demand_unit_bus_index(collections::AbstractCollections)\n\nGet the bus_index field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_bus_index-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.demand_unit_bus_index","text":"demand_unit_bus_index(demand_unit::AbstractCollection)\n\nGet the bus_index field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_bus_index-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.demand_unit_bus_index","text":"demand_unit_bus_index(inputs::AbstractInputs, i::Integer)\n\nGet the bus_index field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_bus_index-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.demand_unit_bus_index","text":"demand_unit_bus_index(inputs::AbstractInputs)\n\nGet the bus_index field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_curtailment_cost_flexible_demand-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.demand_unit_curtailment_cost_flexible_demand","text":"demand_unit_curtailment_cost_flexible_demand(demand_unit::AbstractCollection, i::Integer)\n\nGet the curtailmentcostflexible_demand field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_curtailment_cost_flexible_demand-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.demand_unit_curtailment_cost_flexible_demand","text":"demand_unit_curtailment_cost_flexible_demand(collections::AbstractCollections, i::Integer)\n\nGet the curtailmentcostflexible_demand field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_curtailment_cost_flexible_demand-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.demand_unit_curtailment_cost_flexible_demand","text":"demand_unit_curtailment_cost_flexible_demand(collections::AbstractCollections)\n\nGet the curtailment_cost_flexible_demand field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_curtailment_cost_flexible_demand-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.demand_unit_curtailment_cost_flexible_demand","text":"demand_unit_curtailment_cost_flexible_demand(demand_unit::AbstractCollection)\n\nGet the curtailment_cost_flexible_demand field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_curtailment_cost_flexible_demand-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.demand_unit_curtailment_cost_flexible_demand","text":"demand_unit_curtailment_cost_flexible_demand(inputs::AbstractInputs, i::Integer)\n\nGet the curtailmentcostflexible_demand field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_curtailment_cost_flexible_demand-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.demand_unit_curtailment_cost_flexible_demand","text":"demand_unit_curtailment_cost_flexible_demand(inputs::AbstractInputs)\n\nGet the curtailment_cost_flexible_demand field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_demand_ex_ante_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.demand_unit_demand_ex_ante_file","text":"demand_unit_demand_ex_ante_file(demand_unit::AbstractCollection, i::Integer)\n\nGet the demandexante_file field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_demand_ex_ante_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.demand_unit_demand_ex_ante_file","text":"demand_unit_demand_ex_ante_file(collections::AbstractCollections, i::Integer)\n\nGet the demandexante_file field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_demand_ex_ante_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.demand_unit_demand_ex_ante_file","text":"demand_unit_demand_ex_ante_file(collections::AbstractCollections)\n\nGet the demand_ex_ante_file field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_demand_ex_ante_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.demand_unit_demand_ex_ante_file","text":"demand_unit_demand_ex_ante_file(demand_unit::AbstractCollection)\n\nGet the demand_ex_ante_file field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_demand_ex_ante_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.demand_unit_demand_ex_ante_file","text":"demand_unit_demand_ex_ante_file(inputs::AbstractInputs, i::Integer)\n\nGet the demandexante_file field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_demand_ex_ante_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.demand_unit_demand_ex_ante_file","text":"demand_unit_demand_ex_ante_file(inputs::AbstractInputs)\n\nGet the demand_ex_ante_file field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_demand_ex_post_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.demand_unit_demand_ex_post_file","text":"demand_unit_demand_ex_post_file(demand_unit::AbstractCollection, i::Integer)\n\nGet the demandexpost_file field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_demand_ex_post_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.demand_unit_demand_ex_post_file","text":"demand_unit_demand_ex_post_file(collections::AbstractCollections, i::Integer)\n\nGet the demandexpost_file field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_demand_ex_post_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.demand_unit_demand_ex_post_file","text":"demand_unit_demand_ex_post_file(collections::AbstractCollections)\n\nGet the demand_ex_post_file field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_demand_ex_post_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.demand_unit_demand_ex_post_file","text":"demand_unit_demand_ex_post_file(demand_unit::AbstractCollection)\n\nGet the demand_ex_post_file field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_demand_ex_post_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.demand_unit_demand_ex_post_file","text":"demand_unit_demand_ex_post_file(inputs::AbstractInputs, i::Integer)\n\nGet the demandexpost_file field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_demand_ex_post_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.demand_unit_demand_ex_post_file","text":"demand_unit_demand_ex_post_file(inputs::AbstractInputs)\n\nGet the demand_ex_post_file field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_demand_unit_type-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.demand_unit_demand_unit_type","text":"demand_unit_demand_unit_type(demand_unit::AbstractCollection, i::Integer)\n\nGet the demandunittype field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_demand_unit_type-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.demand_unit_demand_unit_type","text":"demand_unit_demand_unit_type(collections::AbstractCollections, i::Integer)\n\nGet the demandunittype field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_demand_unit_type-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.demand_unit_demand_unit_type","text":"demand_unit_demand_unit_type(collections::AbstractCollections)\n\nGet the demand_unit_type field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_demand_unit_type-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.demand_unit_demand_unit_type","text":"demand_unit_demand_unit_type(demand_unit::AbstractCollection)\n\nGet the demand_unit_type field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_demand_unit_type-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.demand_unit_demand_unit_type","text":"demand_unit_demand_unit_type(inputs::AbstractInputs, i::Integer)\n\nGet the demandunittype field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_demand_unit_type-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.demand_unit_demand_unit_type","text":"demand_unit_demand_unit_type(inputs::AbstractInputs)\n\nGet the demand_unit_type field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_elastic_demand_price_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.demand_unit_elastic_demand_price_file","text":"demand_unit_elastic_demand_price_file(demand_unit::AbstractCollection, i::Integer)\n\nGet the elasticdemandprice_file field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_elastic_demand_price_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.demand_unit_elastic_demand_price_file","text":"demand_unit_elastic_demand_price_file(collections::AbstractCollections, i::Integer)\n\nGet the elasticdemandprice_file field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_elastic_demand_price_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.demand_unit_elastic_demand_price_file","text":"demand_unit_elastic_demand_price_file(collections::AbstractCollections)\n\nGet the elastic_demand_price_file field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_elastic_demand_price_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.demand_unit_elastic_demand_price_file","text":"demand_unit_elastic_demand_price_file(demand_unit::AbstractCollection)\n\nGet the elastic_demand_price_file field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_elastic_demand_price_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.demand_unit_elastic_demand_price_file","text":"demand_unit_elastic_demand_price_file(inputs::AbstractInputs, i::Integer)\n\nGet the elasticdemandprice_file field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_elastic_demand_price_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.demand_unit_elastic_demand_price_file","text":"demand_unit_elastic_demand_price_file(inputs::AbstractInputs)\n\nGet the elastic_demand_price_file field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_existing-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.demand_unit_existing","text":"demand_unit_existing(demand_unit::AbstractCollection, i::Integer)\n\nGet the existing field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_existing-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.demand_unit_existing","text":"demand_unit_existing(collections::AbstractCollections, i::Integer)\n\nGet the existing field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_existing-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.demand_unit_existing","text":"demand_unit_existing(collections::AbstractCollections)\n\nGet the existing field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_existing-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.demand_unit_existing","text":"demand_unit_existing(demand_unit::AbstractCollection)\n\nGet the existing field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_existing-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.demand_unit_existing","text":"demand_unit_existing(inputs::AbstractInputs, i::Integer)\n\nGet the existing field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_existing-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.demand_unit_existing","text":"demand_unit_existing(inputs::AbstractInputs)\n\nGet the existing field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_label-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.demand_unit_label","text":"demand_unit_label(demand_unit::AbstractCollection, i::Integer)\n\nGet the label field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_label-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.demand_unit_label","text":"demand_unit_label(collections::AbstractCollections, i::Integer)\n\nGet the label field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_label-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.demand_unit_label","text":"demand_unit_label(collections::AbstractCollections)\n\nGet the label field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_label-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.demand_unit_label","text":"demand_unit_label(demand_unit::AbstractCollection)\n\nGet the label field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_label-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.demand_unit_label","text":"demand_unit_label(inputs::AbstractInputs, i::Integer)\n\nGet the label field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_label-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.demand_unit_label","text":"demand_unit_label(inputs::AbstractInputs)\n\nGet the label field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_max_curtailment_flexible_demand-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.demand_unit_max_curtailment_flexible_demand","text":"demand_unit_max_curtailment_flexible_demand(demand_unit::AbstractCollection, i::Integer)\n\nGet the maxcurtailmentflexible_demand field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_max_curtailment_flexible_demand-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.demand_unit_max_curtailment_flexible_demand","text":"demand_unit_max_curtailment_flexible_demand(collections::AbstractCollections, i::Integer)\n\nGet the maxcurtailmentflexible_demand field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_max_curtailment_flexible_demand-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.demand_unit_max_curtailment_flexible_demand","text":"demand_unit_max_curtailment_flexible_demand(collections::AbstractCollections)\n\nGet the max_curtailment_flexible_demand field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_max_curtailment_flexible_demand-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.demand_unit_max_curtailment_flexible_demand","text":"demand_unit_max_curtailment_flexible_demand(demand_unit::AbstractCollection)\n\nGet the max_curtailment_flexible_demand field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_max_curtailment_flexible_demand-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.demand_unit_max_curtailment_flexible_demand","text":"demand_unit_max_curtailment_flexible_demand(inputs::AbstractInputs, i::Integer)\n\nGet the maxcurtailmentflexible_demand field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_max_curtailment_flexible_demand-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.demand_unit_max_curtailment_flexible_demand","text":"demand_unit_max_curtailment_flexible_demand(inputs::AbstractInputs)\n\nGet the max_curtailment_flexible_demand field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_max_demand-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.demand_unit_max_demand","text":"demand_unit_max_demand(demand_unit::AbstractCollection, i::Integer)\n\nGet the max_demand field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_max_demand-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.demand_unit_max_demand","text":"demand_unit_max_demand(collections::AbstractCollections, i::Integer)\n\nGet the max_demand field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_max_demand-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.demand_unit_max_demand","text":"demand_unit_max_demand(collections::AbstractCollections)\n\nGet the max_demand field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_max_demand-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.demand_unit_max_demand","text":"demand_unit_max_demand(demand_unit::AbstractCollection)\n\nGet the max_demand field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_max_demand-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.demand_unit_max_demand","text":"demand_unit_max_demand(inputs::AbstractInputs, i::Integer)\n\nGet the max_demand field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_max_demand-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.demand_unit_max_demand","text":"demand_unit_max_demand(inputs::AbstractInputs)\n\nGet the max_demand field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_max_shift_down_flexible_demand-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.demand_unit_max_shift_down_flexible_demand","text":"demand_unit_max_shift_down_flexible_demand(demand_unit::AbstractCollection, i::Integer)\n\nGet the maxshiftdownflexibledemand field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_max_shift_down_flexible_demand-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.demand_unit_max_shift_down_flexible_demand","text":"demand_unit_max_shift_down_flexible_demand(collections::AbstractCollections, i::Integer)\n\nGet the maxshiftdownflexibledemand field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_max_shift_down_flexible_demand-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.demand_unit_max_shift_down_flexible_demand","text":"demand_unit_max_shift_down_flexible_demand(collections::AbstractCollections)\n\nGet the max_shift_down_flexible_demand field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_max_shift_down_flexible_demand-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.demand_unit_max_shift_down_flexible_demand","text":"demand_unit_max_shift_down_flexible_demand(demand_unit::AbstractCollection)\n\nGet the max_shift_down_flexible_demand field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_max_shift_down_flexible_demand-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.demand_unit_max_shift_down_flexible_demand","text":"demand_unit_max_shift_down_flexible_demand(inputs::AbstractInputs, i::Integer)\n\nGet the maxshiftdownflexibledemand field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_max_shift_down_flexible_demand-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.demand_unit_max_shift_down_flexible_demand","text":"demand_unit_max_shift_down_flexible_demand(inputs::AbstractInputs)\n\nGet the max_shift_down_flexible_demand field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_max_shift_up_flexible_demand-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.demand_unit_max_shift_up_flexible_demand","text":"demand_unit_max_shift_up_flexible_demand(demand_unit::AbstractCollection, i::Integer)\n\nGet the maxshiftupflexibledemand field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_max_shift_up_flexible_demand-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.demand_unit_max_shift_up_flexible_demand","text":"demand_unit_max_shift_up_flexible_demand(collections::AbstractCollections, i::Integer)\n\nGet the maxshiftupflexibledemand field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_max_shift_up_flexible_demand-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.demand_unit_max_shift_up_flexible_demand","text":"demand_unit_max_shift_up_flexible_demand(collections::AbstractCollections)\n\nGet the max_shift_up_flexible_demand field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_max_shift_up_flexible_demand-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.demand_unit_max_shift_up_flexible_demand","text":"demand_unit_max_shift_up_flexible_demand(demand_unit::AbstractCollection)\n\nGet the max_shift_up_flexible_demand field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_max_shift_up_flexible_demand-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.demand_unit_max_shift_up_flexible_demand","text":"demand_unit_max_shift_up_flexible_demand(inputs::AbstractInputs, i::Integer)\n\nGet the maxshiftupflexibledemand field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_max_shift_up_flexible_demand-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.demand_unit_max_shift_up_flexible_demand","text":"demand_unit_max_shift_up_flexible_demand(inputs::AbstractInputs)\n\nGet the max_shift_up_flexible_demand field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_window_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.demand_unit_window_file","text":"demand_unit_window_file(demand_unit::AbstractCollection, i::Integer)\n\nGet the window_file field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_window_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.demand_unit_window_file","text":"demand_unit_window_file(collections::AbstractCollections, i::Integer)\n\nGet the window_file field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_window_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.demand_unit_window_file","text":"demand_unit_window_file(collections::AbstractCollections)\n\nGet the window_file field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_window_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.demand_unit_window_file","text":"demand_unit_window_file(demand_unit::AbstractCollection)\n\nGet the window_file field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_window_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.demand_unit_window_file","text":"demand_unit_window_file(inputs::AbstractInputs, i::Integer)\n\nGet the window_file field from the DemandUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.demand_unit_window_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.demand_unit_window_file","text":"demand_unit_window_file(inputs::AbstractInputs)\n\nGet the window_file field from the DemandUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.deserialize_parp_inflow-Tuple{IARA.Inputs}","page":"API Reference","title":"IARA.deserialize_parp_inflow","text":"deserialize_parp_inflow(inputs::Inputs; period::Int, scenario::Int)\n\nDeserialize PAR(p) inflow expression values from a previous clearing problem. Returns a matrix with dimensions [subperiods, hydro_units].\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.elastic_demand!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, IARA.SimulationResultsFromPeriodScenario, Int64, Int64, Int64, Type{IARA.WriteOutput}}","page":"API Reference","title":"IARA.elastic_demand!","text":"elastic_demand!(outputs, inputs::Inputs, run_time_options::RunTimeOptions, simulation_results::SimulationResultsFromPeriodScenario, period::Int, scenario::Int, subscenario::Int, ::Type{WriteOutput})\n\nWrite the attended elastic demand to the output file.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.elastic_demand!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.InitializeOutput}}","page":"API Reference","title":"IARA.elastic_demand!","text":"elastic_demand!(outputs::Outputs, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{InitializeOutput})\n\nInitialize the output file to store the attended elastic demand.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.elastic_demand!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Int64, Int64, Int64, Int64, Type{IARA.SubproblemUpdate}}","page":"API Reference","title":"IARA.elastic_demand!","text":"elastic_demand!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, scenario, subscenario, ::Type{SubproblemUpdate})\n\nUpdates the elastic demand variables in the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.elastic_demand!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.elastic_demand!","text":"elastic_demand!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the elastic demand variables to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.elastic_demand_bounds!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.elastic_demand_bounds!","text":"elastic_demand_bounds!(\n    model,\n    inputs,\n    run_time_options,\n    ::Type{SubproblemBuild},\n)\n\nAdd the elastic demand bounds constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.elastic_demand_labels-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.elastic_demand_labels","text":"elastic_demand_labels(inputs::AbstractInputs)\n\nReturn the labels of elastic Demands.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.expected_number_of_repeats_per_node-Tuple{PSRBridge.AbstractInputs, Int64}","page":"API Reference","title":"IARA.expected_number_of_repeats_per_node","text":"expected_number_of_repeats_per_node(inputs::AbstractInputs, node::Int)\n\nReturn the expected number of repeats for a given node.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.expected_number_of_repeats_per_node-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.expected_number_of_repeats_per_node","text":"expected_number_of_repeats_per_node(inputs::AbstractInputs)\n\nReturn the expected number of repeats per node.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.fcf_cuts_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.fcf_cuts_file","text":"fcf_cuts_file(inputs::AbstractInputs)\n\nReturn the file with the FCF cuts.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.fcf_cuts_path-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.fcf_cuts_path","text":"fcf_cuts_path(inputs::AbstractInputs)\n\nReturn the path to the FCF cuts file.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.fill_data_caches!-Tuple{IARA.Inputs}","page":"API Reference","title":"IARA.fill_data_caches!","text":"fill_data_caches!(inputs::Inputs)\n\nStore pre-processed data for the collections.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.fill_relation_caches!-Tuple{IARA.Inputs}","page":"API Reference","title":"IARA.fill_relation_caches!","text":"fill_relation_caches!(inputs::Inputs)\n\nStore pre-processed relations for the collections.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.finalize_clearing_outputs!-NTuple{5, IARA.Outputs}","page":"API Reference","title":"IARA.finalize_clearing_outputs!","text":"finalize_clearing_outputs!(heuristic_bids_outputs::Outputs, ex_ante_physical_outputs::Outputs, ex_ante_commercial_outputs::Outputs, ex_post_physical_outputs::Outputs, ex_post_commercial_outputs::Outputs)\n\nFinalize the outputs for the clearing subproblem.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.fit_parp_model-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.fit_parp_model","text":"fit_parp_model(inputs::AbstractInputs)\n\nReturn whether the PAR(p) model should be fitted for historical inflow data.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.fix_discrete_variables_from_previous_problem!-Tuple{IARA.Inputs, IARA.RunTimeOptions, JuMP.Model, Int64, Int64}","page":"API Reference","title":"IARA.fix_discrete_variables_from_previous_problem!","text":"fix_discrete_variables_from_previous_problem!(inputs::Inputs, run_time_options::RunTimeOptions, model::JuMP.Model, period::Int, scen::Int)\n\nFix discrete variables from the previous problem.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.flexible_demand!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, IARA.SimulationResultsFromPeriodScenario, Int64, Int64, Int64, Type{IARA.WriteOutput}}","page":"API Reference","title":"IARA.flexible_demand!","text":"flexible_demand!(outputs, inputs::Inputs, run_time_options::RunTimeOptions, simulation_results::SimulationResultsFromPeriodScenario, period::Int, scenario::Int, subscenario::Int, ::Type{WriteOutput})\n\nWrite the attended flexible demand and demand curtailment variables' values to the output file.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.flexible_demand!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.InitializeOutput}}","page":"API Reference","title":"IARA.flexible_demand!","text":"flexible_demand!(outputs::Outputs, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{InitializeOutput})\n\nInitialize the output file to store the attended flexible demand and demand curtailment variables' values.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.flexible_demand!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.flexible_demand!","text":"flexible_demand!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the flexible demand variables to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.flexible_demand_labels-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.flexible_demand_labels","text":"flexible_demand_labels(inputs::AbstractInputs)\n\nReturn the labels of flexible Demands.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.flexible_demand_shift_bounds!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.flexible_demand_shift_bounds!","text":"flexible_demand_shift_bounds!(\n    model,\n    inputs,\n    run_time_options,\n    ::Type{SubproblemBuild},\n)\n\nAdd the flexible demand shift bounds constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.flexible_demand_window_maximum_curtailment!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.flexible_demand_window_maximum_curtailment!","text":"flexible_demand_window_maximum_curtailment!(\n    model,\n    inputs,\n    run_time_options,\n    ::Type{SubproblemBuild},\n)\n\nAdd the flexible demand window maximum curtailment constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.flexible_demand_window_sum!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.flexible_demand_window_sum!","text":"flexible_demand_window_sum!(\n    model,\n    inputs,\n    run_time_options,\n    ::Type{SubproblemBuild},\n)\n\nAdd the flexible demand window sum constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gather_outputs_separated_by_asset_owners-Tuple{IARA.Inputs}","page":"API Reference","title":"IARA.gather_outputs_separated_by_asset_owners","text":"gather_outputs_separated_by_asset_owners(inputs::Inputs)\n\nGather outputs separated by asset owners.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_downstream_index-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.gauging_station_downstream_index","text":"gauging_station_downstream_index(gauging_station::AbstractCollection, i::Integer)\n\nGet the downstream_index field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_downstream_index-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.gauging_station_downstream_index","text":"gauging_station_downstream_index(collections::AbstractCollections, i::Integer)\n\nGet the downstream_index field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_downstream_index-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.gauging_station_downstream_index","text":"gauging_station_downstream_index(collections::AbstractCollections)\n\nGet the downstream_index field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_downstream_index-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.gauging_station_downstream_index","text":"gauging_station_downstream_index(gauging_station::AbstractCollection)\n\nGet the downstream_index field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_downstream_index-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.gauging_station_downstream_index","text":"gauging_station_downstream_index(inputs::AbstractInputs, i::Integer)\n\nGet the downstream_index field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_downstream_index-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.gauging_station_downstream_index","text":"gauging_station_downstream_index(inputs::AbstractInputs)\n\nGet the downstream_index field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_historical_inflow-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.gauging_station_historical_inflow","text":"gauging_station_historical_inflow(gauging_station::AbstractCollection, i::Integer)\n\nGet the historical_inflow field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_historical_inflow-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.gauging_station_historical_inflow","text":"gauging_station_historical_inflow(collections::AbstractCollections, i::Integer)\n\nGet the historical_inflow field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_historical_inflow-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.gauging_station_historical_inflow","text":"gauging_station_historical_inflow(collections::AbstractCollections)\n\nGet the historical_inflow field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_historical_inflow-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.gauging_station_historical_inflow","text":"gauging_station_historical_inflow(gauging_station::AbstractCollection)\n\nGet the historical_inflow field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_historical_inflow-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.gauging_station_historical_inflow","text":"gauging_station_historical_inflow(inputs::AbstractInputs, i::Integer)\n\nGet the historical_inflow field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_historical_inflow-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.gauging_station_historical_inflow","text":"gauging_station_historical_inflow(inputs::AbstractInputs)\n\nGet the historical_inflow field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.gauging_station_inflow_file","text":"gauging_station_inflow_file(inputs::AbstractInputs)\n\nReturn the inflow time series file for all gauging stations.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_initial_state-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.gauging_station_inflow_initial_state","text":"gauging_station_inflow_initial_state(gauging_station::AbstractCollection, i::Integer)\n\nGet the inflowinitialstate field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_initial_state-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.gauging_station_inflow_initial_state","text":"gauging_station_inflow_initial_state(collections::AbstractCollections, i::Integer)\n\nGet the inflowinitialstate field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_initial_state-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.gauging_station_inflow_initial_state","text":"gauging_station_inflow_initial_state(collections::AbstractCollections)\n\nGet the inflow_initial_state field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_initial_state-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.gauging_station_inflow_initial_state","text":"gauging_station_inflow_initial_state(gauging_station::AbstractCollection)\n\nGet the inflow_initial_state field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_initial_state-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.gauging_station_inflow_initial_state","text":"gauging_station_inflow_initial_state(inputs::AbstractInputs, i::Integer)\n\nGet the inflowinitialstate field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_initial_state-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.gauging_station_inflow_initial_state","text":"gauging_station_inflow_initial_state(inputs::AbstractInputs)\n\nGet the inflow_initial_state field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_initial_state_by_scenario_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.gauging_station_inflow_initial_state_by_scenario_file","text":"gauging_station_inflow_initial_state_by_scenario_file(gauging_station::AbstractCollection, i::Integer)\n\nGet the inflowinitialstatebyscenario_file field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_initial_state_by_scenario_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.gauging_station_inflow_initial_state_by_scenario_file","text":"gauging_station_inflow_initial_state_by_scenario_file(collections::AbstractCollections, i::Integer)\n\nGet the inflowinitialstatebyscenario_file field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_initial_state_by_scenario_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.gauging_station_inflow_initial_state_by_scenario_file","text":"gauging_station_inflow_initial_state_by_scenario_file(collections::AbstractCollections)\n\nGet the inflow_initial_state_by_scenario_file field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_initial_state_by_scenario_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.gauging_station_inflow_initial_state_by_scenario_file","text":"gauging_station_inflow_initial_state_by_scenario_file(gauging_station::AbstractCollection)\n\nGet the inflow_initial_state_by_scenario_file field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_initial_state_by_scenario_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.gauging_station_inflow_initial_state_by_scenario_file","text":"gauging_station_inflow_initial_state_by_scenario_file(inputs::AbstractInputs, i::Integer)\n\nGet the inflowinitialstatebyscenario_file field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_initial_state_by_scenario_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.gauging_station_inflow_initial_state_by_scenario_file","text":"gauging_station_inflow_initial_state_by_scenario_file(inputs::AbstractInputs)\n\nGet the inflow_initial_state_by_scenario_file field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_initial_state_variation_type-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.gauging_station_inflow_initial_state_variation_type","text":"gauging_station_inflow_initial_state_variation_type(gauging_station::AbstractCollection, i::Integer)\n\nGet the inflowinitialstatevariationtype field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_initial_state_variation_type-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.gauging_station_inflow_initial_state_variation_type","text":"gauging_station_inflow_initial_state_variation_type(collections::AbstractCollections, i::Integer)\n\nGet the inflowinitialstatevariationtype field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_initial_state_variation_type-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.gauging_station_inflow_initial_state_variation_type","text":"gauging_station_inflow_initial_state_variation_type(collections::AbstractCollections)\n\nGet the inflow_initial_state_variation_type field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_initial_state_variation_type-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.gauging_station_inflow_initial_state_variation_type","text":"gauging_station_inflow_initial_state_variation_type(gauging_station::AbstractCollection)\n\nGet the inflow_initial_state_variation_type field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_initial_state_variation_type-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.gauging_station_inflow_initial_state_variation_type","text":"gauging_station_inflow_initial_state_variation_type(inputs::AbstractInputs, i::Integer)\n\nGet the inflowinitialstatevariationtype field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_initial_state_variation_type-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.gauging_station_inflow_initial_state_variation_type","text":"gauging_station_inflow_initial_state_variation_type(inputs::AbstractInputs)\n\nGet the inflow_initial_state_variation_type field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_noise_ex_ante_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.gauging_station_inflow_noise_ex_ante_file","text":"gauging_station_inflow_noise_ex_ante_file(gauging_station::AbstractCollection, i::Integer)\n\nGet the inflownoiseexantefile field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_noise_ex_ante_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.gauging_station_inflow_noise_ex_ante_file","text":"gauging_station_inflow_noise_ex_ante_file(collections::AbstractCollections, i::Integer)\n\nGet the inflownoiseexantefile field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_noise_ex_ante_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.gauging_station_inflow_noise_ex_ante_file","text":"gauging_station_inflow_noise_ex_ante_file(collections::AbstractCollections)\n\nGet the inflow_noise_ex_ante_file field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_noise_ex_ante_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.gauging_station_inflow_noise_ex_ante_file","text":"gauging_station_inflow_noise_ex_ante_file(gauging_station::AbstractCollection)\n\nGet the inflow_noise_ex_ante_file field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_noise_ex_ante_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.gauging_station_inflow_noise_ex_ante_file","text":"gauging_station_inflow_noise_ex_ante_file(inputs::AbstractInputs, i::Integer)\n\nGet the inflownoiseexantefile field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_noise_ex_ante_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.gauging_station_inflow_noise_ex_ante_file","text":"gauging_station_inflow_noise_ex_ante_file(inputs::AbstractInputs)\n\nGet the inflow_noise_ex_ante_file field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_noise_ex_post_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.gauging_station_inflow_noise_ex_post_file","text":"gauging_station_inflow_noise_ex_post_file(gauging_station::AbstractCollection, i::Integer)\n\nGet the inflownoiseexpostfile field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_noise_ex_post_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.gauging_station_inflow_noise_ex_post_file","text":"gauging_station_inflow_noise_ex_post_file(collections::AbstractCollections, i::Integer)\n\nGet the inflownoiseexpostfile field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_noise_ex_post_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.gauging_station_inflow_noise_ex_post_file","text":"gauging_station_inflow_noise_ex_post_file(collections::AbstractCollections)\n\nGet the inflow_noise_ex_post_file field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_noise_ex_post_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.gauging_station_inflow_noise_ex_post_file","text":"gauging_station_inflow_noise_ex_post_file(gauging_station::AbstractCollection)\n\nGet the inflow_noise_ex_post_file field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_noise_ex_post_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.gauging_station_inflow_noise_ex_post_file","text":"gauging_station_inflow_noise_ex_post_file(inputs::AbstractInputs, i::Integer)\n\nGet the inflownoiseexpostfile field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_noise_ex_post_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.gauging_station_inflow_noise_ex_post_file","text":"gauging_station_inflow_noise_ex_post_file(inputs::AbstractInputs)\n\nGet the inflow_noise_ex_post_file field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_period_average_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.gauging_station_inflow_period_average_file","text":"gauging_station_inflow_period_average_file(gauging_station::AbstractCollection, i::Integer)\n\nGet the inflowperiodaverage_file field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_period_average_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.gauging_station_inflow_period_average_file","text":"gauging_station_inflow_period_average_file(collections::AbstractCollections, i::Integer)\n\nGet the inflowperiodaverage_file field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_period_average_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.gauging_station_inflow_period_average_file","text":"gauging_station_inflow_period_average_file(collections::AbstractCollections)\n\nGet the inflow_period_average_file field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_period_average_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.gauging_station_inflow_period_average_file","text":"gauging_station_inflow_period_average_file(gauging_station::AbstractCollection)\n\nGet the inflow_period_average_file field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_period_average_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.gauging_station_inflow_period_average_file","text":"gauging_station_inflow_period_average_file(inputs::AbstractInputs, i::Integer)\n\nGet the inflowperiodaverage_file field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_period_average_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.gauging_station_inflow_period_average_file","text":"gauging_station_inflow_period_average_file(inputs::AbstractInputs)\n\nGet the inflow_period_average_file field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_period_std_dev_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.gauging_station_inflow_period_std_dev_file","text":"gauging_station_inflow_period_std_dev_file(gauging_station::AbstractCollection, i::Integer)\n\nGet the inflowperiodstddevfile field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_period_std_dev_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.gauging_station_inflow_period_std_dev_file","text":"gauging_station_inflow_period_std_dev_file(collections::AbstractCollections, i::Integer)\n\nGet the inflowperiodstddevfile field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_period_std_dev_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.gauging_station_inflow_period_std_dev_file","text":"gauging_station_inflow_period_std_dev_file(collections::AbstractCollections)\n\nGet the inflow_period_std_dev_file field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_period_std_dev_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.gauging_station_inflow_period_std_dev_file","text":"gauging_station_inflow_period_std_dev_file(gauging_station::AbstractCollection)\n\nGet the inflow_period_std_dev_file field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_period_std_dev_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.gauging_station_inflow_period_std_dev_file","text":"gauging_station_inflow_period_std_dev_file(inputs::AbstractInputs, i::Integer)\n\nGet the inflowperiodstddevfile field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_inflow_period_std_dev_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.gauging_station_inflow_period_std_dev_file","text":"gauging_station_inflow_period_std_dev_file(inputs::AbstractInputs)\n\nGet the inflow_period_std_dev_file field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_label-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.gauging_station_label","text":"gauging_station_label(gauging_station::AbstractCollection, i::Integer)\n\nGet the label field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_label-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.gauging_station_label","text":"gauging_station_label(collections::AbstractCollections, i::Integer)\n\nGet the label field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_label-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.gauging_station_label","text":"gauging_station_label(collections::AbstractCollections)\n\nGet the label field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_label-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.gauging_station_label","text":"gauging_station_label(gauging_station::AbstractCollection)\n\nGet the label field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_label-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.gauging_station_label","text":"gauging_station_label(inputs::AbstractInputs, i::Integer)\n\nGet the label field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_label-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.gauging_station_label","text":"gauging_station_label(inputs::AbstractInputs)\n\nGet the label field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_parp_coefficients_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.gauging_station_parp_coefficients_file","text":"gauging_station_parp_coefficients_file(gauging_station::AbstractCollection, i::Integer)\n\nGet the parpcoefficientsfile field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_parp_coefficients_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.gauging_station_parp_coefficients_file","text":"gauging_station_parp_coefficients_file(collections::AbstractCollections, i::Integer)\n\nGet the parpcoefficientsfile field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_parp_coefficients_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.gauging_station_parp_coefficients_file","text":"gauging_station_parp_coefficients_file(collections::AbstractCollections)\n\nGet the parp_coefficients_file field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_parp_coefficients_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.gauging_station_parp_coefficients_file","text":"gauging_station_parp_coefficients_file(gauging_station::AbstractCollection)\n\nGet the parp_coefficients_file field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_parp_coefficients_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.gauging_station_parp_coefficients_file","text":"gauging_station_parp_coefficients_file(inputs::AbstractInputs, i::Integer)\n\nGet the parpcoefficientsfile field from the GaugingStation collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.gauging_station_parp_coefficients_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.gauging_station_parp_coefficients_file","text":"gauging_station_parp_coefficients_file(inputs::AbstractInputs)\n\nGet the parp_coefficients_file field from the GaugingStation collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.generate_heuristic_bids_for_clearing-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.generate_heuristic_bids_for_clearing","text":"generate_heuristic_bids_for_clearing(inputs::AbstractInputs)\n\nReturn whether heuristic bids should be generated for clearing.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.generate_inflow_scenarios-Tuple{IARA.Inputs}","page":"API Reference","title":"IARA.generate_inflow_scenarios","text":"generate_inflow_scenarios(inputs::Inputs)\n\nGenerate inflow scenarios for the optimization problem.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.get_collection-Tuple{Any, Type{<:PSRBridge.AbstractCollection}}","page":"API Reference","title":"IARA.get_collection","text":"get_collection(inputs::Inputs, collection::Type{<:AbstractCollection})\n\nReturns a IARA.Collection of the specified type from the inputs.\n\nExample:\n\nIARA.get_collection(inputs, IARA.BiddingGroup)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.get_model_object-Tuple{IARA.SubproblemModel, Symbol}","page":"API Reference","title":"IARA.get_model_object","text":"get_model_object(sp_model::SubproblemModel, object_name::Symbol)\n\nRetrieve an object (variable, constraint or expression) from the sp_model's JuMP model  using the provided object_name. This allows flexible access to model components by name.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.get_model_object-Tuple{JuMP.Model, Symbol}","page":"API Reference","title":"IARA.get_model_object","text":"get_model_object(jump_model::Model, object_name::Symbol)\n\nRetrieve an object (variable, constraint or expression) from the jump_model  using the provided object_name. This allows flexible access to model components by name.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.get_spot_prices-NTuple{4, Any}","page":"API Reference","title":"IARA.get_spot_prices","text":"get_spot_prices(reader, bus_collection, generation_labels, network_representation)\n\nGet spot prices for all bidding groups based on the network representation.\n\nArguments\n\nreader: The reader containing spot price data\nbus_collection: The bus collection with zone indices and labels\ngeneration_labels: Array of generation labels in format \"bgX - busY\"\nnetwork_representation: The network representation type (ZONAL or NODAL)\n\nReturns\n\nVector of spot prices corresponding to each generation label\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.has_any_profile_complex_bids-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.has_any_profile_complex_bids","text":"has_any_profile_complex_bids(inputs::AbstractInputs)\n\nReturn true if the bidding group has any profile complex input files.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.has_any_profile_complex_input_files-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.has_any_profile_complex_input_files","text":"has_any_profile_complex_input_files(inputs::AbstractInputs)\n\nReturn true if the bidding group has any profile complex input files.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.has_commitment-Tuple{IARA.HydroUnit, Int64}","page":"API Reference","title":"IARA.has_commitment","text":"has_commitment(hydro_unit::HydroUnit, idx::Int)\n\nCheck if the Hydro Unit at index 'idx' has commitment.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.has_commitment-Tuple{IARA.ThermalUnit, Int64}","page":"API Reference","title":"IARA.has_commitment","text":"has_commitment(thermal_unit::ThermalUnit, idx::Int)\n\nCheck if the Thermal Unit at index 'idx' has commitment.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.has_commitment_initial_condition-Tuple{IARA.ThermalUnit, Int64}","page":"API Reference","title":"IARA.has_commitment_initial_condition","text":"has_commitment_initial_condition(thermal_unit::ThermalUnit, idx::Int)\n\nCheck if the Thermal Unit at index 'idx' has commitment initial condition.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.has_complementary_grouping_profile-Tuple{Vector{Int64}}","page":"API Reference","title":"IARA.has_complementary_grouping_profile","text":"has_complementary_grouping_profile(complementary_grouping_profile_set::Array{Int, 1})\n\nReturns true if the complementary grouping profile set has at least one element equal to 1.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.has_fcf_cuts_to_read-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.has_fcf_cuts_to_read","text":"has_fcf_cuts(inputs::AbstractInputs)\n\nReturn whether the FCF cuts file is defined.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.has_hour_subperiod_map-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.has_hour_subperiod_map","text":"has_hour_subperiod_map(inputs::AbstractInputs)\n\nReturn whether the hour to subperiod map file is defined.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.has_min_outflow-Tuple{IARA.HydroUnit, Int64}","page":"API Reference","title":"IARA.has_min_outflow","text":"has_min_outflow(hydro_unit::HydroUnit, idx::Int)\n\nCheck if the Hydro Unit at index 'idx' has a minimum outflow.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.has_period_season_map_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.has_period_season_map_file","text":"has_period_season_map_file(inputs::AbstractInputs)\n\nReturn whether the period to season map file is defined.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.has_ramp_constraints-Tuple{IARA.ThermalUnit, Int64}","page":"API Reference","title":"IARA.has_ramp_constraints","text":"has_ramp_constraints(thermal_unit::ThermalUnit, idx::Int)\n\nCheck if the Thermal Unit at index 'idx' has ramp constraints.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hour_subperiod_map-Tuple{Any}","page":"API Reference","title":"IARA.hour_subperiod_map","text":"hour_subperiod_map(inputs)\n\nReturn a vector of integers mapping each hour to a single subperiod.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hour_subperiod_map_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hour_subperiod_map_file","text":"hour_subperiod_map_file(inputs::AbstractInputs)\n\nReturn the file with the hour to subperiod map.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_available_energy-Tuple{IARA.Inputs, IARA.RunTimeOptions, Int64, Int64}","page":"API Reference","title":"IARA.hydro_available_energy","text":"hydro_available_energy(\n    inputs::Inputs,\n    run_time_options::RunTimeOptions,\n    period::Int,\n    scenario::Int\n)\n\nCalculate the available energy for each hydro unit in a given period and scenario.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_balance!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, IARA.SimulationResultsFromPeriodScenario, Int64, Int64, Int64, Type{IARA.WriteOutput}}","page":"API Reference","title":"IARA.hydro_balance!","text":"hydro_balance!(\n    outputs,\n    inputs,\n    run_time_options,\n    simulation_results,\n    period,\n    scenario,\n    subscenario,\n    ::Type{WriteOutput},\n)\n\nWrite the hydro opportunity cost to the output file.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_balance!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.InitializeOutput}}","page":"API Reference","title":"IARA.hydro_balance!","text":"hydro_balance!(\n    outputs,\n    inputs,\n    run_time_options,\n    ::Type{InitializeOutput},\n)\n\nInitialize the output file for:\n\nhydro_opportunity_cost\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_balance!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.hydro_balance!","text":"hydro_balance!(\n    model,\n    inputs,\n    run_time_options,\n    ::Type{SubproblemBuild},\n)\n\nAdd the hydro balance constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_balance_aggregated_subperiods-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.hydro_balance_aggregated_subperiods","text":"hydro_balance_aggregated_subperiods(\n    model,\n    inputs,\n    run_time_options,\n)\n\nAdd the hydro balance constraints to the model for the aggregated subperiods resolution.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_balance_chronological_subperiods-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.hydro_balance_chronological_subperiods","text":"hydro_balance_chronological_subperiods(\n    model,\n    inputs,\n    run_time_options,\n)\n\nAdd the hydro balance constraints to the model for the chronological subperiods resolution.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_balance_subperiod_resolution-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_balance_subperiod_resolution","text":"hydro_balance_subperiod_resolution(inputs::AbstractInputs)\n\nReturn the hydro balance subperiod resolution.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_commitment!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, IARA.SimulationResultsFromPeriodScenario, Int64, Int64, Int64, Type{IARA.WriteOutput}}","page":"API Reference","title":"IARA.hydro_commitment!","text":"hydro_commitment!(outputs, inputs::Inputs, run_time_options::RunTimeOptions, simulation_results::SimulationResultsFromPeriodScenario, period::Int, scenario::Int, subscenario::Int, ::Type{WriteOutput})\n\nWrite the hydro unit commitment variables' values to the output file.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_commitment!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.InitializeOutput}}","page":"API Reference","title":"IARA.hydro_commitment!","text":"hydro_commitment!(outputs::Outputs, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{InitializeOutput})\n\nInitialize output file to store the hydro unit commitment variables' values.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_commitment!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.hydro_commitment!","text":"hydro_commitment!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the hydro unit commitment variables to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_generation!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, IARA.SimulationResultsFromPeriodScenario, Int64, Int64, Int64, Type{IARA.WriteOutput}}","page":"API Reference","title":"IARA.hydro_generation!","text":"hydro_generation!(outputs, inputs::Inputs, run_time_options::RunTimeOptions, simulation_results::SimulationResultsFromPeriodScenario, period::Int, scenario::Int, subscenario::Int, ::Type{WriteOutput})\n\nWrite the results for hydro\n\nturbining\nspillage\ngeneration\nspillage penalty\nminimum outflow violation cost\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_generation!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.InitializeOutput}}","page":"API Reference","title":"IARA.hydro_generation!","text":"hydro_generation!(outputs::Outputs, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{InitializeOutput})\n\nInitialize the output files to store results for hydro \n\nturbining\nspillage\ngeneration\nspillage penalty\nminimum outflow slack\nminimum outflow violation cost expression\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_generation!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.hydro_generation!","text":"hydro_generation!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the hydro generation variables to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_generation_bound_by_commitment!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.hydro_generation_bound_by_commitment!","text":"hydro_generation_bound_by_commitment!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the hydro generation bound by commitment constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_inflow!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, IARA.SimulationResultsFromPeriodScenario, Int64, Int64, Int64, Type{IARA.WriteOutput}}","page":"API Reference","title":"IARA.hydro_inflow!","text":"hydro_inflow!(outputs, inputs::Inputs, run_time_options::RunTimeOptions, simulation_results::SimulationResultsFromPeriodScenario, period::Int, scenario::Int, subscenario::Int, ::Type{WriteOutput})\n\nWrite the inflow and inflow_slack values to the output file.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_inflow!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.InitializeOutput}}","page":"API Reference","title":"IARA.hydro_inflow!","text":"hydro_inflow!(outputs::Outputs, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{InitializeOutput})\n\nInitialize the output files for\n\ninflow    \ninflow_slack\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_inflow!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Int64, Int64, Int64, Int64, Type{IARA.SubproblemUpdate}}","page":"API Reference","title":"IARA.hydro_inflow!","text":"hydro_inflow!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, scenario, subscenario, ::Type{SubproblemUpdate})\n\nUpdates the hydro inflow variables in the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_inflow!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.hydro_inflow!","text":"hydro_inflow!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the hydro inflow variables to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_minimum_outflow!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.hydro_minimum_outflow!","text":"hydro_minimum_outflow!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the hydro minimum outflow constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_bidding_group_index-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_bidding_group_index","text":"hydro_unit_bidding_group_index(hydro_unit::AbstractCollection, i::Integer)\n\nGet the biddinggroupindex field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_bidding_group_index-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_bidding_group_index","text":"hydro_unit_bidding_group_index(collections::AbstractCollections, i::Integer)\n\nGet the biddinggroupindex field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_bidding_group_index-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_bidding_group_index","text":"hydro_unit_bidding_group_index(collections::AbstractCollections)\n\nGet the bidding_group_index field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_bidding_group_index-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_bidding_group_index","text":"hydro_unit_bidding_group_index(hydro_unit::AbstractCollection)\n\nGet the bidding_group_index field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_bidding_group_index-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_bidding_group_index","text":"hydro_unit_bidding_group_index(inputs::AbstractInputs, i::Integer)\n\nGet the biddinggroupindex field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_bidding_group_index-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_bidding_group_index","text":"hydro_unit_bidding_group_index(inputs::AbstractInputs)\n\nGet the bidding_group_index field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_bus_index-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_bus_index","text":"hydro_unit_bus_index(hydro_unit::AbstractCollection, i::Integer)\n\nGet the bus_index field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_bus_index-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_bus_index","text":"hydro_unit_bus_index(collections::AbstractCollections, i::Integer)\n\nGet the bus_index field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_bus_index-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_bus_index","text":"hydro_unit_bus_index(collections::AbstractCollections)\n\nGet the bus_index field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_bus_index-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_bus_index","text":"hydro_unit_bus_index(hydro_unit::AbstractCollection)\n\nGet the bus_index field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_bus_index-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_bus_index","text":"hydro_unit_bus_index(inputs::AbstractInputs, i::Integer)\n\nGet the bus_index field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_bus_index-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_bus_index","text":"hydro_unit_bus_index(inputs::AbstractInputs)\n\nGet the bus_index field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_downstream_cumulative_production_factor-Tuple{PSRBridge.AbstractInputs, Int64}","page":"API Reference","title":"IARA.hydro_unit_downstream_cumulative_production_factor","text":"hydro_unit_downstream_cumulative_production_factor(inputs::AbstractInputs, idx::Int)\n\nGet the sum of production factors for the Hydro Unit at index 'idx' and all plants downstream from it.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_existing-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_existing","text":"hydro_unit_existing(hydro_unit::AbstractCollection, i::Integer)\n\nGet the existing field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_existing-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_existing","text":"hydro_unit_existing(collections::AbstractCollections, i::Integer)\n\nGet the existing field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_existing-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_existing","text":"hydro_unit_existing(collections::AbstractCollections)\n\nGet the existing field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_existing-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_existing","text":"hydro_unit_existing(hydro_unit::AbstractCollection)\n\nGet the existing field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_existing-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_existing","text":"hydro_unit_existing(inputs::AbstractInputs, i::Integer)\n\nGet the existing field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_existing-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_existing","text":"hydro_unit_existing(inputs::AbstractInputs)\n\nGet the existing field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_final_volume_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_final_volume_file","text":"hydro_unit_final_volume_file(inputs::AbstractInputs)\n\nReturn the hydro volume time series file for all hydro units.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_gauging_station_index-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_gauging_station_index","text":"hydro_unit_gauging_station_index(hydro_unit::AbstractCollection, i::Integer)\n\nGet the gaugingstationindex field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_gauging_station_index-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_gauging_station_index","text":"hydro_unit_gauging_station_index(collections::AbstractCollections, i::Integer)\n\nGet the gaugingstationindex field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_gauging_station_index-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_gauging_station_index","text":"hydro_unit_gauging_station_index(collections::AbstractCollections)\n\nGet the gauging_station_index field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_gauging_station_index-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_gauging_station_index","text":"hydro_unit_gauging_station_index(hydro_unit::AbstractCollection)\n\nGet the gauging_station_index field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_gauging_station_index-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_gauging_station_index","text":"hydro_unit_gauging_station_index(inputs::AbstractInputs, i::Integer)\n\nGet the gaugingstationindex field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_gauging_station_index-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_gauging_station_index","text":"hydro_unit_gauging_station_index(inputs::AbstractInputs)\n\nGet the gauging_station_index field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_generation_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_generation_file","text":"hydro_unit_generation_file(inputs::AbstractInputs)\n\nReturn the hydro generation time series file for all hydro units.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_has_commitment-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_has_commitment","text":"hydro_unit_has_commitment(hydro_unit::AbstractCollection, i::Integer)\n\nGet the has_commitment field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_has_commitment-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_has_commitment","text":"hydro_unit_has_commitment(collections::AbstractCollections, i::Integer)\n\nGet the has_commitment field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_has_commitment-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_has_commitment","text":"hydro_unit_has_commitment(collections::AbstractCollections)\n\nGet the has_commitment field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_has_commitment-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_has_commitment","text":"hydro_unit_has_commitment(hydro_unit::AbstractCollection)\n\nGet the has_commitment field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_has_commitment-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_has_commitment","text":"hydro_unit_has_commitment(inputs::AbstractInputs, i::Integer)\n\nGet the has_commitment field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_has_commitment-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_has_commitment","text":"hydro_unit_has_commitment(inputs::AbstractInputs)\n\nGet the has_commitment field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_inflow_ex_ante_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_inflow_ex_ante_file","text":"hydro_unit_inflow_ex_ante_file(hydro_unit::AbstractCollection, i::Integer)\n\nGet the inflowexante_file field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_inflow_ex_ante_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_inflow_ex_ante_file","text":"hydro_unit_inflow_ex_ante_file(collections::AbstractCollections, i::Integer)\n\nGet the inflowexante_file field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_inflow_ex_ante_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_inflow_ex_ante_file","text":"hydro_unit_inflow_ex_ante_file(collections::AbstractCollections)\n\nGet the inflow_ex_ante_file field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_inflow_ex_ante_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_inflow_ex_ante_file","text":"hydro_unit_inflow_ex_ante_file(hydro_unit::AbstractCollection)\n\nGet the inflow_ex_ante_file field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_inflow_ex_ante_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_inflow_ex_ante_file","text":"hydro_unit_inflow_ex_ante_file(inputs::AbstractInputs, i::Integer)\n\nGet the inflowexante_file field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_inflow_ex_ante_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_inflow_ex_ante_file","text":"hydro_unit_inflow_ex_ante_file(inputs::AbstractInputs)\n\nGet the inflow_ex_ante_file field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_inflow_ex_post_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_inflow_ex_post_file","text":"hydro_unit_inflow_ex_post_file(hydro_unit::AbstractCollection, i::Integer)\n\nGet the inflowexpost_file field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_inflow_ex_post_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_inflow_ex_post_file","text":"hydro_unit_inflow_ex_post_file(collections::AbstractCollections, i::Integer)\n\nGet the inflowexpost_file field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_inflow_ex_post_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_inflow_ex_post_file","text":"hydro_unit_inflow_ex_post_file(collections::AbstractCollections)\n\nGet the inflow_ex_post_file field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_inflow_ex_post_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_inflow_ex_post_file","text":"hydro_unit_inflow_ex_post_file(hydro_unit::AbstractCollection)\n\nGet the inflow_ex_post_file field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_inflow_ex_post_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_inflow_ex_post_file","text":"hydro_unit_inflow_ex_post_file(inputs::AbstractInputs, i::Integer)\n\nGet the inflowexpost_file field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_inflow_ex_post_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_inflow_ex_post_file","text":"hydro_unit_inflow_ex_post_file(inputs::AbstractInputs)\n\nGet the inflow_ex_post_file field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_initial_volume","text":"hydro_unit_initial_volume(hydro_unit::AbstractCollection, i::Integer)\n\nGet the initial_volume field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_initial_volume","text":"hydro_unit_initial_volume(collections::AbstractCollections, i::Integer)\n\nGet the initial_volume field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_initial_volume","text":"hydro_unit_initial_volume(collections::AbstractCollections)\n\nGet the initial_volume field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_initial_volume","text":"hydro_unit_initial_volume(hydro_unit::AbstractCollection)\n\nGet the initial_volume field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume-Tuple{PSRBridge.AbstractInputs, Int64}","page":"API Reference","title":"IARA.hydro_unit_initial_volume","text":"hydro_unit_initial_volume(inputs::AbstractInputs, idx::Int)\n\nGet the initial volume for the Hydro Unit at index 'idx'.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_initial_volume","text":"hydro_unit_initial_volume(inputs::AbstractInputs, i::Integer)\n\nGet the initial_volume field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_initial_volume","text":"hydro_unit_initial_volume(inputs::AbstractInputs)\n\nGet the initial_volume field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume_by_scenario_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_initial_volume_by_scenario_file","text":"hydro_unit_initial_volume_by_scenario_file(hydro_unit::AbstractCollection, i::Integer)\n\nGet the initialvolumebyscenariofile field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume_by_scenario_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_initial_volume_by_scenario_file","text":"hydro_unit_initial_volume_by_scenario_file(collections::AbstractCollections, i::Integer)\n\nGet the initialvolumebyscenariofile field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume_by_scenario_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_initial_volume_by_scenario_file","text":"hydro_unit_initial_volume_by_scenario_file(collections::AbstractCollections)\n\nGet the initial_volume_by_scenario_file field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume_by_scenario_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_initial_volume_by_scenario_file","text":"hydro_unit_initial_volume_by_scenario_file(hydro_unit::AbstractCollection)\n\nGet the initial_volume_by_scenario_file field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume_by_scenario_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_initial_volume_by_scenario_file","text":"hydro_unit_initial_volume_by_scenario_file(inputs::AbstractInputs, i::Integer)\n\nGet the initialvolumebyscenariofile field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume_by_scenario_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_initial_volume_by_scenario_file","text":"hydro_unit_initial_volume_by_scenario_file(inputs::AbstractInputs)\n\nGet the initial_volume_by_scenario_file field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume_type-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_initial_volume_type","text":"hydro_unit_initial_volume_type(hydro_unit::AbstractCollection, i::Integer)\n\nGet the initialvolumetype field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume_type-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_initial_volume_type","text":"hydro_unit_initial_volume_type(collections::AbstractCollections, i::Integer)\n\nGet the initialvolumetype field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume_type-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_initial_volume_type","text":"hydro_unit_initial_volume_type(collections::AbstractCollections)\n\nGet the initial_volume_type field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume_type-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_initial_volume_type","text":"hydro_unit_initial_volume_type(hydro_unit::AbstractCollection)\n\nGet the initial_volume_type field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume_type-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_initial_volume_type","text":"hydro_unit_initial_volume_type(inputs::AbstractInputs, i::Integer)\n\nGet the initialvolumetype field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume_type-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_initial_volume_type","text":"hydro_unit_initial_volume_type(inputs::AbstractInputs)\n\nGet the initial_volume_type field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume_variation_type-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_initial_volume_variation_type","text":"hydro_unit_initial_volume_variation_type(hydro_unit::AbstractCollection, i::Integer)\n\nGet the initialvolumevariation_type field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume_variation_type-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_initial_volume_variation_type","text":"hydro_unit_initial_volume_variation_type(collections::AbstractCollections, i::Integer)\n\nGet the initialvolumevariation_type field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume_variation_type-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_initial_volume_variation_type","text":"hydro_unit_initial_volume_variation_type(collections::AbstractCollections)\n\nGet the initial_volume_variation_type field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume_variation_type-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_initial_volume_variation_type","text":"hydro_unit_initial_volume_variation_type(hydro_unit::AbstractCollection)\n\nGet the initial_volume_variation_type field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume_variation_type-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_initial_volume_variation_type","text":"hydro_unit_initial_volume_variation_type(inputs::AbstractInputs, i::Integer)\n\nGet the initialvolumevariation_type field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_initial_volume_variation_type-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_initial_volume_variation_type","text":"hydro_unit_initial_volume_variation_type(inputs::AbstractInputs)\n\nGet the initial_volume_variation_type field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_intra_period_operation-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_intra_period_operation","text":"hydro_unit_intra_period_operation(hydro_unit::AbstractCollection, i::Integer)\n\nGet the intraperiodoperation field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_intra_period_operation-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_intra_period_operation","text":"hydro_unit_intra_period_operation(collections::AbstractCollections, i::Integer)\n\nGet the intraperiodoperation field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_intra_period_operation-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_intra_period_operation","text":"hydro_unit_intra_period_operation(collections::AbstractCollections)\n\nGet the intra_period_operation field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_intra_period_operation-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_intra_period_operation","text":"hydro_unit_intra_period_operation(hydro_unit::AbstractCollection)\n\nGet the intra_period_operation field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_intra_period_operation-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_intra_period_operation","text":"hydro_unit_intra_period_operation(inputs::AbstractInputs, i::Integer)\n\nGet the intraperiodoperation field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_intra_period_operation-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_intra_period_operation","text":"hydro_unit_intra_period_operation(inputs::AbstractInputs)\n\nGet the intra_period_operation field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_is_associated_with_some_virtual_reservoir-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_is_associated_with_some_virtual_reservoir","text":"hydro_unit_is_associated_with_some_virtual_reservoir(hydro_unit::AbstractCollection, i::Integer)\n\nGet the isassociatedwithsomevirtual_reservoir field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_is_associated_with_some_virtual_reservoir-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_is_associated_with_some_virtual_reservoir","text":"hydro_unit_is_associated_with_some_virtual_reservoir(collections::AbstractCollections, i::Integer)\n\nGet the isassociatedwithsomevirtual_reservoir field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_is_associated_with_some_virtual_reservoir-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_is_associated_with_some_virtual_reservoir","text":"hydro_unit_is_associated_with_some_virtual_reservoir(collections::AbstractCollections)\n\nGet the is_associated_with_some_virtual_reservoir field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_is_associated_with_some_virtual_reservoir-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_is_associated_with_some_virtual_reservoir","text":"hydro_unit_is_associated_with_some_virtual_reservoir(hydro_unit::AbstractCollection)\n\nGet the is_associated_with_some_virtual_reservoir field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_is_associated_with_some_virtual_reservoir-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_is_associated_with_some_virtual_reservoir","text":"hydro_unit_is_associated_with_some_virtual_reservoir(inputs::AbstractInputs, i::Integer)\n\nGet the isassociatedwithsomevirtual_reservoir field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_is_associated_with_some_virtual_reservoir-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_is_associated_with_some_virtual_reservoir","text":"hydro_unit_is_associated_with_some_virtual_reservoir(inputs::AbstractInputs)\n\nGet the is_associated_with_some_virtual_reservoir field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_label-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_label","text":"hydro_unit_label(hydro_unit::AbstractCollection, i::Integer)\n\nGet the label field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_label-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_label","text":"hydro_unit_label(collections::AbstractCollections, i::Integer)\n\nGet the label field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_label-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_label","text":"hydro_unit_label(collections::AbstractCollections)\n\nGet the label field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_label-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_label","text":"hydro_unit_label(hydro_unit::AbstractCollection)\n\nGet the label field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_label-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_label","text":"hydro_unit_label(inputs::AbstractInputs, i::Integer)\n\nGet the label field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_label-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_label","text":"hydro_unit_label(inputs::AbstractInputs)\n\nGet the label field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_max_generation-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_max_generation","text":"hydro_unit_max_generation(hydro_unit::AbstractCollection, i::Integer)\n\nGet the max_generation field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_max_generation-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_max_generation","text":"hydro_unit_max_generation(collections::AbstractCollections, i::Integer)\n\nGet the max_generation field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_max_generation-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_max_generation","text":"hydro_unit_max_generation(collections::AbstractCollections)\n\nGet the max_generation field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_max_generation-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_max_generation","text":"hydro_unit_max_generation(hydro_unit::AbstractCollection)\n\nGet the max_generation field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_max_generation-Tuple{PSRBridge.AbstractInputs, Int64}","page":"API Reference","title":"IARA.hydro_unit_max_generation","text":"hydro_unit_max_generation(inputs::AbstractInputs, idx::Int)\n\nGet the maximum generation for the Hydro Unit at index 'idx'.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_max_generation-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_max_generation","text":"hydro_unit_max_generation(inputs::AbstractInputs, i::Integer)\n\nGet the max_generation field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_max_generation-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_max_generation","text":"hydro_unit_max_generation(inputs::AbstractInputs)\n\nGet the max_generation field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_max_turbining-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_max_turbining","text":"hydro_unit_max_turbining(hydro_unit::AbstractCollection, i::Integer)\n\nGet the max_turbining field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_max_turbining-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_max_turbining","text":"hydro_unit_max_turbining(collections::AbstractCollections, i::Integer)\n\nGet the max_turbining field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_max_turbining-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_max_turbining","text":"hydro_unit_max_turbining(collections::AbstractCollections)\n\nGet the max_turbining field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_max_turbining-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_max_turbining","text":"hydro_unit_max_turbining(hydro_unit::AbstractCollection)\n\nGet the max_turbining field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_max_turbining-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_max_turbining","text":"hydro_unit_max_turbining(inputs::AbstractInputs, i::Integer)\n\nGet the max_turbining field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_max_turbining-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_max_turbining","text":"hydro_unit_max_turbining(inputs::AbstractInputs)\n\nGet the max_turbining field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_max_volume-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_max_volume","text":"hydro_unit_max_volume(hydro_unit::AbstractCollection, i::Integer)\n\nGet the max_volume field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_max_volume-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_max_volume","text":"hydro_unit_max_volume(collections::AbstractCollections, i::Integer)\n\nGet the max_volume field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_max_volume-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_max_volume","text":"hydro_unit_max_volume(collections::AbstractCollections)\n\nGet the max_volume field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_max_volume-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_max_volume","text":"hydro_unit_max_volume(hydro_unit::AbstractCollection)\n\nGet the max_volume field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_max_volume-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_max_volume","text":"hydro_unit_max_volume(inputs::AbstractInputs, i::Integer)\n\nGet the max_volume field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_max_volume-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_max_volume","text":"hydro_unit_max_volume(inputs::AbstractInputs)\n\nGet the max_volume field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_min_generation-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_min_generation","text":"hydro_unit_min_generation(hydro_unit::AbstractCollection, i::Integer)\n\nGet the min_generation field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_min_generation-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_min_generation","text":"hydro_unit_min_generation(collections::AbstractCollections, i::Integer)\n\nGet the min_generation field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_min_generation-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_min_generation","text":"hydro_unit_min_generation(collections::AbstractCollections)\n\nGet the min_generation field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_min_generation-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_min_generation","text":"hydro_unit_min_generation(hydro_unit::AbstractCollection)\n\nGet the min_generation field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_min_generation-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_min_generation","text":"hydro_unit_min_generation(inputs::AbstractInputs, i::Integer)\n\nGet the min_generation field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_min_generation-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_min_generation","text":"hydro_unit_min_generation(inputs::AbstractInputs)\n\nGet the min_generation field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_min_outflow-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_min_outflow","text":"hydro_unit_min_outflow(hydro_unit::AbstractCollection, i::Integer)\n\nGet the min_outflow field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_min_outflow-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_min_outflow","text":"hydro_unit_min_outflow(collections::AbstractCollections, i::Integer)\n\nGet the min_outflow field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_min_outflow-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_min_outflow","text":"hydro_unit_min_outflow(collections::AbstractCollections)\n\nGet the min_outflow field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_min_outflow-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_min_outflow","text":"hydro_unit_min_outflow(hydro_unit::AbstractCollection)\n\nGet the min_outflow field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_min_outflow-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_min_outflow","text":"hydro_unit_min_outflow(inputs::AbstractInputs, i::Integer)\n\nGet the min_outflow field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_min_outflow-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_min_outflow","text":"hydro_unit_min_outflow(inputs::AbstractInputs)\n\nGet the min_outflow field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_min_volume-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_min_volume","text":"hydro_unit_min_volume(hydro_unit::AbstractCollection, i::Integer)\n\nGet the min_volume field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_min_volume-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_min_volume","text":"hydro_unit_min_volume(collections::AbstractCollections, i::Integer)\n\nGet the min_volume field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_min_volume-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_min_volume","text":"hydro_unit_min_volume(collections::AbstractCollections)\n\nGet the min_volume field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_min_volume-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_min_volume","text":"hydro_unit_min_volume(hydro_unit::AbstractCollection)\n\nGet the min_volume field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_min_volume-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_min_volume","text":"hydro_unit_min_volume(inputs::AbstractInputs, i::Integer)\n\nGet the min_volume field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_min_volume-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_min_volume","text":"hydro_unit_min_volume(inputs::AbstractInputs)\n\nGet the min_volume field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_minimum_outflow_violation_benchmark-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_minimum_outflow_violation_benchmark","text":"hydro_unit_minimum_outflow_violation_benchmark(hydro_unit::AbstractCollection, i::Integer)\n\nGet the minimumoutflowviolation_benchmark field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_minimum_outflow_violation_benchmark-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_minimum_outflow_violation_benchmark","text":"hydro_unit_minimum_outflow_violation_benchmark(collections::AbstractCollections, i::Integer)\n\nGet the minimumoutflowviolation_benchmark field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_minimum_outflow_violation_benchmark-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_minimum_outflow_violation_benchmark","text":"hydro_unit_minimum_outflow_violation_benchmark(collections::AbstractCollections)\n\nGet the minimum_outflow_violation_benchmark field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_minimum_outflow_violation_benchmark-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_minimum_outflow_violation_benchmark","text":"hydro_unit_minimum_outflow_violation_benchmark(hydro_unit::AbstractCollection)\n\nGet the minimum_outflow_violation_benchmark field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_minimum_outflow_violation_benchmark-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_minimum_outflow_violation_benchmark","text":"hydro_unit_minimum_outflow_violation_benchmark(inputs::AbstractInputs, i::Integer)\n\nGet the minimumoutflowviolation_benchmark field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_minimum_outflow_violation_benchmark-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_minimum_outflow_violation_benchmark","text":"hydro_unit_minimum_outflow_violation_benchmark(inputs::AbstractInputs)\n\nGet the minimum_outflow_violation_benchmark field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_minimum_outflow_violation_cost-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_minimum_outflow_violation_cost","text":"hydro_unit_minimum_outflow_violation_cost(hydro_unit::AbstractCollection, i::Integer)\n\nGet the minimumoutflowviolation_cost field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_minimum_outflow_violation_cost-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_minimum_outflow_violation_cost","text":"hydro_unit_minimum_outflow_violation_cost(collections::AbstractCollections, i::Integer)\n\nGet the minimumoutflowviolation_cost field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_minimum_outflow_violation_cost-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_minimum_outflow_violation_cost","text":"hydro_unit_minimum_outflow_violation_cost(collections::AbstractCollections)\n\nGet the minimum_outflow_violation_cost field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_minimum_outflow_violation_cost-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_minimum_outflow_violation_cost","text":"hydro_unit_minimum_outflow_violation_cost(hydro_unit::AbstractCollection)\n\nGet the minimum_outflow_violation_cost field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_minimum_outflow_violation_cost-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_minimum_outflow_violation_cost","text":"hydro_unit_minimum_outflow_violation_cost(inputs::AbstractInputs, i::Integer)\n\nGet the minimumoutflowviolation_cost field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_minimum_outflow_violation_cost-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_minimum_outflow_violation_cost","text":"hydro_unit_minimum_outflow_violation_cost(inputs::AbstractInputs)\n\nGet the minimum_outflow_violation_cost field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_om_cost-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_om_cost","text":"hydro_unit_om_cost(hydro_unit::AbstractCollection, i::Integer)\n\nGet the om_cost field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_om_cost-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_om_cost","text":"hydro_unit_om_cost(collections::AbstractCollections, i::Integer)\n\nGet the om_cost field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_om_cost-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_om_cost","text":"hydro_unit_om_cost(collections::AbstractCollections)\n\nGet the om_cost field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_om_cost-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_om_cost","text":"hydro_unit_om_cost(hydro_unit::AbstractCollection)\n\nGet the om_cost field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_om_cost-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_om_cost","text":"hydro_unit_om_cost(inputs::AbstractInputs, i::Integer)\n\nGet the om_cost field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_om_cost-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_om_cost","text":"hydro_unit_om_cost(inputs::AbstractInputs)\n\nGet the om_cost field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_opportunity_cost_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_opportunity_cost_file","text":"hydro_unit_opportunity_cost_file(inputs::AbstractInputs)\n\nReturn the hydro opportunity cost time series file for all hydro units.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_production_factor-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_production_factor","text":"hydro_unit_production_factor(hydro_unit::AbstractCollection, i::Integer)\n\nGet the production_factor field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_production_factor-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_production_factor","text":"hydro_unit_production_factor(collections::AbstractCollections, i::Integer)\n\nGet the production_factor field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_production_factor-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_production_factor","text":"hydro_unit_production_factor(collections::AbstractCollections)\n\nGet the production_factor field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_production_factor-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_production_factor","text":"hydro_unit_production_factor(hydro_unit::AbstractCollection)\n\nGet the production_factor field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_production_factor-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_production_factor","text":"hydro_unit_production_factor(inputs::AbstractInputs, i::Integer)\n\nGet the production_factor field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_production_factor-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_production_factor","text":"hydro_unit_production_factor(inputs::AbstractInputs)\n\nGet the production_factor field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_spill_to-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_spill_to","text":"hydro_unit_spill_to(hydro_unit::AbstractCollection, i::Integer)\n\nGet the spill_to field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_spill_to-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_spill_to","text":"hydro_unit_spill_to(collections::AbstractCollections, i::Integer)\n\nGet the spill_to field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_spill_to-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_spill_to","text":"hydro_unit_spill_to(collections::AbstractCollections)\n\nGet the spill_to field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_spill_to-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_spill_to","text":"hydro_unit_spill_to(hydro_unit::AbstractCollection)\n\nGet the spill_to field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_spill_to-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_spill_to","text":"hydro_unit_spill_to(inputs::AbstractInputs, i::Integer)\n\nGet the spill_to field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_spill_to-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_spill_to","text":"hydro_unit_spill_to(inputs::AbstractInputs)\n\nGet the spill_to field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_spillage_cost-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_spillage_cost","text":"hydro_unit_spillage_cost(hydro_unit::AbstractCollection, i::Integer)\n\nGet the spillage_cost field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_spillage_cost-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_spillage_cost","text":"hydro_unit_spillage_cost(collections::AbstractCollections, i::Integer)\n\nGet the spillage_cost field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_spillage_cost-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_spillage_cost","text":"hydro_unit_spillage_cost(collections::AbstractCollections)\n\nGet the spillage_cost field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_spillage_cost-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_spillage_cost","text":"hydro_unit_spillage_cost(hydro_unit::AbstractCollection)\n\nGet the spillage_cost field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_spillage_cost-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_spillage_cost","text":"hydro_unit_spillage_cost(inputs::AbstractInputs, i::Integer)\n\nGet the spillage_cost field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_spillage_cost-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_spillage_cost","text":"hydro_unit_spillage_cost(inputs::AbstractInputs)\n\nGet the spillage_cost field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_turbine_to-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_turbine_to","text":"hydro_unit_turbine_to(hydro_unit::AbstractCollection, i::Integer)\n\nGet the turbine_to field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_turbine_to-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_turbine_to","text":"hydro_unit_turbine_to(collections::AbstractCollections, i::Integer)\n\nGet the turbine_to field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_turbine_to-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_turbine_to","text":"hydro_unit_turbine_to(collections::AbstractCollections)\n\nGet the turbine_to field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_turbine_to-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_turbine_to","text":"hydro_unit_turbine_to(hydro_unit::AbstractCollection)\n\nGet the turbine_to field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_turbine_to-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_turbine_to","text":"hydro_unit_turbine_to(inputs::AbstractInputs, i::Integer)\n\nGet the turbine_to field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_turbine_to-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_turbine_to","text":"hydro_unit_turbine_to(inputs::AbstractInputs)\n\nGet the turbine_to field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_virtual_reservoir_index-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.hydro_unit_virtual_reservoir_index","text":"hydro_unit_virtual_reservoir_index(hydro_unit::AbstractCollection, i::Integer)\n\nGet the virtualreservoirindex field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_virtual_reservoir_index-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.hydro_unit_virtual_reservoir_index","text":"hydro_unit_virtual_reservoir_index(collections::AbstractCollections, i::Integer)\n\nGet the virtualreservoirindex field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_virtual_reservoir_index-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.hydro_unit_virtual_reservoir_index","text":"hydro_unit_virtual_reservoir_index(collections::AbstractCollections)\n\nGet the virtual_reservoir_index field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_virtual_reservoir_index-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.hydro_unit_virtual_reservoir_index","text":"hydro_unit_virtual_reservoir_index(hydro_unit::AbstractCollection)\n\nGet the virtual_reservoir_index field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_virtual_reservoir_index-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.hydro_unit_virtual_reservoir_index","text":"hydro_unit_virtual_reservoir_index(inputs::AbstractInputs, i::Integer)\n\nGet the virtualreservoirindex field from the HydroUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_unit_virtual_reservoir_index-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.hydro_unit_virtual_reservoir_index","text":"hydro_unit_virtual_reservoir_index(inputs::AbstractInputs)\n\nGet the virtual_reservoir_index field from the HydroUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_volume!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, IARA.SimulationResultsFromPeriodScenario, Int64, Int64, Int64, Type{IARA.WriteOutput}}","page":"API Reference","title":"IARA.hydro_volume!","text":"hydro_volume!(outputs, inputs::Inputs, run_time_options::RunTimeOptions, simulation_results::SimulationResultsFromPeriodScenario, period::Int, scenario::Int, subscenario::Int, ::Type{WriteOutput})\n\nWrite the hydro final and initial volume values to the output file.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_volume!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.InitializeOutput}}","page":"API Reference","title":"IARA.hydro_volume!","text":"hydro_volume!(outputs::Outputs, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{InitializeOutput})\n\nInitialize the output files for\n\nhydroinitialvolume\nhydrofinalvolume\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_volume!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Int64, Int64, Int64, Int64, Type{IARA.SubproblemUpdate}}","page":"API Reference","title":"IARA.hydro_volume!","text":"hydro_volume!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, scenario, subscenario, ::Type{SubproblemUpdate})\n\nUpdates the hydro volume variables in the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_volume!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.hydro_volume!","text":"hydro_volume!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the hydro volume variables to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.hydro_volume_from_previous_period-Tuple{PSRBridge.AbstractInputs, Any, Int64, Int64}","page":"API Reference","title":"IARA.hydro_volume_from_previous_period","text":"hydro_volume_from_previous_period(inputs::AbstractInputs, run_time_options, period::Int, scenario::Int)\n\nGet the hydro volume from the previous period.\n\nIf the period is the first one, the initial volume is returned. Otherwise, it is read from the serialized results of the previous stage.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.index_among_elastic_demands-Tuple{PSRBridge.AbstractInputs, Int64}","page":"API Reference","title":"IARA.index_among_elastic_demands","text":"index_among_elastic_demands(inputs::AbstractInputs, idx::Int)\n\nReturn the index of the Demand in position 'idx' among the elastic Demands.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.inflow_model-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.inflow_model","text":"inflow_model(inputs::AbstractInputs)\n\nReturn the inflow model type.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.inflow_scenarios_files-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.inflow_scenarios_files","text":"inflow_scenarios_files(inputs::AbstractInputs)\n\nReturn which inflow scenarios files should be read.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.initial_date_time-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.initial_date_time","text":"initial_date_time(inputs::AbstractInputs)\n\nReturn the initial date of the problem.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.initialize!-Tuple{IARA.AssetOwner, PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.initialize!","text":"initialize!(asset_owner::AssetOwner, inputs)\n\nInitialize the AssetOwner collection from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.initialize!-Tuple{IARA.BatteryUnit, PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.initialize!","text":"initialize!(battery_unit::BatteryUnit, inputs::AbstractInputs)\n\nInitialize the Battery Unit collection from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.initialize!-Tuple{IARA.BiddingGroup, PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.initialize!","text":"initialize!(bidding_group::BiddingGroup, inputs::AbstractInputs)\n\nInitialize the BiddingGroup collection from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.initialize!-Tuple{IARA.Branch, PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.initialize!","text":"initialize!(branch::Branch, inputs::AbstractInputs)\n\nInitialize the Branch collection from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.initialize!-Tuple{IARA.Bus, PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.initialize!","text":"initialize!(bus::Bus, inputs::AbstractInputs)\n\nInitialize the Bus collection from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.initialize!-Tuple{IARA.Configurations, PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.initialize!","text":"initialize!(configurations::Configurations, inputs::AbstractInputs)\n\nInitialize the Configurations collection from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.initialize!-Tuple{IARA.DCLine, PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.initialize!","text":"initialize!(dc_line::DCLine, inputs::AbstractInputs)\n\nInitialize the DC Line collection from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.initialize!-Tuple{IARA.DemandUnit, PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.initialize!","text":"initialize!(demand_unit::DemandUnit, inputs::AbstractInputs)\n\nInitialize the Demand collection from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.initialize!-Tuple{IARA.GaugingStation, PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.initialize!","text":"initialize!(gauging_station::GaugingStation, inputs::AbstractInputs)\n\nInitialize the GaugingStation collection from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.initialize!-Tuple{IARA.HydroUnit, PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.initialize!","text":"initialize!(hydro_unit::HydroUnit, inputs::AbstractInputs)\n\nInitialize the Hydro Unit collection from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.initialize!-Tuple{IARA.Inputs}","page":"API Reference","title":"IARA.initialize!","text":"initialize!(inputs::Inputs)\n\nInitialize the inputs.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.initialize!-Tuple{IARA.Interconnection, PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.initialize!","text":"initialize!(interconnection::Interconnection, inputs::AbstractInputs)\n\nInitialize the Interconnection collection from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.initialize!-Tuple{IARA.RenewableUnit, PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.initialize!","text":"initialize!(renewable_unit::RenewableUnit, inputs)\n\nInitialize the Renewable Unit collection from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.initialize!-Tuple{IARA.ThermalUnit, PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.initialize!","text":"initialize!(thermal_unit::ThermalUnit, inputs)\n\nInitialize the Thermal Unit collection from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.initialize!-Tuple{IARA.VirtualReservoir, PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.initialize!","text":"initialize!(virtual_reservoir::VirtualReservoir, inputs::AbstractInputs)\n\nInitialize the VirtualReservoir collection from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.initialize!-Tuple{IARA.Zone, PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.initialize!","text":"initialize!(zone::Zone, inputs)\n\nInitialize the Zone collection from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.initialize_heuristic_bids_outputs-Tuple{IARA.Inputs, IARA.Outputs, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.initialize_heuristic_bids_outputs","text":"initialize_heuristic_bids_outputs(inputs::Inputs, outputs::Outputs, run_time_options::RunTimeOptions)\n\nInitialize the output files for bidding group energy and price bids.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.initialize_outputs-Tuple{IARA.Inputs, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.initialize_outputs","text":"initialize_outputs(inputs::Inputs, run_time_options::RunTimeOptions)\n\nInitialize the outputs struct.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.initialize_time_series_from_external_files-Tuple{Any}","page":"API Reference","title":"IARA.initialize_time_series_from_external_files","text":"initialize_time_series_from_external_files(inputs)\n\nInitialize the time series data from external files. This function reads the data from the files and stores it in the inputs struct.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.initialize_virtual_reservoir_bids_outputs-Tuple{IARA.Inputs, IARA.Outputs, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.initialize_virtual_reservoir_bids_outputs","text":"initialize_virtual_reservoir_bids_outputs(inputs::Inputs, outputs::Outputs, run_time_options::RunTimeOptions)\n\nInitialize the output files for virtual reservoir energy and price bids.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.initialize_virtual_reservoir_inflow_energy_arrival_output-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.initialize_virtual_reservoir_inflow_energy_arrival_output","text":"initialize_virtual_reservoir_inflow_energy_arrival_output(\n    outputs::Outputs,\n    inputs::Inputs,\n    run_time_options::RunTimeOptions,\n)\n\nInitialize the output file for virtual reservoir inflow energy arrival in the next period. This output is used in singleperiodheuristic_bid mode.\n\nWhen readexpostinflowfile is true, the output will have an additional subscenario dimension.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.integer_variable_representation-Tuple{PSRBridge.AbstractInputs, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.integer_variable_representation","text":"integer_variable_representation(inputs::Inputs, run_time_options)\n\nDetermine the integer variables representation.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.integer_variable_representation_ex_ante_commercial-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.integer_variable_representation_ex_ante_commercial","text":"integer_variable_representation_ex_ante_commercial(inputs::AbstractInputs)\n\nReturn the clearing integer variables type for ex-ante commercial.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.integer_variable_representation_ex_ante_physical-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.integer_variable_representation_ex_ante_physical","text":"integer_variable_representation_ex_ante_physical(inputs::AbstractInputs)\n\nReturn the clearing integer variables type for ex-ante physical.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.integer_variable_representation_ex_post_commercial-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.integer_variable_representation_ex_post_commercial","text":"integer_variable_representation_ex_post_commercial(inputs::AbstractInputs)\n\nReturn the clearing integer variables type for ex-post commercial.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.integer_variable_representation_ex_post_physical-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.integer_variable_representation_ex_post_physical","text":"integer_variable_representation_ex_post_physical(inputs::AbstractInputs)\n\nReturn the clearing integer variables type for ex-post physical.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.integer_variable_representation_mincost-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.integer_variable_representation_mincost","text":"integer_variable_representation_mincost(inputs::AbstractInputs)\n\nReturn the clearing integer variables type for mincost.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_capacity_from-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.interconnection_capacity_from","text":"interconnection_capacity_from(interconnection::AbstractCollection, i::Integer)\n\nGet the capacity_from field from the Interconnection collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_capacity_from-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.interconnection_capacity_from","text":"interconnection_capacity_from(collections::AbstractCollections, i::Integer)\n\nGet the capacity_from field from the Interconnection collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_capacity_from-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.interconnection_capacity_from","text":"interconnection_capacity_from(collections::AbstractCollections)\n\nGet the capacity_from field from the Interconnection collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_capacity_from-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.interconnection_capacity_from","text":"interconnection_capacity_from(interconnection::AbstractCollection)\n\nGet the capacity_from field from the Interconnection collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_capacity_from-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.interconnection_capacity_from","text":"interconnection_capacity_from(inputs::AbstractInputs, i::Integer)\n\nGet the capacity_from field from the Interconnection collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_capacity_from-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.interconnection_capacity_from","text":"interconnection_capacity_from(inputs::AbstractInputs)\n\nGet the capacity_from field from the Interconnection collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_capacity_to-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.interconnection_capacity_to","text":"interconnection_capacity_to(interconnection::AbstractCollection, i::Integer)\n\nGet the capacity_to field from the Interconnection collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_capacity_to-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.interconnection_capacity_to","text":"interconnection_capacity_to(collections::AbstractCollections, i::Integer)\n\nGet the capacity_to field from the Interconnection collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_capacity_to-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.interconnection_capacity_to","text":"interconnection_capacity_to(collections::AbstractCollections)\n\nGet the capacity_to field from the Interconnection collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_capacity_to-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.interconnection_capacity_to","text":"interconnection_capacity_to(interconnection::AbstractCollection)\n\nGet the capacity_to field from the Interconnection collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_capacity_to-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.interconnection_capacity_to","text":"interconnection_capacity_to(inputs::AbstractInputs, i::Integer)\n\nGet the capacity_to field from the Interconnection collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_capacity_to-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.interconnection_capacity_to","text":"interconnection_capacity_to(inputs::AbstractInputs)\n\nGet the capacity_to field from the Interconnection collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_existing-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.interconnection_existing","text":"interconnection_existing(interconnection::AbstractCollection, i::Integer)\n\nGet the existing field from the Interconnection collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_existing-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.interconnection_existing","text":"interconnection_existing(collections::AbstractCollections, i::Integer)\n\nGet the existing field from the Interconnection collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_existing-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.interconnection_existing","text":"interconnection_existing(collections::AbstractCollections)\n\nGet the existing field from the Interconnection collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_existing-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.interconnection_existing","text":"interconnection_existing(interconnection::AbstractCollection)\n\nGet the existing field from the Interconnection collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_existing-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.interconnection_existing","text":"interconnection_existing(inputs::AbstractInputs, i::Integer)\n\nGet the existing field from the Interconnection collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_existing-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.interconnection_existing","text":"interconnection_existing(inputs::AbstractInputs)\n\nGet the existing field from the Interconnection collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_flow!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, IARA.SimulationResultsFromPeriodScenario, Int64, Int64, Int64, Type{IARA.WriteOutput}}","page":"API Reference","title":"IARA.interconnection_flow!","text":"interconnection_flow!(outputs, inputs::Inputs, run_time_options::RunTimeOptions, simulation_results::SimulationResultsFromPeriodScenario, period::Int, scenario::Int, subscenario::Int, ::Type{WriteOutput})\n\nWrite the DC flow variables' values to the output file.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_flow!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.InitializeOutput}}","page":"API Reference","title":"IARA.interconnection_flow!","text":"interconnection_flow!(outputs::Outputs, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{InitializeOutput})\n\nInitialize output file to store the DC flow variables' values.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_flow!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.interconnection_flow!","text":"interconnection_flow!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the DC flow variables to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_label-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.interconnection_label","text":"interconnection_label(interconnection::AbstractCollection, i::Integer)\n\nGet the label field from the Interconnection collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_label-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.interconnection_label","text":"interconnection_label(collections::AbstractCollections, i::Integer)\n\nGet the label field from the Interconnection collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_label-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.interconnection_label","text":"interconnection_label(collections::AbstractCollections)\n\nGet the label field from the Interconnection collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_label-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.interconnection_label","text":"interconnection_label(interconnection::AbstractCollection)\n\nGet the label field from the Interconnection collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_label-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.interconnection_label","text":"interconnection_label(inputs::AbstractInputs, i::Integer)\n\nGet the label field from the Interconnection collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_label-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.interconnection_label","text":"interconnection_label(inputs::AbstractInputs)\n\nGet the label field from the Interconnection collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_zone_from-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.interconnection_zone_from","text":"interconnection_zone_from(interconnection::AbstractCollection, i::Integer)\n\nGet the zone_from field from the Interconnection collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_zone_from-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.interconnection_zone_from","text":"interconnection_zone_from(collections::AbstractCollections, i::Integer)\n\nGet the zone_from field from the Interconnection collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_zone_from-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.interconnection_zone_from","text":"interconnection_zone_from(collections::AbstractCollections)\n\nGet the zone_from field from the Interconnection collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_zone_from-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.interconnection_zone_from","text":"interconnection_zone_from(interconnection::AbstractCollection)\n\nGet the zone_from field from the Interconnection collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_zone_from-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.interconnection_zone_from","text":"interconnection_zone_from(inputs::AbstractInputs, i::Integer)\n\nGet the zone_from field from the Interconnection collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_zone_from-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.interconnection_zone_from","text":"interconnection_zone_from(inputs::AbstractInputs)\n\nGet the zone_from field from the Interconnection collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_zone_to-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.interconnection_zone_to","text":"interconnection_zone_to(interconnection::AbstractCollection, i::Integer)\n\nGet the zone_to field from the Interconnection collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_zone_to-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.interconnection_zone_to","text":"interconnection_zone_to(collections::AbstractCollections, i::Integer)\n\nGet the zone_to field from the Interconnection collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_zone_to-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.interconnection_zone_to","text":"interconnection_zone_to(collections::AbstractCollections)\n\nGet the zone_to field from the Interconnection collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_zone_to-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.interconnection_zone_to","text":"interconnection_zone_to(interconnection::AbstractCollection)\n\nGet the zone_to field from the Interconnection collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_zone_to-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.interconnection_zone_to","text":"interconnection_zone_to(inputs::AbstractInputs, i::Integer)\n\nGet the zone_to field from the Interconnection collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.interconnection_zone_to-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.interconnection_zone_to","text":"interconnection_zone_to(inputs::AbstractInputs)\n\nGet the zone_to field from the Interconnection collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.is_ac-Tuple{IARA.Branch, Int64}","page":"API Reference","title":"IARA.is_ac","text":"is_ac(b::Branch, i::Int)\n\nCheck if the Branch at index 'i' is modeled as an AC Line.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.is_associated_with_some_virtual_reservoir-Tuple{IARA.HydroUnit, Int64}","page":"API Reference","title":"IARA.is_associated_with_some_virtual_reservoir","text":"is_associated_with_some_virtual_reservoir(hydro_unit::HydroUnit, idx::Int)\n\nCheck if the Hydro Unit at index 'idx' is associated with some virtual reservoir.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.is_branch_modeled_as_dc_line-Tuple{PSRBridge.AbstractInputs, Int64}","page":"API Reference","title":"IARA.is_branch_modeled_as_dc_line","text":"is_branch_modeled_as_dc_line(inputs::AbstractInputs, idx::Int)\n\nCheck if the Branch at index 'idx' is modeled as a DC Line.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.is_commercial_problem-Tuple{IARA.RunTimeOptions}","page":"API Reference","title":"IARA.is_commercial_problem","text":"is_commercial_problem(run_time_options::RunTimeOptions)\n\nCheck if the problem is commercial.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.is_dc-Tuple{IARA.Branch, Int64}","page":"API Reference","title":"IARA.is_dc","text":"is_dc(b::Branch, i::Int)\n\nCheck if the Branch at index 'i' is modeled as a DC Line.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.is_elastic-Tuple{IARA.DemandUnit, Int64}","page":"API Reference","title":"IARA.is_elastic","text":"is_elastic(d::DemandUnit, i::Int)\n\nReturn true if the Demand in position 'i' is IARA.DemandUnit_DemandType.ELASTIC.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.is_ex_ante_problem-Tuple{IARA.RunTimeOptions}","page":"API Reference","title":"IARA.is_ex_ante_problem","text":"is_ex_ante_problem(run_time_options::RunTimeOptions)\n\nCheck if the problem is ex-ante.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.is_ex_post_problem-Tuple{IARA.RunTimeOptions}","page":"API Reference","title":"IARA.is_ex_post_problem","text":"is_ex_post_problem(run_time_options::RunTimeOptions)\n\nCheck if the problem is ex-post.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.is_flexible-Tuple{IARA.DemandUnit, Int64}","page":"API Reference","title":"IARA.is_flexible","text":"is_flexible(d::DemandUnit, i::Int)\n\nReturn true if the Demand in position 'i' is IARA.DemandUnit_DemandType.FLEXIBLE.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.is_inelastic-Tuple{IARA.DemandUnit, Int64}","page":"API Reference","title":"IARA.is_inelastic","text":"is_inelastic(d::DemandUnit, i::Int)\n\nReturn true if the Demand in position 'i' is IARA.DemandUnit_DemandType.INELASTIC.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.is_market_clearing-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.is_market_clearing","text":"is_market_clearing(inputs::AbstractInputs)\n\nReturn whether the run mode is MARKETCLEARING or SINGLEPERIODMARKETCLEARING.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.is_physical_problem-Tuple{IARA.RunTimeOptions}","page":"API Reference","title":"IARA.is_physical_problem","text":"is_physical_problem(run_time_options::RunTimeOptions)\n\nCheck if the problem is physical.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.is_single_period-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.is_single_period","text":"is_single_period(inputs::AbstractInputs)\n\nReturn whether the run mode is SINGLEPERIODMARKETCLEARING or SINGLEPERIODHEURISTICBID.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.iterate_nash_equilibrium-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.iterate_nash_equilibrium","text":"iterate_nash_equilibrium(inputs::AbstractInputs)\n\nReturn whether the Nash equilibrium should be calculated.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.kirchhoffs_voltage_law!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.kirchhoffs_voltage_law!","text":"kirchhoffs_voltage_law!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the Kirchhoff's Voltage Law constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.language-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.language","text":"language(inputs::AbstractInputs)\n\nReturn the language of the case.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.linear_policy_graph-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.linear_policy_graph","text":"linear_policy_graph(inputs::AbstractInputs)\n\nReturn whether the policy graph is linear.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.link_bids_and_generation!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.link_bids_and_generation!","text":"link_bids_and_generation!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the link between bids and generation constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.link_time_series_to_file-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.link_time_series_to_file","text":"link_time_series_to_file(db::DatabaseSQLite, table_name::String; kwargs...)\n\nLinks a time series to a file in the database.\n\nEach collection in the database can be linked to different time series files.\n\nThe possible files for each collection are:\n\nCollection: Configuration\n\nhour_subperiod_map::String: Mapping of hours to subperiods\n\nfcf_cuts::String: FCF cuts for the model, it's a file read from SDDP.jl in JSON format\n\nperiod_season_map::String: Mapping of periods to seasons\n\nCollection: RenewableUnit\n\ngeneration_ex_ante::String: Realized generation for the model in ex-ante, also used in the min cost module [p.u.]\n\ngeneration_ex_post::String: Realized generation for the model in ex-post [p.u.]\n\nCollection: HydroUnit\n\ninflow_ex_ante::String: Inflow data for the model in ex-ante [m³/s]\n\ninflow_ex_post::String: Inflow data for the model in ex-post [m³/s]\n\ninitial_volume_by_scenario::String\n\nCollection: GaugingStation\n\ninflow_initial_state_by_scenario::String\n\nparp_coefficients::String\n\ninflow_period_average::String\n\ninflow_period_std_dev::String\n\ninflow_noise_ex_ante::String\n\ninflow_noise_ex_post::String\n\nCollection: BiddingGroup\n\nquantity_bid::String: Quantity of bids for independent segement bids [GWh]\n\nprice_bid::String: Price of bids for independent segement bids [$/MWh]\n\nquantity_bid_profile::String: Quantity of bids for profile bids [GWh]\n\nprice_bid_profile::String: Price of bids for profile bids [$/MWh]\n\nparent_profile::String: Parent profile of this bid profile\n\ncomplementary_grouping_profile::String: Complementary grouping for the asset owner's profile bids\n\nminimum_activation_level_profile::String: Minimum activation level of profile\n\nbid_price_limit_justified_independent::String\n\nbid_price_limit_non_justified_independent::String\n\nbid_price_limit_justified_profile::String\n\nbid_price_limit_non_justified_profile::String\n\nbid_justifications::String\n\nCollection: VirtualReservoir\n\nquantity_bid::String: Quantity of bids for virtual reservoirs [MWh]\n\nprice_bid::String: Price of bids for virtual reservoirs [$/MWh]\n\nCollection: DemandUnit\n\nelastic_demand_price::String: Elastic demand price data [$/MWh]\n\ndemand_window::String: Window available for shifting the elastic demand [h]\n\ndemand_ex_ante::String: Demand data for the model in ex-ante, also used in the min cost module [p.u.]\n\ndemand_ex_post::String: Demand data for the model in ex-post [p.u.]\n\nFor more information about these files, please refer to the Input Files documentation.\n\nExample:\n\nIARA.link_time_series_to_file(\n    db,\n    \"RenewableUnit\";\n    generation_ex_ante = \"solar_generation\",\n)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.load_balance!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, IARA.SimulationResultsFromPeriodScenario, Int64, Int64, Int64, Type{IARA.WriteOutput}}","page":"API Reference","title":"IARA.load_balance!","text":"load_balance!(outputs, inputs::Inputs, run_time_options::RunTimeOptions, simulation_results::SimulationResultsFromPeriodScenario, period::Int, scenario::Int, subscenario::Int, ::Type{WriteOutput})\n\nWrite the load marginal cost output.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.load_balance!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.InitializeOutput}}","page":"API Reference","title":"IARA.load_balance!","text":"load_balance!(outputs, inputs, run_time_options, ::Type{InitializeOutput})\n\nInitialize the output files for:\n\nload_marginal_cost\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.load_balance!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.load_balance!","text":"load_balance!(\n    model::SubproblemModel, \n    inputs::Inputs, \n    run_time_options::RunTimeOptions, \n    ::Type{SubproblemBuild}\n)\n\nAdd the load balance constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.load_cuts_and_run_simulation-Tuple{IARA.Inputs, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.load_cuts_and_run_simulation","text":"load_cuts_and_run_simulation(inputs::Inputs, run_time_options::RunTimeOptions)\n\nLoad the cuts and run the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.load_inputs-Tuple{IARA.Args}","page":"API Reference","title":"IARA.load_inputs","text":"load_inputs(args::Args)\n\nInitialize the inputs from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.load_study-Tuple{String}","page":"API Reference","title":"IARA.load_study","text":"load_study(case_path::String; read_only::Bool = true)\n\nOpen the database file and return a database object.\n\nRequired arguments:\n\ncase_path::String: Path to the case folder.\nread_only::Bool: Whether the database should be opened in read-only mode. Default is true.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.lp_filename-Tuple{IARA.Inputs, IARA.RunTimeOptions, Integer, Integer, Integer}","page":"API Reference","title":"IARA.lp_filename","text":"lp_filename(inputs::Inputs, run_time_options::RunTimeOptions, t::Integer, scen::Integer, subscenario::Integer)\n\nReturn the filename to write the lp file.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.market_clearing-Tuple{String}","page":"API Reference","title":"IARA.market_clearing","text":"market_clearing(path::String; kwargs...)\n\nRun the model with the market clearing strategy.\n\nkeywords:\n\noutputs_path::String. Path to the outputs. default = joinpath(path, \"outputs\")\nplot_outputs::Bool. Plot all outputs after the run. default = true\nwrite_lp::Bool. Write the LP files. default = false\ndelete_output_folder_before_execution::Bool. Delete the output folder before execution. default = false\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.market_clearing_model_action-Tuple","page":"API Reference","title":"IARA.market_clearing_model_action","text":"market_clearing_model_action(args...)\n\nMarket clearing model action.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.market_clearing_tiebreaker_weight_for_om_costs-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.market_clearing_tiebreaker_weight_for_om_costs","text":"market_clearing_tiebreaker_weight_for_om_costs(inputs::AbstractInputs)\n\nReturn the market clearing tiebreaker weight applied to physical generation costs.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.max_iteration_nash_equilibrium-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.max_iteration_nash_equilibrium","text":"max_iteration_nash_equilibrium(inputs::AbstractInputs)\n\nReturn the maximum number of iterations for the Nash equilibrium.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.max_rev_equilibrium_bid_initialization-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.max_rev_equilibrium_bid_initialization","text":"max_rev_equilibrium_bid_initialization(inputs::AbstractInputs)\n\nReturn the maximum revenue equilibrium bid initialization strategy.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.max_rev_equilibrium_bus_aggregation_type-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.max_rev_equilibrium_bus_aggregation_type","text":"max_rev_equilibrium_bus_aggregation_type(inputs::AbstractInputs)\n\nReturn the maximum revenue equilibrium bus aggregation type.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.merge_period_subperiod","page":"API Reference","title":"IARA.merge_period_subperiod","text":"merge_period_subperiod(data::Array{T, N}) where {T <: AbstractFloat, N}\n\nReduce the dimension of the data array by merging the period and subperiod dimensions.\n\n\n\n\n\n","category":"function"},{"location":"api_reference.html#IARA.merge_scenario_agent","page":"API Reference","title":"IARA.merge_scenario_agent","text":"merge_scenario_agent(::Type{<:PlotType}, data::Array{<:AbstractFloat, N}, agent_names::Vector{String}, scenario_names::Union{Vector{String}, Nothing}; kwargs...) where {N}\n\nReduce the dimension of the data array by merging the scenario and agent dimensions.\n\n\n\n\n\n","category":"function"},{"location":"api_reference.html#IARA.merge_scenario_subscenario","page":"API Reference","title":"IARA.merge_scenario_subscenario","text":"merge_scenario_subscenario(data::Array{<:AbstractFloat, N}, agent_names::Vector{String}; kwargs...) where {N}\n\nReduce the dimension of the data array by merging the scenario and subscenario dimensions.\n\n\n\n\n\n","category":"function"},{"location":"api_reference.html#IARA.merge_scenario_subscenario_agent","page":"API Reference","title":"IARA.merge_scenario_subscenario_agent","text":"merge_scenario_subscenario_agent(data::Array{<:AbstractFloat, N}, agent_names::Vector{String}; kwargs...) where {N}\n\nReduce the dimension of the data array by merging the scenario, subscenario, and agent dimensions.\n\n\n\n\n\n","category":"function"},{"location":"api_reference.html#IARA.merge_segment_agent","page":"API Reference","title":"IARA.merge_segment_agent","text":"merge_segment_agent(data::Array{<:AbstractFloat, N}, agent_names::Vector{String}; kwargs...) where {N}\n\nReduce the dimension of the data array by merging the segment and agent dimensions.\n\n\n\n\n\n","category":"function"},{"location":"api_reference.html#IARA.migrations_directory-Tuple{}","page":"API Reference","title":"IARA.migrations_directory","text":"migrations_directory()\n\nReturn the path to the migration directory.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.min_cost-Tuple{String}","page":"API Reference","title":"IARA.min_cost","text":"min_cost(path::String; kwargs...)\n\nRun the model with the minimum cost strategy.\n\nkeywords:\n\noutputs_path::String. Path to the outputs. default = joinpath(path, \"outputs\")\nplot_outputs::Bool. Plot all outputs after the run. default = true\nwrite_lp::Bool. Write the LP files. default = false\ndelete_output_folder_before_execution::Bool. Delete the output folder before execution. default = false\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.model_action-Tuple","page":"API Reference","title":"IARA.model_action","text":"model_action(args...)\n\nDispatch the model action based on the run mode and the action type.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.model_directory-Tuple{}","page":"API Reference","title":"IARA.model_directory","text":"model_directory()\n\nReturn the path to the model directory.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.must_read_hydro_unit_data_for_markup_wizard-Tuple{IARA.Inputs}","page":"API Reference","title":"IARA.must_read_hydro_unit_data_for_markup_wizard","text":"must_read_hydro_unit_data_for_markup_wizard(inputs::Inputs)\n\nThis function returns true when the following conditions are met:\n\nThe run mode is not TRAINMINCOST\nThere is at least one hydro unit that is associated with a bidding group\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.nash_equilibrium_iteration-Tuple{PSRBridge.AbstractInputs, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.nash_equilibrium_iteration","text":"nash_equilibrium_iteration(inputs::AbstractInputs, run_time_options::RunTimeOptions)\n\nReturn the Nash equilibrium iteration.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.network_representation-Tuple{PSRBridge.AbstractInputs, Any}","page":"API Reference","title":"IARA.network_representation","text":"network_representation(inputs::Inputs, run_time_options)\n\nDetermine the network representation.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.network_representation_ex_ante_commercial-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.network_representation_ex_ante_commercial","text":"network_representation_ex_ante_commercial(inputs::AbstractInputs)\n\nReturn the network representation for the ex-ante commercial model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.network_representation_ex_ante_physical-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.network_representation_ex_ante_physical","text":"network_representation_ex_ante_physical(inputs::AbstractInputs)\n\nReturn the network representation for the ex-ante physical model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.network_representation_ex_post_commercial-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.network_representation_ex_post_commercial","text":"network_representation_ex_post_commercial(inputs::AbstractInputs)\n\nReturn the network representation for the ex-post commercial model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.network_representation_ex_post_physical-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.network_representation_ex_post_physical","text":"network_representation_ex_post_physical(inputs::AbstractInputs)\n\nReturn the network representation for the ex-post physical model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.network_representation_mincost-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.network_representation_mincost","text":"network_representation_mincost(inputs::AbstractInputs)\n\nReturn the network representation for the mincost model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.node_repetition_probability-Tuple{IARA.Inputs}","page":"API Reference","title":"IARA.node_repetition_probability","text":"node_repetition_probability(inputs::Inputs)\n\nReturns the probability that the problem repeats a node after solving it's subproblem.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.node_termination_probability-Tuple{IARA.Inputs}","page":"API Reference","title":"IARA.node_termination_probability","text":"node_termination_probability(inputs::Inputs)\n\nReturns the probability that the problem finishes after solving a node's subproblem.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.nodes-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.nodes","text":"nodes(inputs::AbstractInputs)\n\nReturn all nodes in the SDDP policy graph, except for the root node.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.normalized_inflow_from_previous_period-Tuple{PSRBridge.AbstractInputs, Any, Int64, Int64}","page":"API Reference","title":"IARA.normalized_inflow_from_previous_period","text":"normalized_inflow_from_previous_period(inputs::AbstractInputs, run_time_options, period::Int, scenario::Int)\n\nGet the normalized inflow state variables from the previous period for PAR(p) model.\n\nIf the period is the first one, the initial state is returned. Otherwise, it is read from the serialized results of the previous stage.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.number_of_flexible_demand_windows-Tuple{PSRBridge.AbstractInputs, Int64}","page":"API Reference","title":"IARA.number_of_flexible_demand_windows","text":"number_of_flexible_demand_windows(inputs::AbstractInputs, idx::Int)\n\nReturn the number of windows for the flexible Demand in position 'idx'.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.number_of_nodes-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.number_of_nodes","text":"number_of_nodes(inputs::AbstractInputs)\n\nReturn the number of nodes in the SDDP policy graph.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.number_of_periods-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.number_of_periods","text":"number_of_periods(inputs::AbstractInputs)\n\nReturn the number of periods in the problem.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.number_of_scenarios-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.number_of_scenarios","text":"number_of_scenarios(inputs::AbstractInputs)\n\nReturn the number of scenarios in the problem.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.number_of_subperiods-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.number_of_subperiods","text":"number_of_subperiods(inputs::AbstractInputs)\n\nReturn the number of subperiods in the problem.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.number_of_subscenarios-Tuple{PSRBridge.AbstractInputs, Any}","page":"API Reference","title":"IARA.number_of_subscenarios","text":"number_of_subscenarios(inputs::AbstractInputs, run_time_options)\n\nReturn the number of subscenarios to simulate.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.operates_as_run_of_river-Tuple{IARA.HydroUnit, Int64}","page":"API Reference","title":"IARA.operates_as_run_of_river","text":"operates_as_run_of_river(hydro_unit::HydroUnit, idx::Int)\n\nCheck if the Hydro Unit at index 'idx' operates as run of river.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.operates_with_reservoir-Tuple{IARA.HydroUnit, Int64}","page":"API Reference","title":"IARA.operates_with_reservoir","text":"operates_with_reservoir(hydro_unit::HydroUnit, idx::Int)\n\nCheck if the Hydro Unit at index 'idx' operates with reservoir.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.output_path-Tuple{IARA.Inputs}","page":"API Reference","title":"IARA.output_path","text":"output_path(inputs::Inputs)\n\nReturn the path to the outputs directory.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.parp!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.parp!","text":"parp!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the PAR(p) constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.parp_max_lags-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.parp_max_lags","text":"parp_max_lags(inputs::AbstractInputs)\n\nReturn the maximum number of lags in the PAR(p) model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.path_case-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.path_case","text":"path_case(inputs::AbstractInputs)\n\nReturn the path to the case.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.path_case-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite}","page":"API Reference","title":"IARA.path_case","text":"path_case(db::DatabaseSQLite)\n\nReturn the path to the case.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.path_parp-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.path_parp","text":"path_parp(inputs::AbstractInputs)\n\nReturn the path to the PAR(p) model files.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.period_discount_rate-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.period_discount_rate","text":"period_discount_rate(inputs::AbstractInputs)\n\nReturn the discount rate per period.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.period_season_map_cache-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.period_season_map_cache","text":"period_season_map(inputs::AbstractInputs)\n\nReturn the period to season map.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.period_season_map_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.period_season_map_file","text":"period_season_map_file(inputs::AbstractInputs)\n\nReturn the file with the period to season map.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.period_season_map_from_file-Tuple{Any}","page":"API Reference","title":"IARA.period_season_map_from_file","text":"period_season_map(inputs)\n\nReturn a 3-element vector with the current season, sample and next_subscenario given the current period and scenario.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.periods-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.periods","text":"periods(inputs::AbstractInputs)\n\nReturn all problem periods.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.periods_per_year-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.periods_per_year","text":"periods_per_year(inputs::AbstractInputs)\n\nReturn the number of periods per year.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.plot_data","page":"API Reference","title":"IARA.plot_data","text":"plot_data(::Type{<:PlotType}, data::Array{<:AbstractFloat, N}, agent_names::Vector{String}, dimensions::Vector{String}; kwargs...)\n\nPlot the data for a specific plot type.\n\n\n\n\n\n","category":"function"},{"location":"api_reference.html#IARA.plot_data-Union{Tuple{N}, Tuple{Type{IARA.PlotTechnologyHistogramPeriodSubperiod}, Array{<:AbstractFloat, N}, Vector{String}, Vector{String}}} where N","page":"API Reference","title":"IARA.plot_data","text":"plot_data(\n    ::Type{PlotTechnologyHistogramPeriodSubperiod},\n    data::Array{<:AbstractFloat, N},\n    agent_names::Vector{String},\n    dimensions::Vector{String};\n    title::String,\n    unit::String,\n    file_path::String,\n    kwargs...,\n) where {N}\n\nPlots a histogram where the observations are the total of generation for a technology at subperiod i, period j, considering all scenarios.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.plot_data-Union{Tuple{N}, Tuple{Type{IARA.PlotTechnologyHistogramPeriod}, Array{<:AbstractFloat, N}, Vector{String}, Vector{String}}} where N","page":"API Reference","title":"IARA.plot_data","text":"plot_data(::Type{PlotTechnologyHistogramPeriod}, data::Array{<:AbstractFloat, N}, agent_names::Vector{String}, dimensions::Vector{String}; title::String = \"\", unit::String = \"\", file_path::String, kwargs...)\n\nCreate a histogram plot for the total of generation for a technology at period i, considering all scenarios and subperiods.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.plot_data-Union{Tuple{N}, Tuple{Type{IARA.PlotTechnologyHistogramSubperiod}, Array{<:AbstractFloat, N}, Vector{String}, Vector{String}}} where N","page":"API Reference","title":"IARA.plot_data","text":"plot_data(::Type{PlotTechnologyHistogramSubperiod}, data::Array{AbstractFloat, N}, agent_names::Vector{String}, dimensions::Vector{String}; title::String = \"\", unit::String = \"\", file_path::String, kwargs...)\n\nCreate a histogram plot for the total of generation for a technology at subperiod i, considering all scenarios and periods.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.plot_data-Union{Tuple{N}, Tuple{Type{IARA.PlotTechnologyHistogram}, Array{<:AbstractFloat, N}, Vector{String}, Vector{String}}} where N","page":"API Reference","title":"IARA.plot_data","text":"plot_data(::Type{PlotTechnologyHistogram}, data::Array{<:AbstractFloat, N}, agent_names::Vector{String}, dimensions::Vector{String}; title::String = \"\", unit::String = \"\", file_path::String, kwargs...)\n\nCreate a histogram plot for the total of generation for a technology, considering all scenarios, periods and subperiods.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.plot_data-Union{Tuple{N}, Tuple{Type{IARA.PlotTimeSeriesAll}, Array{<:AbstractFloat, N}, Vector{String}, Vector{String}}} where N","page":"API Reference","title":"IARA.plot_data","text":"plot_data(::Type{PlotTimeSeriesAll}, data::Array{<:AbstractFloat, N}, agent_names::Vector{String}, dimensions::Vector{String}; title::String = \"\", unit::String = \"\", file_path::String, initial_date::DateTime, time_series_step::Configurations_TimeSeriesStep.T, kwargs...)\n\nCreate a time series plot with all scenarios.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.plot_data-Union{Tuple{N}, Tuple{Type{IARA.PlotTimeSeriesQuantiles}, Array{<:AbstractFloat, N}, Vector{String}, Vector{String}}} where N","page":"API Reference","title":"IARA.plot_data","text":"plot_data(::Type{PlotTimeSeriesQuantiles}, data::Array{<:AbstractFloat, N}, agent_names::Vector{String}, dimensions::Vector{String}; title::String = \"\", unit::String = \"\", file_path::String, initial_date::DateTime, time_series_step::Configurations_TimeSeriesStep.T, kwargs...)\n\nCreate a time series plot with P10, P50, and P90 quantiles of scenarios.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.plot_data-Union{Tuple{N}, Tuple{Type{IARA.PlotTimeSeriesStackedMean}, Array{<:AbstractFloat, N}, Vector{String}, Vector{String}}} where N","page":"API Reference","title":"IARA.plot_data","text":"plot_data(::Type{PlotTimeSeriesStackedMean}, data::Array{<:AbstractFloat, N}, agent_names::Vector{String}, dimensions::Vector{String}; title::String = \"\", unit::String = \"\", file_path::String, initial_date::DateTime, time_series_step::Configurations_TimeSeriesStep.T, kwargs...)\n\nCreate a time series plot with the mean of scenarios with all agents stacked.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.policy_graph_type-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.policy_graph_type","text":"policy_graph_type(inputs::AbstractInputs)\n\nReturn the policy graph type.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.post_processing-Tuple{IARA.Inputs}","page":"API Reference","title":"IARA.post_processing","text":"post_processing(inputs::Inputs)\n\nRun post-processing routines.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.post_processing_bidding_group_revenue-Tuple{IARA.Inputs, IARA.Outputs, IARA.OutputReaders, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.post_processing_bidding_group_revenue","text":"post_processing_bidding_group_revenue(inputs::Inputs, outputs_post_processing::Outputs, model_outputs_time_serie::OutputReaders, run_time_options::RunTimeOptions)\n\nPost-process the bidding group revenue data, based on the generation data and the marginal cost data.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.post_processing_bidding_group_total_revenue-Tuple{IARA.Inputs, IARA.Outputs, IARA.OutputReaders, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.post_processing_bidding_group_total_revenue","text":"post_processing_bidding_group_total_revenue(inputs::Inputs, outputs_post_processing::Outputs, model_outputs_time_serie::OutputReaders, run_time_options::RunTimeOptions)\n\nPost-process the total revenue data, based on the ex-ante and ex-post revenue data.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.post_processing_generation-Tuple{IARA.Inputs, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.post_processing_generation","text":"post_processing_generation(inputs::Inputs, run_time_options::RunTimeOptions)\n\nRun post-processing routines for generation.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.price_maker_bid_model_action-Tuple","page":"API Reference","title":"IARA.price_maker_bid_model_action","text":"price_maker_bid_model_action(args...)\n\nStrategic bid model action.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.price_taker_bid_model_action-Tuple","page":"API Reference","title":"IARA.price_taker_bid_model_action","text":"price_taker_bid_model_action(args...)\n\nPrice taker bid model action.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.profile_min_activation_level!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.InitializeOutput}}","page":"API Reference","title":"IARA.profile_min_activation_level!","text":"profile_min_activation_level!(outputs::Outputs, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{InitializeOutput})\n\nAdds symbols to serialize and query the profile minimum activation level variables.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.profile_min_activation_level!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Int64, Int64, Int64, Int64, Type{IARA.SubproblemUpdate}}","page":"API Reference","title":"IARA.profile_min_activation_level!","text":"profile_min_activation_level!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, scenario, subscenario, ::Type{SubproblemUpdate})\n\nUpdates the profile minimum activation level variables in the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.profile_min_activation_level!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.profile_min_activation_level!","text":"profile_min_activation_level!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the profile minimum activation level variables to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.read_bids_from_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.read_bids_from_file","text":"read_bids_from_file(inputs::AbstractInputs)\n\nReturn whether bids should be read from a file.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.read_cuts_into_clearing_model!-Tuple{IARA.ProblemModel, IARA.Inputs, IARA.RunTimeOptions, Int64}","page":"API Reference","title":"IARA.read_cuts_into_clearing_model!","text":"read_cuts_into_clearing_model!(\n    model::ProblemModel, \n    inputs::Inputs, \n    run_time_options::RunTimeOptions, \n    period::Int\n)\n\nCheck if the clearing representation must read cuts. If so, it reads them.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.read_ex_ante_demand_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.read_ex_ante_demand_file","text":"read_ex_ante_demand_file(inputs::AbstractInputs)\n\nReturn whether the ex-ante demand file should be read.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.read_ex_ante_file-Tuple{IARA.Configurations_UncertaintyScenariosFiles.T}","page":"API Reference","title":"IARA.read_ex_ante_file","text":"read_ex_ante_file(files_to_read::Configurations_UncertaintyScenariosFiles.T)\n\nReturn whether the ex-ante file should be read.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.read_ex_ante_inflow_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.read_ex_ante_inflow_file","text":"read_ex_ante_inflow_file(inputs::AbstractInputs)\n\nReturn whether the ex-ante inflow file should be read.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.read_ex_ante_renewable_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.read_ex_ante_renewable_file","text":"read_ex_ante_renewable_file(inputs::AbstractInputs)\n\nReturn whether the ex-ante renewable file should be read.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.read_ex_post_demand_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.read_ex_post_demand_file","text":"read_ex_post_demand_file(inputs::AbstractInputs)\n\nReturn whether the ex-ante demand file should be read.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.read_ex_post_file-Tuple{IARA.Configurations_UncertaintyScenariosFiles.T}","page":"API Reference","title":"IARA.read_ex_post_file","text":"read_ex_post_file(files_to_read::Configurations_UncertaintyScenariosFiles.T)\n\nReturn whether the ex-post file should be read.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.read_ex_post_inflow_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.read_ex_post_inflow_file","text":"read_ex_post_inflow_file(inputs::AbstractInputs)\n\nReturn whether the ex-ante inflow file should be read.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.read_ex_post_renewable_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.read_ex_post_renewable_file","text":"read_ex_post_renewable_file(inputs::AbstractInputs)\n\nReturn whether the ex-ante renewable file should be read.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.read_inflow_from_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.read_inflow_from_file","text":"read_inflow_from_file(inputs::AbstractInputs)\n\nReturn whether inflow should be read from a file.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.read_parp_coefficients-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.read_parp_coefficients","text":"read_parp_coefficients(inputs::AbstractInputs)\n\nReturn whether the PAR(p) coefficients should be read from files.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.read_serialized_bid_price_limits-Tuple{IARA.Inputs}","page":"API Reference","title":"IARA.read_serialized_bid_price_limits","text":"read_serialized_bid_price_limits(inputs::Inputs; period::Int, scenario::Int)\n\nRead serialized bid price limits.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.read_serialized_clearing_variable-Tuple{IARA.Inputs, IARA.RunTime_ClearingSubproblem.T, Symbol}","page":"API Reference","title":"IARA.read_serialized_clearing_variable","text":"read_serialized_clearing_variable(inputs::Inputs, clearing_model_subproblem::RunTime_ClearingSubproblem.T, symbol_to_read::Symbol; period::Int, scenario::Int)\n\nRead serialized clearing variable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.read_serialized_heuristic_bids-Tuple{IARA.Inputs}","page":"API Reference","title":"IARA.read_serialized_heuristic_bids","text":"read_serialized_heuristic_bids(inputs::Inputs; period::Int, scenario::Int)\n\nRead serialized heuristic bids.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.read_serialized_virtual_reservoir_heuristic_bids-Tuple{IARA.Inputs}","page":"API Reference","title":"IARA.read_serialized_virtual_reservoir_heuristic_bids","text":"read_serialized_virtual_reservoir_heuristic_bids(inputs::Inputs; period::Int, scenario::Int)\n\nRead serialized virtual reservoir heuristic bids.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.read_timeseries_file-Tuple{String}","page":"API Reference","title":"IARA.read_timeseries_file","text":"read_time_series_file(file_path::String)\n\nRead a time series file, in either .csv or .quiv format.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.read_timeseries_file_in_outputs-Tuple{Any, Any}","page":"API Reference","title":"IARA.read_timeseries_file_in_outputs","text":"read_timeseries_file_in_outputs(filename::String, inputs::Inputs)\n\nRead a timeseries file in the outputs directory.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.reference_curve_final_segment_price_markup-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.reference_curve_final_segment_price_markup","text":"reference_curve_final_segment_price_markup(inputs::AbstractInputs)\n\nReturn the final segment price markup for the reference curve.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.reference_curve_number_of_segments-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.reference_curve_number_of_segments","text":"reference_curve_number_of_segments(inputs::AbstractInputs)\n\nReturn the number of segments in the reference curve.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_balance!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.renewable_balance!","text":"renewable_balance!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the renewable unit balance constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_generation!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, IARA.SimulationResultsFromPeriodScenario, Int64, Int64, Int64, Type{IARA.WriteOutput}}","page":"API Reference","title":"IARA.renewable_generation!","text":"renewable_generation!(outputs, inputs::Inputs, run_time_options::RunTimeOptions, simulation_results::SimulationResultsFromPeriodScenario, period::Int, scenario::Int, subscenario::Int, ::Type{WriteOutput})\n\nWrite the renewable generation and curtailment variables' values to the output.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_generation!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.InitializeOutput}}","page":"API Reference","title":"IARA.renewable_generation!","text":"renewable_generation!(outputs::Outputs, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{InitializeOutput})\n\nInitialize the output files for\n\nrenewable generation\nrenewable curtailment\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_generation!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Int64, Int64, Int64, Int64, Type{IARA.SubproblemUpdate}}","page":"API Reference","title":"IARA.renewable_generation!","text":"renewable_generation!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemUpdate})\n\nUpdates the renewable generation variables in the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_generation!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.renewable_generation!","text":"renewable_generation!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the renewable unit generation variables to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_scenarios_files-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.renewable_scenarios_files","text":"renewable_scenarios_files(inputs::AbstractInputs)\n\nReturn which renewable scenarios files should be read.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_bidding_group_index-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.renewable_unit_bidding_group_index","text":"renewable_unit_bidding_group_index(renewable_unit::AbstractCollection, i::Integer)\n\nGet the biddinggroupindex field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_bidding_group_index-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.renewable_unit_bidding_group_index","text":"renewable_unit_bidding_group_index(collections::AbstractCollections, i::Integer)\n\nGet the biddinggroupindex field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_bidding_group_index-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.renewable_unit_bidding_group_index","text":"renewable_unit_bidding_group_index(collections::AbstractCollections)\n\nGet the bidding_group_index field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_bidding_group_index-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.renewable_unit_bidding_group_index","text":"renewable_unit_bidding_group_index(renewable_unit::AbstractCollection)\n\nGet the bidding_group_index field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_bidding_group_index-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.renewable_unit_bidding_group_index","text":"renewable_unit_bidding_group_index(inputs::AbstractInputs, i::Integer)\n\nGet the biddinggroupindex field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_bidding_group_index-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.renewable_unit_bidding_group_index","text":"renewable_unit_bidding_group_index(inputs::AbstractInputs)\n\nGet the bidding_group_index field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_bus_index-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.renewable_unit_bus_index","text":"renewable_unit_bus_index(renewable_unit::AbstractCollection, i::Integer)\n\nGet the bus_index field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_bus_index-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.renewable_unit_bus_index","text":"renewable_unit_bus_index(collections::AbstractCollections, i::Integer)\n\nGet the bus_index field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_bus_index-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.renewable_unit_bus_index","text":"renewable_unit_bus_index(collections::AbstractCollections)\n\nGet the bus_index field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_bus_index-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.renewable_unit_bus_index","text":"renewable_unit_bus_index(renewable_unit::AbstractCollection)\n\nGet the bus_index field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_bus_index-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.renewable_unit_bus_index","text":"renewable_unit_bus_index(inputs::AbstractInputs, i::Integer)\n\nGet the bus_index field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_bus_index-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.renewable_unit_bus_index","text":"renewable_unit_bus_index(inputs::AbstractInputs)\n\nGet the bus_index field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_curtailment_cost-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.renewable_unit_curtailment_cost","text":"renewable_unit_curtailment_cost(renewable_unit::AbstractCollection, i::Integer)\n\nGet the curtailment_cost field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_curtailment_cost-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.renewable_unit_curtailment_cost","text":"renewable_unit_curtailment_cost(collections::AbstractCollections, i::Integer)\n\nGet the curtailment_cost field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_curtailment_cost-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.renewable_unit_curtailment_cost","text":"renewable_unit_curtailment_cost(collections::AbstractCollections)\n\nGet the curtailment_cost field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_curtailment_cost-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.renewable_unit_curtailment_cost","text":"renewable_unit_curtailment_cost(renewable_unit::AbstractCollection)\n\nGet the curtailment_cost field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_curtailment_cost-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.renewable_unit_curtailment_cost","text":"renewable_unit_curtailment_cost(inputs::AbstractInputs, i::Integer)\n\nGet the curtailment_cost field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_curtailment_cost-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.renewable_unit_curtailment_cost","text":"renewable_unit_curtailment_cost(inputs::AbstractInputs)\n\nGet the curtailment_cost field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_existing-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.renewable_unit_existing","text":"renewable_unit_existing(renewable_unit::AbstractCollection, i::Integer)\n\nGet the existing field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_existing-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.renewable_unit_existing","text":"renewable_unit_existing(collections::AbstractCollections, i::Integer)\n\nGet the existing field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_existing-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.renewable_unit_existing","text":"renewable_unit_existing(collections::AbstractCollections)\n\nGet the existing field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_existing-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.renewable_unit_existing","text":"renewable_unit_existing(renewable_unit::AbstractCollection)\n\nGet the existing field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_existing-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.renewable_unit_existing","text":"renewable_unit_existing(inputs::AbstractInputs, i::Integer)\n\nGet the existing field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_existing-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.renewable_unit_existing","text":"renewable_unit_existing(inputs::AbstractInputs)\n\nGet the existing field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_generation_ex_ante_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.renewable_unit_generation_ex_ante_file","text":"renewable_unit_generation_ex_ante_file(renewable_unit::AbstractCollection, i::Integer)\n\nGet the generationexante_file field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_generation_ex_ante_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.renewable_unit_generation_ex_ante_file","text":"renewable_unit_generation_ex_ante_file(collections::AbstractCollections, i::Integer)\n\nGet the generationexante_file field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_generation_ex_ante_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.renewable_unit_generation_ex_ante_file","text":"renewable_unit_generation_ex_ante_file(collections::AbstractCollections)\n\nGet the generation_ex_ante_file field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_generation_ex_ante_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.renewable_unit_generation_ex_ante_file","text":"renewable_unit_generation_ex_ante_file(renewable_unit::AbstractCollection)\n\nGet the generation_ex_ante_file field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_generation_ex_ante_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.renewable_unit_generation_ex_ante_file","text":"renewable_unit_generation_ex_ante_file(inputs::AbstractInputs, i::Integer)\n\nGet the generationexante_file field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_generation_ex_ante_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.renewable_unit_generation_ex_ante_file","text":"renewable_unit_generation_ex_ante_file(inputs::AbstractInputs)\n\nGet the generation_ex_ante_file field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_generation_ex_post_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.renewable_unit_generation_ex_post_file","text":"renewable_unit_generation_ex_post_file(renewable_unit::AbstractCollection, i::Integer)\n\nGet the generationexpost_file field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_generation_ex_post_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.renewable_unit_generation_ex_post_file","text":"renewable_unit_generation_ex_post_file(collections::AbstractCollections, i::Integer)\n\nGet the generationexpost_file field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_generation_ex_post_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.renewable_unit_generation_ex_post_file","text":"renewable_unit_generation_ex_post_file(collections::AbstractCollections)\n\nGet the generation_ex_post_file field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_generation_ex_post_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.renewable_unit_generation_ex_post_file","text":"renewable_unit_generation_ex_post_file(renewable_unit::AbstractCollection)\n\nGet the generation_ex_post_file field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_generation_ex_post_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.renewable_unit_generation_ex_post_file","text":"renewable_unit_generation_ex_post_file(inputs::AbstractInputs, i::Integer)\n\nGet the generationexpost_file field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_generation_ex_post_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.renewable_unit_generation_ex_post_file","text":"renewable_unit_generation_ex_post_file(inputs::AbstractInputs)\n\nGet the generation_ex_post_file field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_label-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.renewable_unit_label","text":"renewable_unit_label(renewable_unit::AbstractCollection, i::Integer)\n\nGet the label field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_label-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.renewable_unit_label","text":"renewable_unit_label(collections::AbstractCollections, i::Integer)\n\nGet the label field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_label-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.renewable_unit_label","text":"renewable_unit_label(collections::AbstractCollections)\n\nGet the label field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_label-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.renewable_unit_label","text":"renewable_unit_label(renewable_unit::AbstractCollection)\n\nGet the label field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_label-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.renewable_unit_label","text":"renewable_unit_label(inputs::AbstractInputs, i::Integer)\n\nGet the label field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_label-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.renewable_unit_label","text":"renewable_unit_label(inputs::AbstractInputs)\n\nGet the label field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_max_generation-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.renewable_unit_max_generation","text":"renewable_unit_max_generation(renewable_unit::AbstractCollection, i::Integer)\n\nGet the max_generation field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_max_generation-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.renewable_unit_max_generation","text":"renewable_unit_max_generation(collections::AbstractCollections, i::Integer)\n\nGet the max_generation field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_max_generation-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.renewable_unit_max_generation","text":"renewable_unit_max_generation(collections::AbstractCollections)\n\nGet the max_generation field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_max_generation-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.renewable_unit_max_generation","text":"renewable_unit_max_generation(renewable_unit::AbstractCollection)\n\nGet the max_generation field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_max_generation-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.renewable_unit_max_generation","text":"renewable_unit_max_generation(inputs::AbstractInputs, i::Integer)\n\nGet the max_generation field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_max_generation-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.renewable_unit_max_generation","text":"renewable_unit_max_generation(inputs::AbstractInputs)\n\nGet the max_generation field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_om_cost-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.renewable_unit_om_cost","text":"renewable_unit_om_cost(renewable_unit::AbstractCollection, i::Integer)\n\nGet the om_cost field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_om_cost-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.renewable_unit_om_cost","text":"renewable_unit_om_cost(collections::AbstractCollections, i::Integer)\n\nGet the om_cost field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_om_cost-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.renewable_unit_om_cost","text":"renewable_unit_om_cost(collections::AbstractCollections)\n\nGet the om_cost field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_om_cost-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.renewable_unit_om_cost","text":"renewable_unit_om_cost(renewable_unit::AbstractCollection)\n\nGet the om_cost field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_om_cost-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.renewable_unit_om_cost","text":"renewable_unit_om_cost(inputs::AbstractInputs, i::Integer)\n\nGet the om_cost field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_om_cost-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.renewable_unit_om_cost","text":"renewable_unit_om_cost(inputs::AbstractInputs)\n\nGet the om_cost field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_technology_type-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.renewable_unit_technology_type","text":"renewable_unit_technology_type(renewable_unit::AbstractCollection, i::Integer)\n\nGet the technology_type field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_technology_type-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.renewable_unit_technology_type","text":"renewable_unit_technology_type(collections::AbstractCollections, i::Integer)\n\nGet the technology_type field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_technology_type-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.renewable_unit_technology_type","text":"renewable_unit_technology_type(collections::AbstractCollections)\n\nGet the technology_type field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_technology_type-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.renewable_unit_technology_type","text":"renewable_unit_technology_type(renewable_unit::AbstractCollection)\n\nGet the technology_type field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_technology_type-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.renewable_unit_technology_type","text":"renewable_unit_technology_type(inputs::AbstractInputs, i::Integer)\n\nGet the technology_type field from the RenewableUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.renewable_unit_technology_type-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.renewable_unit_technology_type","text":"renewable_unit_technology_type(inputs::AbstractInputs)\n\nGet the technology_type field from the RenewableUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.reshape_time_series!","page":"API Reference","title":"IARA.reshape_time_series!","text":"reshape_time_series!(::Type{<:PlotType}, data::Array{<:AbstractFloat, N}, agent_names::Vector{String}, dimensions::Vector{String}; kwargs...)\n\nReduce the dimension of the data array by merging the dimensions, according to the plot type.\n\n\n\n\n\n","category":"function"},{"location":"api_reference.html#IARA.revenue_convex_combination!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.revenue_convex_combination!","text":"revenue_convex_combination!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the revenue convex combination constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.run_algorithms-Tuple{Any}","page":"API Reference","title":"IARA.run_algorithms","text":"run_algorithms(inputs)\n\nRun the algorithms according to the run mode.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.run_clearing_simulation-Tuple{IARA.ProblemModel, IARA.Inputs, IARA.RunTimeOptions, Int64}","page":"API Reference","title":"IARA.run_clearing_simulation","text":"run_clearing_simulation(\n    model::ProblemModel,\n    inputs::Inputs,\n    outputs::Outputs,\n    run_time_options::RunTimeOptions,\n    period::Int,\n)\n\nRun the clearing simulation.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.run_mode-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.run_mode","text":"run_mode(inputs::AbstractInputs)\n\nReturn the run mode.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.scale_cuts-Tuple{String, String, Float64}","page":"API Reference","title":"IARA.scale_cuts","text":"scale_cuts(input_file::String, output_file::String, factor::Float64)\n\nRead FCF cuts from inputfile, multiply all intercepts and coefficients by factor (preserving states), and save the result to outputfile.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.scenarios-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.scenarios","text":"scenarios(inputs::AbstractInputs)\n\nReturn all problem scenarios.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.serialize_bid_price_limits-Tuple{IARA.Inputs, Vararg{Vector{Float64}, 4}}","page":"API Reference","title":"IARA.serialize_bid_price_limits","text":"serialize_bid_price_limits(inputs::Inputs, bidding_group_bid_price_limit_not_justified_independent::Array{Float64, 1}, bidding_group_bid_price_limit_justified_independent::Array{Float64, 1}, bidding_group_bid_price_limit_not_justified_profile::Array{Float64, 1}, bidding_group_bid_price_limit_justified_profile::Array{Float64, 1}; period::Int, scenario::Int)\n\nSerialize bid price limits.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.serialize_clearing_variables-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, IARA.SimulationResultsFromPeriodScenario}","page":"API Reference","title":"IARA.serialize_clearing_variables","text":"serialize_clearing_variables(outputs::Outputs, inputs::Inputs, run_time_options::RunTimeOptions, simulation_results::SimulationResultsFromPeriodScenario; period::Int, scenario::Int)\n\nSerialize clearing variables.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.serialize_heuristic_bids-Tuple{IARA.Inputs, Array{Float64, 4}, Array{Float64, 4}}","page":"API Reference","title":"IARA.serialize_heuristic_bids","text":"serialize_heuristic_bids(inputs::Inputs, quantity_bid::Array{Float64, 4}, price_bid::Array{Float64, 4}; period::Int, scenario::Int)\n\nSerialize heuristic bids.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.serialize_parp_inflow-Tuple{IARA.Inputs, IARA.RunTimeOptions, Matrix{Float64}}","page":"API Reference","title":"IARA.serialize_parp_inflow","text":"serialize_parp_inflow(inputs::Inputs, inflow_values::Matrix{Float64}; period::Int, scenario::Int)\n\nSerialize PAR(p) inflow expression values for use in subsequent clearing problems. The inflowvalues matrix should have dimensions [subperiods, hydrounits].\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.serialize_virtual_reservoir_heuristic_bids-Tuple{IARA.Inputs, Array{Float64, 3}, Array{Float64, 3}}","page":"API Reference","title":"IARA.serialize_virtual_reservoir_heuristic_bids","text":"serialize_virtual_reservoir_heuristic_bids(inputs::Inputs, quantity_bid::Array{Float64, 3}, price_bid::Array{Float64, 3}; period::Int, scenario::Int)\n\nSerialize virtual reservoir heuristic bids.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.set_custom_hook-Tuple{JuMP.Model, IARA.Inputs, IARA.RunTimeOptions, Integer, Integer, Integer}","page":"API Reference","title":"IARA.set_custom_hook","text":"set_custom_hook(\n    node::SDDP.Node,\n    inputs::Inputs,\n    t::Integer,\n    scen::Integer,\n    subscenario::Integer,\n)\n\nSet hooks to write lps to the file if user asks to write lps or if the model is infeasible. Also, set hooks to fix integer variables from previous problem, fix integer variables, and relax integrality.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.set_hydro_spill_to!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String, String}","page":"API Reference","title":"IARA.set_hydro_spill_to!","text":"set_hydro_spill_to!(db::DatabaseSQLite, hydro_unit_from::String, hydro_unit_to::String)\n\nLink two Hydro Units by setting the downstream spillage Hydro Unit.\n\nExample:\n\nIARA.set_hydro_spill_to!(db, \"hydro_1\", \"hydro_2\")\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.set_hydro_turbine_to!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String, String}","page":"API Reference","title":"IARA.set_hydro_turbine_to!","text":"set_hydro_turbine_to!(db::DatabaseSQLite, hydro_unit_from::String, hydro_unit_to::String)\n\nLink two Hydro Units by setting the downstream turbining Hydro Unit.\n\nExample:\n\nIARA.set_hydro_turbine_to!(db, \"hydro_1\", \"hydro_2\")\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.settlement_type-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.settlement_type","text":"settlement_type(inputs::AbstractInputs)\n\nReturn the settlement type.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.should_build_reference_curve-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.should_build_reference_curve","text":"should_build_reference_curve(inputs::AbstractInputs)\n\nReturn whether the reference curve should be built.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.should_run_supply_function_equilibrium-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.should_run_supply_function_equilibrium","text":"should_run_supply_function_equilibrium(inputs::AbstractInputs)\n\nReturn whether the Nash equilibrium from hydro reference curve should be run.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.should_write_ex_post_quantity_bid_output_file-Tuple{IARA.Inputs, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.should_write_ex_post_quantity_bid_output_file","text":"should_write_ex_post_quantity_bid_output_file(inputs::Inputs, run_time_options::RunTimeOptions)\n\nCheck if the ex-post quantity bid output file should be written.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.simulate_all_periods_and_scenarios_of_market_clearing-Tuple{IARA.Inputs}","page":"API Reference","title":"IARA.simulate_all_periods_and_scenarios_of_market_clearing","text":"simulate_all_periods_and_scenarios_of_market_clearing(inputs::Inputs)\n\nSimulate all periods and scenarios of the market clearing.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.simulate_all_periods_and_scenarios_of_trained_model-Tuple{IARA.ProblemModel, IARA.Inputs, IARA.Outputs, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.simulate_all_periods_and_scenarios_of_trained_model","text":"simulate_all_periods_and_scenarios_of_trained_model(\n    model::ProblemModel,\n    inputs::Inputs,\n    outputs::Outputs,\n    run_time_options::RunTimeOptions,\n)\n\nSimulate all periods and scenarios of a trained model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.simulate_all_scenarios_of_single_period_market_clearing-Tuple{IARA.Inputs}","page":"API Reference","title":"IARA.simulate_all_scenarios_of_single_period_market_clearing","text":"simulate_all_scenarios_of_single_period_market_clearing(inputs::Inputs)\n\nSimulate all periods and scenarios of the market clearing.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.single_period_heuristic_bid-Tuple{IARA.Inputs}","page":"API Reference","title":"IARA.single_period_heuristic_bid","text":"single_period_heuristic_bid(inputs::Inputs)\n\nGenerate heuristic bids for a single period.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.single_period_heuristic_bid-Tuple{String}","page":"API Reference","title":"IARA.single_period_heuristic_bid","text":"single_period_heuristic_bid(path::String; kwargs...)\n\nGenerate heuristic bids for a single period.\n\nkeywords:\n\noutputs_path::String. Path to the outputs. default = joinpath(path, \"outputs\")\nplot_outputs::Bool. Plot all outputs after the run. default = true\nwrite_lp::Bool. Write the LP files. default = false\ndelete_output_folder_before_execution::Bool. Delete the output folder before execution. default = false\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.single_period_market_clearing-Tuple{String}","page":"API Reference","title":"IARA.single_period_market_clearing","text":"single_period_market_clearing(path::String; kwargs...)\n\nRun the model with the single period market clearing strategy.\n\nkeywords:\n\noutputs_path::String. Path to the outputs. default = joinpath(path, \"outputs\")\nplot_outputs::Bool. Plot all outputs after the run. default = true\nwrite_lp::Bool. Write the LP files. default = false\ndelete_output_folder_before_execution::Bool. Delete the output folder before execution. default = false\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.skip_clearing_subproblem-Tuple{IARA.Inputs, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.skip_clearing_subproblem","text":"skip_clearing_subproblem(inputs::Inputs, run_time_options::RunTimeOptions)\n\nCheck if the clearing subproblem should be skipped.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.some_branch_does_not_have_dc_flag-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.some_branch_does_not_have_dc_flag","text":"some_branch_does_not_have_dc_flag(inputs::AbstractInputs)\n\nCheck if not all Branches are modeled as DC Lines.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.some_inflow_initial_state_varies_by_scenario-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.some_inflow_initial_state_varies_by_scenario","text":"some_inflow_initial_state_varies_by_scenario(inputs::AbstractInputs)\n\nCheck if it is necessary to read the inflow initial state by scenario timeseries file.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.some_initial_volume_varies_by_scenario-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.some_initial_volume_varies_by_scenario","text":"some_initial_volume_varies_by_scenario(inputs::AbstractInputs)\n\nCheck if it is necessary to read the initial volume by scenario timeseries file.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.subperiod_duration_in_hours-Tuple{PSRBridge.AbstractInputs, Int64}","page":"API Reference","title":"IARA.subperiod_duration_in_hours","text":"subperiod_duration_in_hours(inputs::AbstractInputs, subperiod::Int)\n\nReturn the subperiod duration in hours for a given subperiod.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.subperiod_duration_in_hours-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.subperiod_duration_in_hours","text":"subperiod_duration_in_hours(inputs::AbstractInputs)\n\nReturn the subperiod duration in hours for all subperiods.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.subperiod_hour_map-Tuple{Any}","page":"API Reference","title":"IARA.subperiod_hour_map","text":"subperiod_hour_map(inputs)\n\nReturn a vector of vectors, mapping each subperiod to multiple hours.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.subperiods-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.subperiods","text":"subperiods(inputs::AbstractInputs)\n\nReturn all problem subperiods.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.subperiods_in_flexible_demand_window-Tuple{PSRBridge.AbstractInputs, Int64, Int64}","page":"API Reference","title":"IARA.subperiods_in_flexible_demand_window","text":"subperiods_in_flexible_demand_window(inputs::AbstractInputs, idx::Int, w::Int)\n\nReturn the set of subperiods in the window 'w' of the flexible Demand in position 'idx'.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.subscenarios-Tuple{PSRBridge.AbstractInputs, Any}","page":"API Reference","title":"IARA.subscenarios","text":"subscenarios(inputs::AbstractInputs, run_time_options)\n\nReturn all subscenarios to simulate.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.summarize-Tuple{String}","page":"API Reference","title":"IARA.summarize","text":"summarize(path::String; run_mode::String = \"market-clearing\")\n\nSummarize the case based on the run_mode passed.\n\nThe available run modes are:\n\ntrain-min-cost\nmin-cost\nmarket-clearing\nsingle-period-market-clearing\nsingle-period-heuristic-bid\ninterface-call\nsingle-period-hydro-supply-reference-curve\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.supply_function_equilibrium_extra_bid_quantity-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.supply_function_equilibrium_extra_bid_quantity","text":"supply_function_equilibrium_extra_bid_quantity(inputs::AbstractInputs)\n\nReturn the extra bid quantity for the Supply Function Equilibrium.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.supply_function_equilibrium_max_cost_multiplier-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.supply_function_equilibrium_max_cost_multiplier","text":"supply_function_equilibrium_max_cost_multiplier(inputs)\n\nReturn the maximum cost multiplier for the Supply Function Equilibrium.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.supply_function_equilibrium_max_iterations-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.supply_function_equilibrium_max_iterations","text":"supply_function_equilibrium_max_iterations(inputs)\n\nReturn the maximum number of iterations for the Supply Function Equilibrium.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.supply_function_equilibrium_tolerance-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.supply_function_equilibrium_tolerance","text":"supply_function_equilibrium_tolerance(inputs)\n\nReturn the tolerance for the bid slopes in the Supply Function Equilibrium.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_commitment!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, IARA.SimulationResultsFromPeriodScenario, Int64, Int64, Int64, Type{IARA.WriteOutput}}","page":"API Reference","title":"IARA.thermal_commitment!","text":"thermal_commitment!(outputs, inputs::Inputs, run_time_options::RunTimeOptions, simulation_results::SimulationResultsFromPeriodScenario, period::Int, scenario::Int, subscenario::Int, ::Type{WriteOutput})\n\nWrite the thermal unit commitment variables' values to the output file.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_commitment!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.InitializeOutput}}","page":"API Reference","title":"IARA.thermal_commitment!","text":"thermal_commitment!(outputs::Outputs, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{InitializeOutput})\n\nInitialize the output file to store the thermal unit commitment variables' values.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_commitment!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.thermal_commitment!","text":"thermal_commitment!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the thermal unit commitment variables to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_generation!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, IARA.SimulationResultsFromPeriodScenario, Int64, Int64, Int64, Type{IARA.WriteOutput}}","page":"API Reference","title":"IARA.thermal_generation!","text":"thermal_generation!(outputs, inputs::Inputs, run_time_options::RunTimeOptions, simulation_results::SimulationResultsFromPeriodScenario, period::Int, scenario::Int, subscenario::Int, ::Type{WriteOutput})\n\nWrite the thermal unit generation variables' values to the output file.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_generation!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.InitializeOutput}}","page":"API Reference","title":"IARA.thermal_generation!","text":"thermal_generation!(outputs::Outputs, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{InitializeOutput})\n\nInitialize the output file to store the thermal unit generation variables' values.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_generation!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.thermal_generation!","text":"thermal_generation!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the thermal unit generation variables to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_generation_bound_by_commitment!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.thermal_generation_bound_by_commitment!","text":"thermal_generation_bound_by_commitment!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the thermal unit generation bound by commitment constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_min_max_up_down_time!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.thermal_min_max_up_down_time!","text":"thermal_min_max_up_down_time!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the thermal unit minimum and maximum up and down time constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_ramp!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.thermal_ramp!","text":"thermal_ramp!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the thermal unit ramp constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_startup_and_shutdown!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.thermal_startup_and_shutdown!","text":"thermal_startup_and_shutdown!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the thermal unit startup and shutdown constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_bidding_group_index-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.thermal_unit_bidding_group_index","text":"thermal_unit_bidding_group_index(thermal_unit::AbstractCollection, i::Integer)\n\nGet the biddinggroupindex field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_bidding_group_index-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.thermal_unit_bidding_group_index","text":"thermal_unit_bidding_group_index(collections::AbstractCollections, i::Integer)\n\nGet the biddinggroupindex field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_bidding_group_index-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.thermal_unit_bidding_group_index","text":"thermal_unit_bidding_group_index(collections::AbstractCollections)\n\nGet the bidding_group_index field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_bidding_group_index-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.thermal_unit_bidding_group_index","text":"thermal_unit_bidding_group_index(thermal_unit::AbstractCollection)\n\nGet the bidding_group_index field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_bidding_group_index-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.thermal_unit_bidding_group_index","text":"thermal_unit_bidding_group_index(inputs::AbstractInputs, i::Integer)\n\nGet the biddinggroupindex field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_bidding_group_index-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.thermal_unit_bidding_group_index","text":"thermal_unit_bidding_group_index(inputs::AbstractInputs)\n\nGet the bidding_group_index field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_bus_index-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.thermal_unit_bus_index","text":"thermal_unit_bus_index(thermal_unit::AbstractCollection, i::Integer)\n\nGet the bus_index field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_bus_index-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.thermal_unit_bus_index","text":"thermal_unit_bus_index(collections::AbstractCollections, i::Integer)\n\nGet the bus_index field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_bus_index-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.thermal_unit_bus_index","text":"thermal_unit_bus_index(collections::AbstractCollections)\n\nGet the bus_index field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_bus_index-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.thermal_unit_bus_index","text":"thermal_unit_bus_index(thermal_unit::AbstractCollection)\n\nGet the bus_index field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_bus_index-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.thermal_unit_bus_index","text":"thermal_unit_bus_index(inputs::AbstractInputs, i::Integer)\n\nGet the bus_index field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_bus_index-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.thermal_unit_bus_index","text":"thermal_unit_bus_index(inputs::AbstractInputs)\n\nGet the bus_index field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_commitment_initial_condition-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.thermal_unit_commitment_initial_condition","text":"thermal_unit_commitment_initial_condition(thermal_unit::AbstractCollection, i::Integer)\n\nGet the commitmentinitialcondition field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_commitment_initial_condition-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.thermal_unit_commitment_initial_condition","text":"thermal_unit_commitment_initial_condition(collections::AbstractCollections, i::Integer)\n\nGet the commitmentinitialcondition field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_commitment_initial_condition-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.thermal_unit_commitment_initial_condition","text":"thermal_unit_commitment_initial_condition(collections::AbstractCollections)\n\nGet the commitment_initial_condition field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_commitment_initial_condition-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.thermal_unit_commitment_initial_condition","text":"thermal_unit_commitment_initial_condition(thermal_unit::AbstractCollection)\n\nGet the commitment_initial_condition field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_commitment_initial_condition-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.thermal_unit_commitment_initial_condition","text":"thermal_unit_commitment_initial_condition(inputs::AbstractInputs, i::Integer)\n\nGet the commitmentinitialcondition field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_commitment_initial_condition-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.thermal_unit_commitment_initial_condition","text":"thermal_unit_commitment_initial_condition(inputs::AbstractInputs)\n\nGet the commitment_initial_condition field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_downtime_initial_condition-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.thermal_unit_downtime_initial_condition","text":"thermal_unit_downtime_initial_condition(thermal_unit::AbstractCollection, i::Integer)\n\nGet the downtimeinitialcondition field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_downtime_initial_condition-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.thermal_unit_downtime_initial_condition","text":"thermal_unit_downtime_initial_condition(collections::AbstractCollections, i::Integer)\n\nGet the downtimeinitialcondition field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_downtime_initial_condition-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.thermal_unit_downtime_initial_condition","text":"thermal_unit_downtime_initial_condition(collections::AbstractCollections)\n\nGet the downtime_initial_condition field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_downtime_initial_condition-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.thermal_unit_downtime_initial_condition","text":"thermal_unit_downtime_initial_condition(thermal_unit::AbstractCollection)\n\nGet the downtime_initial_condition field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_downtime_initial_condition-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.thermal_unit_downtime_initial_condition","text":"thermal_unit_downtime_initial_condition(inputs::AbstractInputs, i::Integer)\n\nGet the downtimeinitialcondition field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_downtime_initial_condition-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.thermal_unit_downtime_initial_condition","text":"thermal_unit_downtime_initial_condition(inputs::AbstractInputs)\n\nGet the downtime_initial_condition field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_existing-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.thermal_unit_existing","text":"thermal_unit_existing(thermal_unit::AbstractCollection, i::Integer)\n\nGet the existing field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_existing-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.thermal_unit_existing","text":"thermal_unit_existing(collections::AbstractCollections, i::Integer)\n\nGet the existing field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_existing-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.thermal_unit_existing","text":"thermal_unit_existing(collections::AbstractCollections)\n\nGet the existing field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_existing-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.thermal_unit_existing","text":"thermal_unit_existing(thermal_unit::AbstractCollection)\n\nGet the existing field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_existing-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.thermal_unit_existing","text":"thermal_unit_existing(inputs::AbstractInputs, i::Integer)\n\nGet the existing field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_existing-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.thermal_unit_existing","text":"thermal_unit_existing(inputs::AbstractInputs)\n\nGet the existing field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_generation_initial_condition-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.thermal_unit_generation_initial_condition","text":"thermal_unit_generation_initial_condition(thermal_unit::AbstractCollection, i::Integer)\n\nGet the generationinitialcondition field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_generation_initial_condition-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.thermal_unit_generation_initial_condition","text":"thermal_unit_generation_initial_condition(collections::AbstractCollections, i::Integer)\n\nGet the generationinitialcondition field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_generation_initial_condition-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.thermal_unit_generation_initial_condition","text":"thermal_unit_generation_initial_condition(collections::AbstractCollections)\n\nGet the generation_initial_condition field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_generation_initial_condition-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.thermal_unit_generation_initial_condition","text":"thermal_unit_generation_initial_condition(thermal_unit::AbstractCollection)\n\nGet the generation_initial_condition field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_generation_initial_condition-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.thermal_unit_generation_initial_condition","text":"thermal_unit_generation_initial_condition(inputs::AbstractInputs, i::Integer)\n\nGet the generationinitialcondition field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_generation_initial_condition-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.thermal_unit_generation_initial_condition","text":"thermal_unit_generation_initial_condition(inputs::AbstractInputs)\n\nGet the generation_initial_condition field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_has_commitment-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.thermal_unit_has_commitment","text":"thermal_unit_has_commitment(thermal_unit::AbstractCollection, i::Integer)\n\nGet the has_commitment field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_has_commitment-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.thermal_unit_has_commitment","text":"thermal_unit_has_commitment(collections::AbstractCollections, i::Integer)\n\nGet the has_commitment field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_has_commitment-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.thermal_unit_has_commitment","text":"thermal_unit_has_commitment(collections::AbstractCollections)\n\nGet the has_commitment field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_has_commitment-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.thermal_unit_has_commitment","text":"thermal_unit_has_commitment(thermal_unit::AbstractCollection)\n\nGet the has_commitment field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_has_commitment-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.thermal_unit_has_commitment","text":"thermal_unit_has_commitment(inputs::AbstractInputs, i::Integer)\n\nGet the has_commitment field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_has_commitment-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.thermal_unit_has_commitment","text":"thermal_unit_has_commitment(inputs::AbstractInputs)\n\nGet the has_commitment field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_intra_period_operation-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.thermal_unit_intra_period_operation","text":"thermal_unit_intra_period_operation(inputs::AbstractInputs)\n\nReturn whether subperiods should be looped for thermal constraints.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_label-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.thermal_unit_label","text":"thermal_unit_label(thermal_unit::AbstractCollection, i::Integer)\n\nGet the label field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_label-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.thermal_unit_label","text":"thermal_unit_label(collections::AbstractCollections, i::Integer)\n\nGet the label field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_label-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.thermal_unit_label","text":"thermal_unit_label(collections::AbstractCollections)\n\nGet the label field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_label-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.thermal_unit_label","text":"thermal_unit_label(thermal_unit::AbstractCollection)\n\nGet the label field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_label-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.thermal_unit_label","text":"thermal_unit_label(inputs::AbstractInputs, i::Integer)\n\nGet the label field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_label-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.thermal_unit_label","text":"thermal_unit_label(inputs::AbstractInputs)\n\nGet the label field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_generation-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.thermal_unit_max_generation","text":"thermal_unit_max_generation(thermal_unit::AbstractCollection, i::Integer)\n\nGet the max_generation field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_generation-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.thermal_unit_max_generation","text":"thermal_unit_max_generation(collections::AbstractCollections, i::Integer)\n\nGet the max_generation field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_generation-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.thermal_unit_max_generation","text":"thermal_unit_max_generation(collections::AbstractCollections)\n\nGet the max_generation field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_generation-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.thermal_unit_max_generation","text":"thermal_unit_max_generation(thermal_unit::AbstractCollection)\n\nGet the max_generation field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_generation-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.thermal_unit_max_generation","text":"thermal_unit_max_generation(inputs::AbstractInputs, i::Integer)\n\nGet the max_generation field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_generation-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.thermal_unit_max_generation","text":"thermal_unit_max_generation(inputs::AbstractInputs)\n\nGet the max_generation field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_ramp_down-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.thermal_unit_max_ramp_down","text":"thermal_unit_max_ramp_down(thermal_unit::AbstractCollection, i::Integer)\n\nGet the maxrampdown field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_ramp_down-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.thermal_unit_max_ramp_down","text":"thermal_unit_max_ramp_down(collections::AbstractCollections, i::Integer)\n\nGet the maxrampdown field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_ramp_down-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.thermal_unit_max_ramp_down","text":"thermal_unit_max_ramp_down(collections::AbstractCollections)\n\nGet the max_ramp_down field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_ramp_down-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.thermal_unit_max_ramp_down","text":"thermal_unit_max_ramp_down(thermal_unit::AbstractCollection)\n\nGet the max_ramp_down field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_ramp_down-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.thermal_unit_max_ramp_down","text":"thermal_unit_max_ramp_down(inputs::AbstractInputs, i::Integer)\n\nGet the maxrampdown field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_ramp_down-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.thermal_unit_max_ramp_down","text":"thermal_unit_max_ramp_down(inputs::AbstractInputs)\n\nGet the max_ramp_down field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_ramp_up-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.thermal_unit_max_ramp_up","text":"thermal_unit_max_ramp_up(thermal_unit::AbstractCollection, i::Integer)\n\nGet the maxrampup field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_ramp_up-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.thermal_unit_max_ramp_up","text":"thermal_unit_max_ramp_up(collections::AbstractCollections, i::Integer)\n\nGet the maxrampup field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_ramp_up-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.thermal_unit_max_ramp_up","text":"thermal_unit_max_ramp_up(collections::AbstractCollections)\n\nGet the max_ramp_up field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_ramp_up-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.thermal_unit_max_ramp_up","text":"thermal_unit_max_ramp_up(thermal_unit::AbstractCollection)\n\nGet the max_ramp_up field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_ramp_up-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.thermal_unit_max_ramp_up","text":"thermal_unit_max_ramp_up(inputs::AbstractInputs, i::Integer)\n\nGet the maxrampup field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_ramp_up-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.thermal_unit_max_ramp_up","text":"thermal_unit_max_ramp_up(inputs::AbstractInputs)\n\nGet the max_ramp_up field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_shutdowns-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.thermal_unit_max_shutdowns","text":"thermal_unit_max_shutdowns(thermal_unit::AbstractCollection, i::Integer)\n\nGet the max_shutdowns field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_shutdowns-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.thermal_unit_max_shutdowns","text":"thermal_unit_max_shutdowns(collections::AbstractCollections, i::Integer)\n\nGet the max_shutdowns field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_shutdowns-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.thermal_unit_max_shutdowns","text":"thermal_unit_max_shutdowns(collections::AbstractCollections)\n\nGet the max_shutdowns field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_shutdowns-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.thermal_unit_max_shutdowns","text":"thermal_unit_max_shutdowns(thermal_unit::AbstractCollection)\n\nGet the max_shutdowns field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_shutdowns-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.thermal_unit_max_shutdowns","text":"thermal_unit_max_shutdowns(inputs::AbstractInputs, i::Integer)\n\nGet the max_shutdowns field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_shutdowns-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.thermal_unit_max_shutdowns","text":"thermal_unit_max_shutdowns(inputs::AbstractInputs)\n\nGet the max_shutdowns field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_startups-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.thermal_unit_max_startups","text":"thermal_unit_max_startups(thermal_unit::AbstractCollection, i::Integer)\n\nGet the max_startups field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_startups-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.thermal_unit_max_startups","text":"thermal_unit_max_startups(collections::AbstractCollections, i::Integer)\n\nGet the max_startups field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_startups-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.thermal_unit_max_startups","text":"thermal_unit_max_startups(collections::AbstractCollections)\n\nGet the max_startups field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_startups-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.thermal_unit_max_startups","text":"thermal_unit_max_startups(thermal_unit::AbstractCollection)\n\nGet the max_startups field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_startups-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.thermal_unit_max_startups","text":"thermal_unit_max_startups(inputs::AbstractInputs, i::Integer)\n\nGet the max_startups field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_startups-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.thermal_unit_max_startups","text":"thermal_unit_max_startups(inputs::AbstractInputs)\n\nGet the max_startups field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_uptime-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.thermal_unit_max_uptime","text":"thermal_unit_max_uptime(thermal_unit::AbstractCollection, i::Integer)\n\nGet the max_uptime field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_uptime-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.thermal_unit_max_uptime","text":"thermal_unit_max_uptime(collections::AbstractCollections, i::Integer)\n\nGet the max_uptime field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_uptime-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.thermal_unit_max_uptime","text":"thermal_unit_max_uptime(collections::AbstractCollections)\n\nGet the max_uptime field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_uptime-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.thermal_unit_max_uptime","text":"thermal_unit_max_uptime(thermal_unit::AbstractCollection)\n\nGet the max_uptime field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_uptime-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.thermal_unit_max_uptime","text":"thermal_unit_max_uptime(inputs::AbstractInputs, i::Integer)\n\nGet the max_uptime field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_max_uptime-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.thermal_unit_max_uptime","text":"thermal_unit_max_uptime(inputs::AbstractInputs)\n\nGet the max_uptime field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_min_downtime-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.thermal_unit_min_downtime","text":"thermal_unit_min_downtime(thermal_unit::AbstractCollection, i::Integer)\n\nGet the min_downtime field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_min_downtime-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.thermal_unit_min_downtime","text":"thermal_unit_min_downtime(collections::AbstractCollections, i::Integer)\n\nGet the min_downtime field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_min_downtime-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.thermal_unit_min_downtime","text":"thermal_unit_min_downtime(collections::AbstractCollections)\n\nGet the min_downtime field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_min_downtime-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.thermal_unit_min_downtime","text":"thermal_unit_min_downtime(thermal_unit::AbstractCollection)\n\nGet the min_downtime field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_min_downtime-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.thermal_unit_min_downtime","text":"thermal_unit_min_downtime(inputs::AbstractInputs, i::Integer)\n\nGet the min_downtime field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_min_downtime-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.thermal_unit_min_downtime","text":"thermal_unit_min_downtime(inputs::AbstractInputs)\n\nGet the min_downtime field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_min_generation-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.thermal_unit_min_generation","text":"thermal_unit_min_generation(thermal_unit::AbstractCollection, i::Integer)\n\nGet the min_generation field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_min_generation-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.thermal_unit_min_generation","text":"thermal_unit_min_generation(collections::AbstractCollections, i::Integer)\n\nGet the min_generation field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_min_generation-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.thermal_unit_min_generation","text":"thermal_unit_min_generation(collections::AbstractCollections)\n\nGet the min_generation field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_min_generation-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.thermal_unit_min_generation","text":"thermal_unit_min_generation(thermal_unit::AbstractCollection)\n\nGet the min_generation field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_min_generation-Tuple{PSRBridge.AbstractInputs, Int64}","page":"API Reference","title":"IARA.thermal_unit_min_generation","text":"thermal_unit_min_generation(inputs, idx::Int)\n\nReturn the min_generation of the Thermal Unit at index 'idx'.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_min_generation-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.thermal_unit_min_generation","text":"thermal_unit_min_generation(inputs::AbstractInputs, i::Integer)\n\nGet the min_generation field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_min_generation-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.thermal_unit_min_generation","text":"thermal_unit_min_generation(inputs::AbstractInputs)\n\nGet the min_generation field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_min_uptime-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.thermal_unit_min_uptime","text":"thermal_unit_min_uptime(thermal_unit::AbstractCollection, i::Integer)\n\nGet the min_uptime field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_min_uptime-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.thermal_unit_min_uptime","text":"thermal_unit_min_uptime(collections::AbstractCollections, i::Integer)\n\nGet the min_uptime field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_min_uptime-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.thermal_unit_min_uptime","text":"thermal_unit_min_uptime(collections::AbstractCollections)\n\nGet the min_uptime field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_min_uptime-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.thermal_unit_min_uptime","text":"thermal_unit_min_uptime(thermal_unit::AbstractCollection)\n\nGet the min_uptime field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_min_uptime-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.thermal_unit_min_uptime","text":"thermal_unit_min_uptime(inputs::AbstractInputs, i::Integer)\n\nGet the min_uptime field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_min_uptime-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.thermal_unit_min_uptime","text":"thermal_unit_min_uptime(inputs::AbstractInputs)\n\nGet the min_uptime field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_om_cost-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.thermal_unit_om_cost","text":"thermal_unit_om_cost(thermal_unit::AbstractCollection, i::Integer)\n\nGet the om_cost field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_om_cost-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.thermal_unit_om_cost","text":"thermal_unit_om_cost(collections::AbstractCollections, i::Integer)\n\nGet the om_cost field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_om_cost-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.thermal_unit_om_cost","text":"thermal_unit_om_cost(collections::AbstractCollections)\n\nGet the om_cost field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_om_cost-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.thermal_unit_om_cost","text":"thermal_unit_om_cost(thermal_unit::AbstractCollection)\n\nGet the om_cost field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_om_cost-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.thermal_unit_om_cost","text":"thermal_unit_om_cost(inputs::AbstractInputs, i::Integer)\n\nGet the om_cost field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_om_cost-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.thermal_unit_om_cost","text":"thermal_unit_om_cost(inputs::AbstractInputs)\n\nGet the om_cost field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_shutdown_cost-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.thermal_unit_shutdown_cost","text":"thermal_unit_shutdown_cost(thermal_unit::AbstractCollection, i::Integer)\n\nGet the shutdown_cost field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_shutdown_cost-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.thermal_unit_shutdown_cost","text":"thermal_unit_shutdown_cost(collections::AbstractCollections, i::Integer)\n\nGet the shutdown_cost field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_shutdown_cost-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.thermal_unit_shutdown_cost","text":"thermal_unit_shutdown_cost(collections::AbstractCollections)\n\nGet the shutdown_cost field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_shutdown_cost-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.thermal_unit_shutdown_cost","text":"thermal_unit_shutdown_cost(thermal_unit::AbstractCollection)\n\nGet the shutdown_cost field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_shutdown_cost-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.thermal_unit_shutdown_cost","text":"thermal_unit_shutdown_cost(inputs::AbstractInputs, i::Integer)\n\nGet the shutdown_cost field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_shutdown_cost-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.thermal_unit_shutdown_cost","text":"thermal_unit_shutdown_cost(inputs::AbstractInputs)\n\nGet the shutdown_cost field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_startup_cost-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.thermal_unit_startup_cost","text":"thermal_unit_startup_cost(thermal_unit::AbstractCollection, i::Integer)\n\nGet the startup_cost field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_startup_cost-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.thermal_unit_startup_cost","text":"thermal_unit_startup_cost(collections::AbstractCollections, i::Integer)\n\nGet the startup_cost field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_startup_cost-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.thermal_unit_startup_cost","text":"thermal_unit_startup_cost(collections::AbstractCollections)\n\nGet the startup_cost field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_startup_cost-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.thermal_unit_startup_cost","text":"thermal_unit_startup_cost(thermal_unit::AbstractCollection)\n\nGet the startup_cost field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_startup_cost-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.thermal_unit_startup_cost","text":"thermal_unit_startup_cost(inputs::AbstractInputs, i::Integer)\n\nGet the startup_cost field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_startup_cost-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.thermal_unit_startup_cost","text":"thermal_unit_startup_cost(inputs::AbstractInputs)\n\nGet the startup_cost field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_uptime_initial_condition-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.thermal_unit_uptime_initial_condition","text":"thermal_unit_uptime_initial_condition(thermal_unit::AbstractCollection, i::Integer)\n\nGet the uptimeinitialcondition field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_uptime_initial_condition-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.thermal_unit_uptime_initial_condition","text":"thermal_unit_uptime_initial_condition(collections::AbstractCollections, i::Integer)\n\nGet the uptimeinitialcondition field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_uptime_initial_condition-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.thermal_unit_uptime_initial_condition","text":"thermal_unit_uptime_initial_condition(collections::AbstractCollections)\n\nGet the uptime_initial_condition field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_uptime_initial_condition-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.thermal_unit_uptime_initial_condition","text":"thermal_unit_uptime_initial_condition(thermal_unit::AbstractCollection)\n\nGet the uptime_initial_condition field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_uptime_initial_condition-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.thermal_unit_uptime_initial_condition","text":"thermal_unit_uptime_initial_condition(inputs::AbstractInputs, i::Integer)\n\nGet the uptimeinitialcondition field from the ThermalUnit collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.thermal_unit_uptime_initial_condition-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.thermal_unit_uptime_initial_condition","text":"thermal_unit_uptime_initial_condition(inputs::AbstractInputs)\n\nGet the uptime_initial_condition field from the ThermalUnit collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_bid_price_limit_justified_independent-Tuple{Any}","page":"API Reference","title":"IARA.time_series_bid_price_limit_justified_independent","text":"time_series_bid_price_limit_justified_independent(inputs)\n\nReturn the time series of price limits for justified independent bids.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_bid_price_limit_justified_profile-Tuple{Any}","page":"API Reference","title":"IARA.time_series_bid_price_limit_justified_profile","text":"time_series_bid_price_limit_justified_profile(inputs)\n\nReturn the time series of price limits for justified profile bids.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_bid_price_limit_non_justified_independent-Tuple{Any}","page":"API Reference","title":"IARA.time_series_bid_price_limit_non_justified_independent","text":"time_series_bid_price_limit_non_justified_independent(inputs)\n\nReturn the time series of price limits for non justified independent bids.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_bid_price_limit_non_justified_profile-Tuple{Any}","page":"API Reference","title":"IARA.time_series_bid_price_limit_non_justified_profile","text":"time_series_bid_price_limit_non_justified_profile(inputs)\n\nReturn the time series of price limits for non justified profile bids.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_complementary_grouping_profile-Tuple{Any, Int64, Int64}","page":"API Reference","title":"IARA.time_series_complementary_grouping_profile","text":"time_series_complementary_grouping_profile(inputs::Inputs)\n\nReturn the complementary grouping profile time series.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_dataframe-Tuple{String}","page":"API Reference","title":"IARA.time_series_dataframe","text":"time_series_dataframe(path::String)\n\nReads a time series from a file and returns a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_demand-Tuple{Any, Any}","page":"API Reference","title":"IARA.time_series_demand","text":"time_series_demand(inputs::Inputs, run_time_options::RunTimeOptions; subscenario::Int)\n\nReturn the demand time series for the given subscenario.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_elastic_demand_price-Tuple{Any}","page":"API Reference","title":"IARA.time_series_elastic_demand_price","text":"time_series_elastic_demand_price(inputs)\n\nReturn the elastic demand price time series.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_hydro_generation-Tuple{Any}","page":"API Reference","title":"IARA.time_series_hydro_generation","text":"time_series_hydro_generation(inputs)\n\nReturn the hydro generation time series.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_hydro_opportunity_cost-Tuple{Any}","page":"API Reference","title":"IARA.time_series_hydro_opportunity_cost","text":"time_series_hydro_opportunity_cost(inputs)\n\nReturn the hydro opportunity cost time series.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_inflow-Tuple{Any, Any}","page":"API Reference","title":"IARA.time_series_inflow","text":"time_series_inflow(inputs::Inputs, run_time_options::RunTimeOptions; subscenario::Int)\n\nReturn the inflow time series for the given subscenario.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_inflow_noise-Tuple{Any, Any}","page":"API Reference","title":"IARA.time_series_inflow_noise","text":"time_series_inflow_noise(inputs, run_time_options; subscenario::Union{Int, Nothing} = nothing)\n\nReturn the inflow noise time series.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_inflow_period_average-Tuple{Any}","page":"API Reference","title":"IARA.time_series_inflow_period_average","text":"time_series_inflow_period_average(inputs)\n\nReturn the inflow period average time series.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_inflow_period_std_dev-Tuple{Any}","page":"API Reference","title":"IARA.time_series_inflow_period_std_dev","text":"time_series_inflow_period_std_dev(inputs)\n\nReturn the inflow period standard deviation time series.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_parent_profile-Tuple{Any, Int64, Int64}","page":"API Reference","title":"IARA.time_series_parent_profile","text":"time_series_parent_profile(inputs::Inputs)\n\nReturn the parent profile profile time series.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_parp_coefficients-Tuple{Any}","page":"API Reference","title":"IARA.time_series_parp_coefficients","text":"time_series_parp_coefficients(inputs)\n\nReturn the PAR(p) coefficients time series.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_price_bid-Tuple{Any, Int64, Int64}","page":"API Reference","title":"IARA.time_series_price_bid","text":"time_series_price_bid(inputs, period::Int, scenario::Int)\n\nReturn the price bid time series for the given period and scenario.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_price_bid_profile-Tuple{Any, Int64, Int64}","page":"API Reference","title":"IARA.time_series_price_bid_profile","text":"time_series_price_bid_profile(inputs::Inputs)\n\nReturn the price bid profile time series.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_quantity_bid-Tuple{Any, Int64, Int64}","page":"API Reference","title":"IARA.time_series_quantity_bid","text":"time_series_quantity_bid(inputs::Inputs, period::Int, scenario::Int)\n\nReturn the quantity bid time series for the given period and scenario.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_quantity_bid_profile-Tuple{Any, Int64, Int64}","page":"API Reference","title":"IARA.time_series_quantity_bid_profile","text":"time_series_quantity_bid_profile(inputs::Inputs)\n\nReturn the quantity bid profile time series.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_renewable_generation-Tuple{Any, Any}","page":"API Reference","title":"IARA.time_series_renewable_generation","text":"time_series_renewable_generation(inputs::Inputs, run_time_options::RunTimeOptions; subscenario::Int)\n\nReturn the renewable generation time series for the given subscenario.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_spot_price-Tuple{Any}","page":"API Reference","title":"IARA.time_series_spot_price","text":"time_series_spot_price(inputs::Inputs)\n\nReturn the spot price time series.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_step-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.time_series_step","text":"time_series_step(inputs::AbstractInputs)\n\nReturn the Time series step.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_virtual_reservoir_price_bid-Tuple{Any, Int64, Int64}","page":"API Reference","title":"IARA.time_series_virtual_reservoir_price_bid","text":"time_series_virtual_reservoir_price_bid(inputs, period::Int, scenario::Int)\n\nReturn the virtual reservoir price bid time series for the given period and scenario.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.time_series_virtual_reservoir_quantity_bid-Tuple{Any, Int64, Int64}","page":"API Reference","title":"IARA.time_series_virtual_reservoir_quantity_bid","text":"time_series_virtual_reservoir_quantity_bid(inputs, period::Int, scenario::Int)\n\nReturn the virtual reservoir quantity bid time series for the given period and scenario.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.train_min_cost-Tuple{String}","page":"API Reference","title":"IARA.train_min_cost","text":"train_min_cost(path::String; kwargs...)\n\nTrain the model to minimize the total cost of the system.\n\nkeywords:\n\noutputs_path::String. Path to the outputs. default = joinpath(path, \"outputs\")\nplot_outputs::Bool. Plot all outputs after the run. default = true\nwrite_lp::Bool. Write the LP files. default = false\ndelete_output_folder_before_execution::Bool. Delete the output folder before execution. default = false\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.train_min_cost_model_action-Tuple","page":"API Reference","title":"IARA.train_min_cost_model_action","text":"train_min_cost_model_action(args...)\n\nMin cost model action.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.train_mincost_iteration_limit-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.train_mincost_iteration_limit","text":"train_mincost_iteration_limit(inputs::AbstractInputs)\n\nReturn the iteration limit.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.train_mincost_time_limit_sec-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.train_mincost_time_limit_sec","text":"train_mincost_time_limit_sec(inputs::AbstractInputs)\n\nReturn the time limit for the case.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.train_model_and_run_simulation-Tuple{IARA.Inputs, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.train_model_and_run_simulation","text":"train_model_and_run_simulation(inputs::Inputs, run_time_options::RunTimeOptions)\n\nTrain the model and run the simulation.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.treat_energy_arrival_by_pairs_of_agents-Tuple{PSRBridge.AbstractInputs, IARA.RunTimeOptions, Vector{Float64}}","page":"API Reference","title":"IARA.treat_energy_arrival_by_pairs_of_agents","text":"treat_energy_arrival_by_pairs_of_agents(\n    inputs::AbstractInputs,\n    run_time_options::RunTimeOptions,\n    vr_energy_arrival::Vector{Float64},\n)\n\nDistribute the virtual reservoir energy arrival across asset owners based on their inflow allocation.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_asset_owner!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_asset_owner!","text":"update_asset_owner!(db::DatabaseSQLite, label::String; kwargs...)\n\nUpdate the AssetOwner named 'label' in the database.\n\nExample:\n\nIARA.update_asset_owner!(\n    db,\n    \"AssetOwner1\";\n    price_type = IARA.AssetOwner_PriceType.PRICE_TAKER\n)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_battery_unit!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_battery_unit!","text":"update_battery_unit!(db::DatabaseSQLite, label::String; kwargs...)\n\nUpdate the Battery Unit named 'label' in the database.\n\nExample:\n\nIARA.update_battery_unit!(\n    db,\n    \"BatteryUnit1\";\n    initial_storage = 0.0,\n)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_battery_unit_relation!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_battery_unit_relation!","text":"update_battery_unit_relation!(db::DatabaseSQLite, battery_unit_label::String; collection::String, relation_type::String, related_label::String)\n\nUpdate the Battery Unit named 'label' in the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_bidding_group!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_bidding_group!","text":"update_bidding_group!(db::DatabaseSQLite, label::String; kwargs...)\n\nUpdate the BiddingGroup named 'label' in the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_bidding_group_relation!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_bidding_group_relation!","text":"update_bidding_group_relation!(db::DatabaseSQLite, bidding_group_label::String; collection::String, relation_type::String, related_label::String)\n\nUpdate the BiddingGroup named 'label' in the database.\n\nExample:\n\nIARA.update_bidding_group_relation!(\n    db,\n    \"bg_1\";\n    collection = \"AssetOwner\",\n    relation_type = \"id\",\n    related_label = \"asset_owner_2\",\n)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_bidding_group_vectors!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_bidding_group_vectors!","text":"update_bidding_group_vectors!(db::DatabaseSQLite, label::String; kwargs...)\n\nUpdate the vectors of the Bidding Group named 'label' in the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_branch!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_branch!","text":"update_branch!(db::DatabaseSQLite, label::String; kwargs...)\n\nUpdate the Branch named 'label' in the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_branch_relation!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_branch_relation!","text":"update_branch_relation!(db::DatabaseSQLite, branch_label::String; collection::String, relation_type::String, related_label::String)\n\nUpdate the Branch named 'label' in the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_bus!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_bus!","text":"update_bus!(db::DatabaseSQLite, label::String; kwargs...)\n\nUpdate the Bus named 'label' in the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_bus_relation!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_bus_relation!","text":"update_bus_relation!(\n    db::DatabaseSQLite,\n    bus_label::String;\n    collection::String,\n    relation_type::String,\n    related_label::String,\n)\n\nUpdate the relation of the bus named bus_label with the collection collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_configuration!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite}","page":"API Reference","title":"IARA.update_configuration!","text":"update_configuration!(db::DatabaseSQLite; kwargs...)\n\nUpdate the Configuration table in the database.\n\nExample:\n\nIARA.update_configuration!(\n    db;\n    number_of_scenarios = 12,\n)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_dc_line!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_dc_line!","text":"update_dc_line!(db::DatabaseSQLite, label::String; kwargs...)\n\nUpdate the DC Line named 'label' in the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_dc_line_relation!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_dc_line_relation!","text":"update_dc_line_relation!(db::DatabaseSQLite, dc_line_label::String; collection::String, relation_type::String, related_label::String)\n\nUpdate the DC Line named 'label' in the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_dc_line_time_series_parameter!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String, String, Any}","page":"API Reference","title":"IARA.update_dc_line_time_series_parameter!","text":"update_dc_line_time_series_parameter!(db::DatabaseSQLite, label::String, attribute::String, value; dimensions...)\n\nUpdate a DC Line time series parameter in the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_demand_unit!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_demand_unit!","text":"update_demand!(db::DatabaseSQLite, label::String; kwargs...)\n\nUpdate the Demand named 'label' in the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_demand_unit_relation!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_demand_unit_relation!","text":"update_demand_unit_relation!(db::DatabaseSQLite, demand_label::String; collection::String, relation_type::String, related_label::String)\n\nUpdate the Demand named 'label' in the database.\n\nExample:\n\nIARA.update_demand_unit_relation!(\n    db, \n    \"dem_1\"; \n    collection = \"Bus\", \n    relation_type = \"id\", \n    related_label = \"bus_3\"\n)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_gauging_station!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_gauging_station!","text":"update_gauging_station!(db::DatabaseSQLite, label::String; kwargs...)\n\nUpdate the GaugingStation named 'label' in the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_gauging_station_relation!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_gauging_station_relation!","text":"update_gauging_station_relation!(db::DatabaseSQLite, label::String; collection::String, relation_type::String, related_label::String)\n\nUpdate the relation of the GaugingStation named 'label' in the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_hydro_unit!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_hydro_unit!","text":"update_hydro_unit!(db::DatabaseSQLite, label::String; kwargs...)\n\nUpdate the Hydro Unit named 'label' in the database.\n\nExample:\n\nIARA.update_hydro_unit!(\n    db,\n    \"hyd_1\";\n    initial_volume = 1000.0\n)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_hydro_unit_relation!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_hydro_unit_relation!","text":"update_hydro_unit_relation!(\n    db::DatabaseSQLite, \n    hydro_unit_label::String; \n    collection::String, \n    relation_type::String, \n    related_label::String\n)\n\nUpdate the Hydro Unit named 'label' in the database.\n\nArguments:\n\ndb::PSRClassesInterface.DatabaseSQLite: Database\nhydro_unit_label::String: Hydro Unit label\ncollection::String: Collection name that the Hydro Unit is related to\nrelation_type::String: Relation type\nrelated_label::String: Label of the element that the Hydro Unit is related to\n\nExample:\n\nIARA.update_hydro_unit_relation!(db, \"hyd_1\";\n    collection = \"BiddingGroup\",\n    relation_type = \"id\",\n    related_label = \"bg_1\",\n)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_hydro_unit_time_series_parameter!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String, String, Any}","page":"API Reference","title":"IARA.update_hydro_unit_time_series_parameter!","text":"update_hydro_unit_time_series_parameter!(\n    db::DatabaseSQLite, \n    label::String, \n    attribute::String, \n    value; \n    dimensions...\n)\n\nUpdate a Hydro Unit time series parameter in the database for a given dimension value\n\nArguments:\n\ndb::PSRClassesInterface.DatabaseSQLite: Database\nlabel::String: Hydro Unit label\nattribute::String: Attribute name\nvalue: Value to be updated\ndimensions...: Dimension values\n\nExample:\n\nIARA.update_hydro_unit_time_series_parameter!(\n    db,\n    \"hyd_1\",\n    \"max_volume\",\n    30.0;\n    date_time = DateTime(0), # dimension value\n)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_hydro_unit_vectors!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_hydro_unit_vectors!","text":"update_hydro_unit_vectors!(db::DatabaseSQLite, label::String; kwargs...)\n\nUpdate the vectors of the Hydro Unit named 'label' in the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_interconnection!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_interconnection!","text":"update_interconnection!(db::DatabaseSQLite, label::String; kwargs...)\n\nUpdate the Interconnection named 'label' in the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_interconnection_relation!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_interconnection_relation!","text":"update_interconnection_relation!(db::DatabaseSQLite, interconnection_label::String; collection::String, relation_type::String, related_label::String)\n\nUpdate the Interconnection named 'label' in the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_interconnection_time_series_parameter!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String, String, Any}","page":"API Reference","title":"IARA.update_interconnection_time_series_parameter!","text":"update_interconnection_time_series_parameter!(db::DatabaseSQLite, label::String, attribute::String, value; dimensions...)\n\nUpdate a Interconnection time series parameter in the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_renewable_unit!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_renewable_unit!","text":"update_renewable_unit!(db::DatabaseSQLite, label::String; kwargs...)\n\nUpdate the Renewable Unit named 'label' in the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_renewable_unit_relation!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_renewable_unit_relation!","text":"update_renewable_unit_relation!(db::DatabaseSQLite, renewable_unit_label::String; collection::String, relation_type::String, related_label::String)\n\nUpdate the Renewable Unit named 'label' in the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_renewable_unit_time_series!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_renewable_unit_time_series!","text":"update_renewable_unit_time_series!(db::DatabaseSQLite, label::String; date_time::DateTime = DateTime(0), kwargs...)\n\nUpdate time series attributes for the Renewable Unit named 'label' in the database.\n\nExample:\n\nIARA.update_renewable_unit_time_series!(db, \"gnd_1\"; max_generation = 4.5)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_thermal_unit!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_thermal_unit!","text":"update_thermal_unit!(db::DatabaseSQLite, label::String; kwargs...)\n\nUpdate the Thermal Unit named 'label' in the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_thermal_unit_relation!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_thermal_unit_relation!","text":"update_thermal_unit_relation!(db::DatabaseSQLite, thermal_unit_label::String; collection::String, relation_type::String, related_label::String)\n\nUpdate the Thermal Unit named 'label' in the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_thermal_unit_time_series_parameter!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String, String, Any}","page":"API Reference","title":"IARA.update_thermal_unit_time_series_parameter!","text":"update_thermal_unit_time_series_parameter!(\n    db::DatabaseSQLite, \n    label::String, \n    attribute::String, \n    value; \n    dimensions...\n)\n\nUpdate a Thermal Unit time series parameter in the database for a given dimension value\n\nArguments:\n\ndb::PSRClassesInterface.DatabaseSQLite: Database\nlabel::String: Thermal Unit label\nattribute::String: Attribute name\nvalue: Value to be updated\ndimensions...: Dimension values\n\nExample:\n\nIARA.update_thermal_unit_time_series_parameter!(\n    db,\n    \"therm_1\",\n    \"om_cost\",\n    30.0;\n    date_time = DateTime(0), # dimension value\n)\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_time_series_from_db!-Tuple{IARA.BatteryUnit, PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, DateTime}","page":"API Reference","title":"IARA.update_time_series_from_db!","text":"update_time_series_from_db!(battery_unit::BatteryUnit, db::DatabaseSQLite, period_date_time::DateTime)\n\nUpdate the Battery Unit time series from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_time_series_from_db!-Tuple{IARA.BiddingGroup, PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, DateTime}","page":"API Reference","title":"IARA.update_time_series_from_db!","text":"update_time_series_from_db!(bidding_group::BiddingGroup, db::DatabaseSQLite, period_date_time::DateTime)\n\nUpdate the BiddingGroup time series from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_time_series_from_db!-Tuple{IARA.Branch, PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, DateTime}","page":"API Reference","title":"IARA.update_time_series_from_db!","text":"update_time_series_from_db!(branch::Branch, db::DatabaseSQLite, period_date_time::DateTime)\n\nUpdate the Branch collection time series from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_time_series_from_db!-Tuple{IARA.DCLine, PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, DateTime}","page":"API Reference","title":"IARA.update_time_series_from_db!","text":"update_time_series_from_db!(dc_link::DCLine, db::DatabaseSQLite, period_date_time::DateTime)\n\nUpdate the DC Line collection time series from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_time_series_from_db!-Tuple{IARA.DemandUnit, PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, DateTime}","page":"API Reference","title":"IARA.update_time_series_from_db!","text":"update_time_series_from_db!(demand_unit::DemandUnit, db::DatabaseSQLite, period_date_time::DateTime)\n\nUpdate the Demand collection time series from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_time_series_from_db!-Tuple{IARA.HydroUnit, PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, DateTime}","page":"API Reference","title":"IARA.update_time_series_from_db!","text":"update_time_series_from_db!(hydro_unit::HydroUnit, db::DatabaseSQLite, period_date_time::DateTime)\n\nUpdate the Hydro Unit time series from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_time_series_from_db!-Tuple{IARA.Inputs, Int64}","page":"API Reference","title":"IARA.update_time_series_from_db!","text":"update_time_series_from_db!(inputs::Inputs, period::Int)\n\nUpdate the time series stored inside db file for the given period.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_time_series_from_db!-Tuple{IARA.Interconnection, PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, DateTime}","page":"API Reference","title":"IARA.update_time_series_from_db!","text":"update_time_series_from_db!(dc_link::Interconnection, db::DatabaseSQLite, period_date_time::DateTime)\n\nUpdate the Interconnection collection time series from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_time_series_from_db!-Tuple{IARA.RenewableUnit, PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, DateTime}","page":"API Reference","title":"IARA.update_time_series_from_db!","text":"update_time_series_from_db!(renewable_unit::RenewableUnit, db::DatabaseSQLite, period_date_time::DateTime)\n\nUpdate the Renewable Unit collection time series from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_time_series_from_db!-Tuple{IARA.ThermalUnit, PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, DateTime}","page":"API Reference","title":"IARA.update_time_series_from_db!","text":"update_time_series_from_db!(thermal_unit::ThermalUnit, db::DatabaseSQLite, period_date_time::DateTime)\n\nUpdate the time series of the Thermal Unit collection from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_time_series_from_db!-Tuple{IARA.VirtualReservoir, PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, DateTime}","page":"API Reference","title":"IARA.update_time_series_from_db!","text":"update_time_series_from_db!(virtual_reservoir::VirtualReservoir, db::DatabaseSQLite, period_date_time::DateTime)\n\nUpdate the VirtualReservoir time series from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_time_series_from_db!-Tuple{IARA.Zone, PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, DateTime}","page":"API Reference","title":"IARA.update_time_series_from_db!","text":"update_time_series_from_db!(zone::Zone, db::DatabaseSQLite, period_date_time::DateTime)\n\nUpdate the Zone collection time series from the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.update_zone!-Tuple{PSRClassesInterface.PSRDatabaseSQLite.DatabaseSQLite, String}","page":"API Reference","title":"IARA.update_zone!","text":"update_zone!(db::DatabaseSQLite, label::String; kwargs...)\n\nUpdate the Zone named 'label' in the database.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.use_binary_variables-Tuple{PSRBridge.AbstractInputs, Any}","page":"API Reference","title":"IARA.use_binary_variables","text":"use_binary_variables(inputs::AbstractInputs, run_time_options)\n\nReturn whether binary variables should be used.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.use_fcf_in_clearing-Tuple{IARA.Inputs, IARA.RunTimeOptions}","page":"API Reference","title":"IARA.use_fcf_in_clearing","text":"use_fcf_in_clearing(\n    inputs::Inputs, \n    run_time_options::RunTimeOptions\n)\n\nCheck if the clearing representation must read cuts.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.use_scaled_fcf_in_clearing-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.use_scaled_fcf_in_clearing","text":"use_scaled_fcf_in_clearing(inputs::AbstractInputs)\n\nReturn whether the FCF should be used in clearing.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.use_virtual_reservoirs-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.use_virtual_reservoirs","text":"use_virtual_reservoirs(inputs::AbstractInputs)\n\nReturn whether virtual reservoirs are used in clearing.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.validate-Tuple{Any}","page":"API Reference","title":"IARA.validate","text":"validate(inputs)\n\nvalidate that the inputs are consistent through all periods.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.validate-Tuple{IARA.AssetOwner}","page":"API Reference","title":"IARA.validate","text":"validate(asset_owner::AssetOwner)\n\nValidate the asset owner collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.validate-Tuple{IARA.BatteryUnit}","page":"API Reference","title":"IARA.validate","text":"validate(battery_unit::BatteryUnit)\n\nValidate the Battery's parameters. Returns the number of errors found.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.validate-Tuple{IARA.BiddingGroup}","page":"API Reference","title":"IARA.validate","text":"validate(bidding_group::BiddingGroup)\n\nValidate the BiddingGroup's parameters. Returns the number of errors found.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.validate-Tuple{IARA.Branch}","page":"API Reference","title":"IARA.validate","text":"validate(branch::Branch)\n\nValidate the Branch collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.validate-Tuple{IARA.Bus}","page":"API Reference","title":"IARA.validate","text":"validate(bus::Bus)\n\nValidate the bus collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.validate-Tuple{IARA.Configurations}","page":"API Reference","title":"IARA.validate","text":"validate(configurations::Configurations)\n\nValidate the Configurations' parameters. Return the number of errors found.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.validate-Tuple{IARA.DCLine}","page":"API Reference","title":"IARA.validate","text":"validate(dc_line::DCLine)\n\nValidate the DC Line collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.validate-Tuple{IARA.DemandUnit}","page":"API Reference","title":"IARA.validate","text":"validate(demand_unit::DemandUnit)\n\nValidate the Demand's parameters. Return the number of errors found.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.validate-Tuple{IARA.GaugingStation}","page":"API Reference","title":"IARA.validate","text":"validate(gauging_station::GaugingStation)\n\nValidate the gauging station collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.validate-Tuple{IARA.HydroUnit}","page":"API Reference","title":"IARA.validate","text":"validate(hydro_unit::HydroUnit)\n\nValidate the Hydro Units' parameters. Return the number of errors found.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.validate-Tuple{IARA.Interconnection}","page":"API Reference","title":"IARA.validate","text":"validate(interconnection::Interconnection)\n\nValidate the Interconnection collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.validate-Tuple{IARA.RenewableUnit}","page":"API Reference","title":"IARA.validate","text":"validate(renewable_unit::RenewableUnit)\n\nValidate the Renewable Units' parameters. Return the number of errors found.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.validate-Tuple{IARA.ThermalUnit}","page":"API Reference","title":"IARA.validate","text":"validate(thermal_unit::ThermalUnit)\n\nValidate the Thermal Units' parameters. Return the number of errors found.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.validate-Tuple{IARA.VirtualReservoir}","page":"API Reference","title":"IARA.validate","text":"validate(virtual_reservoir::VirtualReservoir)\n\nValidate the VirtualReservoir's parameters. Return the number of errors found.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.validate-Tuple{IARA.Zone}","page":"API Reference","title":"IARA.validate","text":"validate(zone::Zone)\n\nValidate the zone collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.validate-Tuple{String}","page":"API Reference","title":"IARA.validate","text":"validate(path::String; run_mode::String = \"market-clearing\")\n\nValidate the case based on the run_mode passed.\n\nThe available run modes are:\n\ntrain-min-cost\nmin-cost\nmarket-clearing\nsingle-period-market-clearing\nsingle-period-heuristic-bid\ninterface-call\nsingle-period-hydro-supply-reference-curve\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_asset_owner_indices-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_asset_owner_indices","text":"virtual_reservoir_asset_owner_indices(virtual_reservoir::AbstractCollection, i::Integer)\n\nGet the assetownerindices field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_asset_owner_indices-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_asset_owner_indices","text":"virtual_reservoir_asset_owner_indices(collections::AbstractCollections, i::Integer)\n\nGet the assetownerindices field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_asset_owner_indices-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.virtual_reservoir_asset_owner_indices","text":"virtual_reservoir_asset_owner_indices(collections::AbstractCollections)\n\nGet the asset_owner_indices field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_asset_owner_indices-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.virtual_reservoir_asset_owner_indices","text":"virtual_reservoir_asset_owner_indices(virtual_reservoir::AbstractCollection)\n\nGet the asset_owner_indices field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_asset_owner_indices-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_asset_owner_indices","text":"virtual_reservoir_asset_owner_indices(inputs::AbstractInputs, i::Integer)\n\nGet the assetownerindices field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_asset_owner_indices-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.virtual_reservoir_asset_owner_indices","text":"virtual_reservoir_asset_owner_indices(inputs::AbstractInputs)\n\nGet the asset_owner_indices field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_asset_owners_inflow_allocation-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_asset_owners_inflow_allocation","text":"virtual_reservoir_asset_owners_inflow_allocation(virtual_reservoir::AbstractCollection, i::Integer)\n\nGet the assetownersinflow_allocation field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_asset_owners_inflow_allocation-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_asset_owners_inflow_allocation","text":"virtual_reservoir_asset_owners_inflow_allocation(collections::AbstractCollections, i::Integer)\n\nGet the assetownersinflow_allocation field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_asset_owners_inflow_allocation-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.virtual_reservoir_asset_owners_inflow_allocation","text":"virtual_reservoir_asset_owners_inflow_allocation(collections::AbstractCollections)\n\nGet the asset_owners_inflow_allocation field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_asset_owners_inflow_allocation-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.virtual_reservoir_asset_owners_inflow_allocation","text":"virtual_reservoir_asset_owners_inflow_allocation(virtual_reservoir::AbstractCollection)\n\nGet the asset_owners_inflow_allocation field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_asset_owners_inflow_allocation-Tuple{PSRBridge.AbstractInputs, Int64, Int64}","page":"API Reference","title":"IARA.virtual_reservoir_asset_owners_inflow_allocation","text":"virtual_reservoir_asset_owners_inflow_allocation(inputs::AbstractInputs, vr::Int, ao::Int)\n\nReturn the inflow allocation of the asset owner ao in the VirtualReservoir vr.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_asset_owners_inflow_allocation-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_asset_owners_inflow_allocation","text":"virtual_reservoir_asset_owners_inflow_allocation(inputs::AbstractInputs, i::Integer)\n\nGet the assetownersinflow_allocation field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_asset_owners_inflow_allocation-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.virtual_reservoir_asset_owners_inflow_allocation","text":"virtual_reservoir_asset_owners_inflow_allocation(inputs::AbstractInputs)\n\nGet the asset_owners_inflow_allocation field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_asset_owners_initial_energy_account_share-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_asset_owners_initial_energy_account_share","text":"virtual_reservoir_asset_owners_initial_energy_account_share(virtual_reservoir::AbstractCollection, i::Integer)\n\nGet the assetownersinitialenergyaccount_share field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_asset_owners_initial_energy_account_share-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_asset_owners_initial_energy_account_share","text":"virtual_reservoir_asset_owners_initial_energy_account_share(collections::AbstractCollections, i::Integer)\n\nGet the assetownersinitialenergyaccount_share field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_asset_owners_initial_energy_account_share-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.virtual_reservoir_asset_owners_initial_energy_account_share","text":"virtual_reservoir_asset_owners_initial_energy_account_share(collections::AbstractCollections)\n\nGet the asset_owners_initial_energy_account_share field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_asset_owners_initial_energy_account_share-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.virtual_reservoir_asset_owners_initial_energy_account_share","text":"virtual_reservoir_asset_owners_initial_energy_account_share(virtual_reservoir::AbstractCollection)\n\nGet the asset_owners_initial_energy_account_share field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_asset_owners_initial_energy_account_share-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_asset_owners_initial_energy_account_share","text":"virtual_reservoir_asset_owners_initial_energy_account_share(inputs::AbstractInputs, i::Integer)\n\nGet the assetownersinitialenergyaccount_share field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_asset_owners_initial_energy_account_share-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.virtual_reservoir_asset_owners_initial_energy_account_share","text":"virtual_reservoir_asset_owners_initial_energy_account_share(inputs::AbstractInputs)\n\nGet the asset_owners_initial_energy_account_share field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_correspondence_by_generation!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.virtual_reservoir_correspondence_by_generation!","text":"virtual_reservoir_correspondence_by_generation!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the virtual reservoir correspondence by generation constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_correspondence_by_volume!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.virtual_reservoir_correspondence_by_volume!","text":"virtual_reservoir_correspondence_by_volume!(\n    model::SubproblemModel,\n    inputs::Inputs,\n    run_time_options::RunTimeOptions,\n    ::Type{SubproblemBuild},\n)\n\nAdd the virtual reservoir correspondence by volume constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_correspondence_type-Tuple{Any}","page":"API Reference","title":"IARA.virtual_reservoir_correspondence_type","text":"virtual_reservoir_correspondence_type(inputs)\n\nReturn the type of physical-virtual correspondence for the virtual reservoirs.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_energy_account!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Int64, Int64, Int64, Int64, Type{IARA.SubproblemUpdate}}","page":"API Reference","title":"IARA.virtual_reservoir_energy_account!","text":"virtual_reservoir_energy_account!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, scenario, subscenario, ::Type{SubproblemUpdate})\n\nUpdate the virtual reservoir energy account variables in the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_energy_account!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.virtual_reservoir_energy_account!","text":"virtual_reservoir_energy_account!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the virtual reservoir energy account variables to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_generation!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, IARA.SimulationResultsFromPeriodScenario, Int64, Int64, Int64, Type{IARA.WriteOutput}}","page":"API Reference","title":"IARA.virtual_reservoir_generation!","text":"virtual_reservoir_generation!(outputs, inputs::Inputs, run_time_options::RunTimeOptions, simulation_results::SimulationResultsFromPeriodScenario, period::Int, scenario::Int, subscenario::Int, ::Type{WriteOutput})\n\nWrite the virtual reservoir generation variables' values to the output file.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_generation!-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.InitializeOutput}}","page":"API Reference","title":"IARA.virtual_reservoir_generation!","text":"virtual_reservoir_generation!(outputs::Outputs, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{InitializeOutput})\n\nAdd symbols to serialize and query the virtual reservoir generation variables and initialize the output file for virtual reservoir generation.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_generation!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Int64, Int64, Int64, Int64, Type{IARA.SubproblemUpdate}}","page":"API Reference","title":"IARA.virtual_reservoir_generation!","text":"virtual_reservoir_generation!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, scenario, subscenario, ::Type{SubproblemUpdate})\n\nUpdate the virtual reservoir generation variables in the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_generation!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.virtual_reservoir_generation!","text":"virtual_reservoir_generation!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the virtual reservoir generation variables to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_generation_bounds!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.virtual_reservoir_generation_bounds!","text":"virtual_reservoir_generation_bounds!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the virtual reservoir generation bounds constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_generation_reference!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.virtual_reservoir_generation_reference!","text":"virtual_reservoir_generation_reference!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nConstraint matching virtual reservoir generation to the input reference generation for the reference curve model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_hydro_unit_indices-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_hydro_unit_indices","text":"virtual_reservoir_hydro_unit_indices(virtual_reservoir::AbstractCollection, i::Integer)\n\nGet the hydrounitindices field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_hydro_unit_indices-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_hydro_unit_indices","text":"virtual_reservoir_hydro_unit_indices(collections::AbstractCollections, i::Integer)\n\nGet the hydrounitindices field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_hydro_unit_indices-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.virtual_reservoir_hydro_unit_indices","text":"virtual_reservoir_hydro_unit_indices(collections::AbstractCollections)\n\nGet the hydro_unit_indices field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_hydro_unit_indices-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.virtual_reservoir_hydro_unit_indices","text":"virtual_reservoir_hydro_unit_indices(virtual_reservoir::AbstractCollection)\n\nGet the hydro_unit_indices field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_hydro_unit_indices-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_hydro_unit_indices","text":"virtual_reservoir_hydro_unit_indices(inputs::AbstractInputs, i::Integer)\n\nGet the hydrounitindices field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_hydro_unit_indices-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.virtual_reservoir_hydro_unit_indices","text":"virtual_reservoir_hydro_unit_indices(inputs::AbstractInputs)\n\nGet the hydro_unit_indices field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_initial_energy_account-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_initial_energy_account","text":"virtual_reservoir_initial_energy_account(virtual_reservoir::AbstractCollection, i::Integer)\n\nGet the initialenergyaccount field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_initial_energy_account-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_initial_energy_account","text":"virtual_reservoir_initial_energy_account(collections::AbstractCollections, i::Integer)\n\nGet the initialenergyaccount field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_initial_energy_account-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.virtual_reservoir_initial_energy_account","text":"virtual_reservoir_initial_energy_account(collections::AbstractCollections)\n\nGet the initial_energy_account field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_initial_energy_account-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.virtual_reservoir_initial_energy_account","text":"virtual_reservoir_initial_energy_account(virtual_reservoir::AbstractCollection)\n\nGet the initial_energy_account field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_initial_energy_account-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_initial_energy_account","text":"virtual_reservoir_initial_energy_account(inputs::AbstractInputs, i::Integer)\n\nGet the initialenergyaccount field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_initial_energy_account-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.virtual_reservoir_initial_energy_account","text":"virtual_reservoir_initial_energy_account(inputs::AbstractInputs)\n\nGet the initial_energy_account field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_label-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_label","text":"virtual_reservoir_label(virtual_reservoir::AbstractCollection, i::Integer)\n\nGet the label field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_label-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_label","text":"virtual_reservoir_label(collections::AbstractCollections, i::Integer)\n\nGet the label field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_label-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.virtual_reservoir_label","text":"virtual_reservoir_label(collections::AbstractCollections)\n\nGet the label field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_label-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.virtual_reservoir_label","text":"virtual_reservoir_label(virtual_reservoir::AbstractCollection)\n\nGet the label field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_label-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_label","text":"virtual_reservoir_label(inputs::AbstractInputs, i::Integer)\n\nGet the label field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_label-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.virtual_reservoir_label","text":"virtual_reservoir_label(inputs::AbstractInputs)\n\nGet the label field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_markup_bids_for_period_scenario-Tuple{IARA.Inputs, IARA.RunTimeOptions, Int64, Int64}","page":"API Reference","title":"IARA.virtual_reservoir_markup_bids_for_period_scenario","text":"virtual_reservoir_markup_bids_for_period_scenario(\n    inputs::Inputs, \n    outputs::Outputs, \n    run_time_options::RunTimeOptions, \n    period::Int, \n    scenario::Int\n)\n\nGenerate heuristic bids for the virtual reservoirs and write them to the output files.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_non_decreasing_reference_quantity!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.virtual_reservoir_non_decreasing_reference_quantity!","text":"virtual_reservoir_non_decreasing_reference_quantity!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nConstraint ensuring the reference quantity for each virtual reservoir does not decrease at each iteration.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_previous_reference_quantity!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.virtual_reservoir_previous_reference_quantity!","text":"virtual_reservoir_previous_reference_quantity!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nVirtual reservoir total generation variable and parameter initialization for the reference curve model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_price_bid_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_price_bid_file","text":"virtual_reservoir_price_bid_file(virtual_reservoir::AbstractCollection, i::Integer)\n\nGet the pricebidfile field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_price_bid_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_price_bid_file","text":"virtual_reservoir_price_bid_file(collections::AbstractCollections, i::Integer)\n\nGet the pricebidfile field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_price_bid_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.virtual_reservoir_price_bid_file","text":"virtual_reservoir_price_bid_file(collections::AbstractCollections)\n\nGet the price_bid_file field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_price_bid_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.virtual_reservoir_price_bid_file","text":"virtual_reservoir_price_bid_file(virtual_reservoir::AbstractCollection)\n\nGet the price_bid_file field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_price_bid_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_price_bid_file","text":"virtual_reservoir_price_bid_file(inputs::AbstractInputs, i::Integer)\n\nGet the pricebidfile field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_price_bid_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.virtual_reservoir_price_bid_file","text":"virtual_reservoir_price_bid_file(inputs::AbstractInputs)\n\nGet the price_bid_file field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_quantity_bid_file-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_quantity_bid_file","text":"virtual_reservoir_quantity_bid_file(virtual_reservoir::AbstractCollection, i::Integer)\n\nGet the quantitybidfile field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_quantity_bid_file-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_quantity_bid_file","text":"virtual_reservoir_quantity_bid_file(collections::AbstractCollections, i::Integer)\n\nGet the quantitybidfile field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_quantity_bid_file-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.virtual_reservoir_quantity_bid_file","text":"virtual_reservoir_quantity_bid_file(collections::AbstractCollections)\n\nGet the quantity_bid_file field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_quantity_bid_file-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.virtual_reservoir_quantity_bid_file","text":"virtual_reservoir_quantity_bid_file(virtual_reservoir::AbstractCollection)\n\nGet the quantity_bid_file field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_quantity_bid_file-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_quantity_bid_file","text":"virtual_reservoir_quantity_bid_file(inputs::AbstractInputs, i::Integer)\n\nGet the quantitybidfile field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_quantity_bid_file-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.virtual_reservoir_quantity_bid_file","text":"virtual_reservoir_quantity_bid_file(inputs::AbstractInputs)\n\nGet the quantity_bid_file field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_total_generation!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.virtual_reservoir_total_generation!","text":"virtual_reservoir_total_generation!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nVirtual reservoir total generation variable and parameter initialization for the reference curve model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_total_generation_correspondence!-Tuple{IARA.SubproblemModel, IARA.Inputs, IARA.RunTimeOptions, Type{IARA.SubproblemBuild}}","page":"API Reference","title":"IARA.virtual_reservoir_total_generation_correspondence!","text":"virtual_reservoir_total_generation_correspondence!(model::SubproblemModel, inputs::Inputs, run_time_options::RunTimeOptions, ::Type{SubproblemBuild})\n\nAdd the virtual reservoir correspondence by generation constraints to the model.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_water_to_energy_factors-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_water_to_energy_factors","text":"virtual_reservoir_water_to_energy_factors(virtual_reservoir::AbstractCollection, i::Integer)\n\nGet the watertoenergy_factors field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_water_to_energy_factors-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_water_to_energy_factors","text":"virtual_reservoir_water_to_energy_factors(collections::AbstractCollections, i::Integer)\n\nGet the watertoenergy_factors field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_water_to_energy_factors-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.virtual_reservoir_water_to_energy_factors","text":"virtual_reservoir_water_to_energy_factors(collections::AbstractCollections)\n\nGet the water_to_energy_factors field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_water_to_energy_factors-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.virtual_reservoir_water_to_energy_factors","text":"virtual_reservoir_water_to_energy_factors(virtual_reservoir::AbstractCollection)\n\nGet the water_to_energy_factors field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_water_to_energy_factors-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.virtual_reservoir_water_to_energy_factors","text":"virtual_reservoir_water_to_energy_factors(inputs::AbstractInputs, i::Integer)\n\nGet the watertoenergy_factors field from the VirtualReservoir collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.virtual_reservoir_water_to_energy_factors-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.virtual_reservoir_water_to_energy_factors","text":"virtual_reservoir_water_to_energy_factors(inputs::AbstractInputs)\n\nGet the water_to_energy_factors field from the VirtualReservoir collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.write_parp_outputs-Tuple{IARA.Inputs, Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}, Matrix{Float64}, Matrix{Float64}}","page":"API Reference","title":"IARA.write_parp_outputs","text":"write_parp_outputs(\n    inputs::Inputs,\n    inflow::Array{Float64, 3},\n    noise::Array{Float64, 3},\n    parp_coefficients::Array{Float64, 3},\n    inflow_period_average::Array{Float64, 2},\n    inflow_period_std_dev::Array{Float64, 2},\n)\n\nWrite PAR(p) outputs to files.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.write_timeseries_file-Union{Tuple{N}, Tuple{T}, Tuple{String, Array{T, N}}} where {T, N}","page":"API Reference","title":"IARA.write_timeseries_file","text":"write_timeseries_file(\n    file_path::String, \n    data::Array{T, N};\n    dimensions::Vector{String},\n    labels::Vector{String},\n    time_dimension::String,\n    dimension_size::Vector{Int},\n    initial_date::Union{String, DateTime} = \"\",\n    unit::String = \"\",\n) where {T, N}\n\nWrite a time series file in Quiver format.\n\nRequired arguments:\n\nfile_path::String: Path to the CSV file.\ndata::Array{T, N}: Data to be written.\ndimensions::Vector{String}: Dimensions of the data.\nlabels::Vector{String}: Labels of the data.\ntime_dimension::String: Name of the time dimension.\ndimension_size::Vector{Int}: Size of each dimension.\ninitial_date::Union{String, DateTime}: Initial date of the time series. If a string is provided, it should be in the format \"yyyy-mm-ddTHH:MM:SS\".\nunit::String: Unit of the time series data.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.write_virtual_reservoir_next_period_inflow_energy_arrival-Tuple{IARA.Outputs, IARA.Inputs, IARA.RunTimeOptions, Int64, Int64, Int64}","page":"API Reference","title":"IARA.write_virtual_reservoir_next_period_inflow_energy_arrival","text":"write_virtual_reservoir_next_period_inflow_energy_arrival(\n    outputs::Outputs,\n    inputs::Inputs,\n    run_time_options::RunTimeOptions,\n    period::Int,\n    scenario::Int,\n    subscenario::Int,\n)\n\nWrite the virtual reservoir inflow energy arrival for the NEXT period. This is used in singleperiodmarket_clearing to show what energy will arrive in the next period. The calculation uses the volume at the END of the current period (from the clearing results) and the inflow series for the next period.\n\nFor period 1, we use the volumes directly from simulationresults (if provided). For period > 1, we read from the serialized file using hydrovolumefromprevious_period.\n\nNote: The inflow varies by scenario for ONLYEXANTE, and by scenario and subscenario for ONLYEXPOST or EXANTEANDEXPOST.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.zone_label-Tuple{PSRBridge.AbstractCollection, Integer}","page":"API Reference","title":"IARA.zone_label","text":"zone_label(zone::AbstractCollection, i::Integer)\n\nGet the label field from the Zone collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.zone_label-Tuple{PSRBridge.AbstractCollections, Integer}","page":"API Reference","title":"IARA.zone_label","text":"zone_label(collections::AbstractCollections, i::Integer)\n\nGet the label field from the Zone collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.zone_label-Tuple{PSRBridge.AbstractCollections}","page":"API Reference","title":"IARA.zone_label","text":"zone_label(collections::AbstractCollections)\n\nGet the label field from the Zone collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.zone_label-Tuple{PSRBridge.AbstractCollection}","page":"API Reference","title":"IARA.zone_label","text":"zone_label(zone::AbstractCollection)\n\nGet the label field from the Zone collection.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.zone_label-Tuple{PSRBridge.AbstractInputs, Integer}","page":"API Reference","title":"IARA.zone_label","text":"zone_label(inputs::AbstractInputs, i::Integer)\n\nGet the label field from the Zone collection at index i.\n\n\n\n\n\n","category":"method"},{"location":"api_reference.html#IARA.zone_label-Tuple{PSRBridge.AbstractInputs}","page":"API Reference","title":"IARA.zone_label","text":"zone_label(inputs::AbstractInputs)\n\nGet the label field from the Zone collection.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/case_04_run_multi_min_activation.html#Min-activation-Bid-Running","page":"Min activation Bid - Running","title":"Min activation Bid - Running","text":"The data for this case is available in the folder data/case_4\n\nusing Dates\nusing DataFrames\nusing IARA\n; #hide\nnothing #hide","category":"section"},{"location":"tutorial/case_04_run_multi_min_activation.html#Case-recap","page":"Min activation Bid - Running","title":"Case recap","text":"In the previous section, we started from the Case 3 elements and created a case with a minimum activation level for a Bidding Group.\n\nLet's create a folder to store the output of the MARKET_CLEARING mode and define the path to the original case.\n\nconst PATH_EXECUTION = joinpath(@__DIR__, \"case_4_execution\")\n\nif !isdir(PATH_EXECUTION)\n    mkdir(PATH_EXECUTION)\nend\n\nconst PATH_ORIGINAL = joinpath(@__DIR__, \"data\", \"case_4\")\n\ncp(PATH_ORIGINAL, PATH_EXECUTION; force = true);\n#hide\n\nBefore running, let's load the case and update the run mode to MARKET_CLEARING.\n\ndb = IARA.load_study(PATH_EXECUTION; read_only = false)\n\nIARA.update_configuration!(\n    db;\n    construction_type_ex_ante_physical = IARA.Configurations_ConstructionType.HYBRID,\n    construction_type_ex_ante_commercial = IARA.Configurations_ConstructionType.HYBRID,\n    construction_type_ex_post_physical = IARA.Configurations_ConstructionType.HYBRID,\n    construction_type_ex_post_commercial = IARA.Configurations_ConstructionType.HYBRID,\n)\n\nIARA.close_study!(db)\n; #hide\nnothing #hide\n\nNow we are able to run the case with IARA.market_clearing.\n\nIARA.market_clearing(\n    PATH_EXECUTION;\n    delete_output_folder_before_execution = true,\n)","category":"section"},{"location":"tutorial/case_04_run_multi_min_activation.html#Analyzing-the-results","page":"Min activation Bid - Running","title":"Analyzing the results","text":"The results are stored inside the case folder, in the outputs directory.\n\ncase_folder\n ├── outputs\n │    ├── plots\n │    │   └── ...\n │    └── ...\n └── ...\n\n<iframe src=\"case_4_execution\\\\outputs\\\\plots\\\\bidding_group_generation_ex_ante_commercial_all.html\" style=\"height:500px;width:100%;\"></iframe>\n\n<iframe src=\"case_4_execution\\\\outputs\\\\plots\\\\bidding_group_generation_profile_ex_ante_commercial_all.html\" style=\"height:500px;width:100%;\"></iframe>\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"centralized_operation_problem.html#Centralized-Operation-Problem","page":"Centralized operation problem","title":"Centralized Operation Problem","text":"","category":"section"},{"location":"centralized_operation_problem.html#Sets","page":"Centralized operation problem","title":"Sets","text":"J^T: Set of thermal units.\nJ^TC: Set of commitment thermal units.\nJ^H: Set of hydro units.\nJ^HC: Set of commitment hydro units.\nJ^HR: Set of hydro units that operate with a reservoir.\nJ^HRR: Set of hydro units that operate with as run-of-the-river.\nJ^R: Set of renewable units.\nJ^B: Set of battery units.\nJ^D: Set of demands.\nJ^DI: Set of inelastic demands.\nJ^DE: Set of elastic demands. J^DE cap J^DI = emptyset.\nJ^DF: Set of flexible demands. J^DF cap J^DE = J^DF cap J^DI = emptyset.\nL: Set of transmission lines.\nN: Set of network nodes (a.k.a. buses).\nZ: Set of zones.\nN^-ref: Set of network nodes, except for the angle reference node.\nB(t): Set of subperiods in period t.\nL^in(n): Set of lines entering node n.\nL^out(n): Set of lines exiting node n.\nI^in(z): Set of interconnections entering zone z.\nI^out(z): Set of interconnections exiting zone z.\nJ^H_U(j): Set of hydro units that turbine water to hydro unit j.\nJ^H_Z(j): Set of hydro units that spill water to hydro unit j.\nB(j t w): Set of subperiods in window w of flexible demand j at period t.\nL^DC: Set of DC lines. L^DC subseteq L.\nL^AC: Set of branches. L^AC = L setminus L^DC.\nI: Set of interconnections.\n\nNote: \n\nThe set J^T(n) is defined as the set of thermal units connected to node n.\nThe set J^T(z) is defined as the set of thermal units connected to zone z.\n\nAll other sets are defined similarly.\n\nSome branches may have a flag indicating that they are modeled as DC lines.","category":"section"},{"location":"centralized_operation_problem.html#Parameters","page":"Centralized operation problem","title":"Parameters","text":"d(tau): Duration in hours of subperiod tau.\nC_u rightarrow v: Conversion factor from unit u to unit v.","category":"section"},{"location":"centralized_operation_problem.html#Hydro-Units","page":"Centralized operation problem","title":"Hydro Units","text":"V_j: Maximum volume of water (hm^3) in the reservoir of hydro unit j.\nU_j: Maximum amount of water (m^3s) that can be turbined from the hydro unit j.\nrho_j: Turbine efficiency (MWm^3s) of hydro unit j.\na_j tau: Inflow of water (hm^3) into the reservoir of hydro unit j at the start of subperiod tau.\nO_j: Minimum outflow of water (m^3s) from the reservoir of hydro unit j.\nC^eta: Cost (hm^3) of minimum outflow violation.\nC^z_j: Cost (hm^3) of spilling water from hydro unit j.\noverlineG^H_j: Maximum generation (MW) of hydro unit j.\nunderlineG^H_j: Minimum generation (MW) of hydro unit j.","category":"section"},{"location":"centralized_operation_problem.html#Thermal-Units","page":"Centralized operation problem","title":"Thermal Units","text":"overlineG^T_j: Maximum generation (MW) of thermal unit j.\nunderlineG^T_j: Minimum generation (MW) of thermal unit j.\nC^T_j: Cost of generation (MWh) of thermal unit j.\nC^T_up_j: Cost of startup () of thermal unit j.\nC^T_down_j: Cost of shutdown () of thermal unit j.\nx^T_j 0: Commitment of thermal unit j at the start of the period.\nDelta^up_j: Ramp-up limit (MWmin) of thermal unit j.\nDelta^down_j: Ramp-down limit (MWmin) of thermal unit j.\ng^T_j 0: Generation (MW) of thermal unit j at the start of the period.\nUT^max_j: Maximum uptime (h) of thermal unit j.\nUT^min_j: Minimum uptime (h) of thermal unit j.\nDT^min_j: Minimum downtime (h) of thermal unit j.\nt^up_j0: Uptime (h) of thermal unit j at the start of the period.\nt^down_j0: Downtime (h) of thermal unit j at the start of the period.","category":"section"},{"location":"centralized_operation_problem.html#Renewable-Units","page":"Centralized operation problem","title":"Renewable Units","text":"G^R_j: Maximum generation (MW) of renewable unit j.\nG^R_j tau(omega): Realized generation (pu, as a fraction of the maximum generation) of renewable unit j during subperiod tau and scenario omega.\nC^Rz_j: Cost of curtailment (MWh) of renewable unit j.\nC^R_j: Cost of generation (MWh) of renewable unit j.","category":"section"},{"location":"centralized_operation_problem.html#Battery-Units","page":"Centralized operation problem","title":"Battery Units","text":"G^B_j: Maximum generation (MW) of battery unit j.\noverlines^B_j: Maximum state (MWh) of charge of battery unit j.\nunderlines^B_j: Minimum state (MWh) of charge of battery unit j.\nC^S_j: Cost of storage (MWh) of battery unit j.","category":"section"},{"location":"centralized_operation_problem.html#Demands","page":"Centralized operation problem","title":"Demands","text":"D_j tau(omega): Load (GWh) of demand j during subperiod tau and scenario omega.\nC^delta: Cost of demand deficit (MWh).\nC^delta^F_j tau: Cost demand curtailment (MWh) of demand j during subperiod tau.\nP_j tau(omega): Maximum price (MWh) of elastic demand j during subperiod tau and scenario omega.\nW_j t: Window of demand j at period t, if j in J^DF.\nunderlined^F_j: Maximum fraction of flexible demand j to be under attended at some subperiod.\noverlined^F_j: Maximum fraction of flexible demand j to be over attended at some subperiod.\noverlinedelta^F_j: Maximum fraction of flexible demand j to be curtailed at a window.","category":"section"},{"location":"centralized_operation_problem.html#Interconections","page":"Centralized operation problem","title":"Interconections","text":"Z^from_j: Zone where interconnection j starts.\nZ^to_j: Zone where interconnection j ends.\noverlinef^Z from_j: Maximum flow (MW) from zone Z^to_j to zone zone^from_j.\noverlinef^Z to_j: Maximum flow (MW) from zone Z^from_j to zone zone^to_j.","category":"section"},{"location":"centralized_operation_problem.html#DC-Lines","page":"Centralized operation problem","title":"DC Lines","text":"n^from_j: Node where line j starts.\nn^to_j: Node where line j ends.\noverlinef^from_j: Maximum flow (MW) from node n^to_j to node n^from_j.\noverlinef^to_j: Maximum flow (MW) from node n^from_j to node n^to_j.","category":"section"},{"location":"centralized_operation_problem.html#Branches","page":"Centralized operation problem","title":"Branches","text":"n^from_j: Node where line j starts.\nn^to_j: Node where line j ends.\noverlinef_j: Maximum flow (MW) of line j.\nX_j: Reactance (pu) of line j.","category":"section"},{"location":"centralized_operation_problem.html#Variables","page":"Centralized operation problem","title":"Variables","text":"","category":"section"},{"location":"centralized_operation_problem.html#Hydro-Units-2","page":"Centralized operation problem","title":"Hydro Units","text":"g^H_j tau: Generation (MWh) of hydro unit j during subperiod tau.\nv_j tau: Volume of water (hm^3) in the reservoir at the start of subperiod tau.\nu_j tau: Turbined water (hm^3) from the reservoir during subperiod tau.\nz_j tau: Spilled water (hm^3) from the reservoir during subperiod tau.\nv^S_in_j: Volume of water (hm^3) in the reservoir at the start of the period.\nv^S_out_j: Volume of water (hm^3) in the reservoir at the end of the period.\na^S_j tau: Inflow slack (m^3s) of hydro unit j during subperiod tau.\neta_j tau: Hydro minimum outflow violation (hm^3) during subperiod tau.\nx^H_j tau: Commitment of hydro unit j during subperiod tau.","category":"section"},{"location":"centralized_operation_problem.html#Thermal-Units-2","page":"Centralized operation problem","title":"Thermal Units","text":"g^T_j tau: Generation (MWh) of thermal unit j during subperiod tau.\nx^T_j tau: Commitment of thermal unit j during subperiod tau.\ny^T_j tau: Startup of thermal unit j during subperiod tau.\nw^T_j tau: Shutdown of thermal unit j during subperiod tau.","category":"section"},{"location":"centralized_operation_problem.html#Renewable-Units-2","page":"Centralized operation problem","title":"Renewable Units","text":"g^R_j tau: Generation (MWh) of renewable unit j during subperiod tau.\nz^r_j tau: Spilled generation (MWh) of renewable unit j during subperiod tau.","category":"section"},{"location":"centralized_operation_problem.html#Battery-Units-2","page":"Centralized operation problem","title":"Battery Units","text":"s^B_j tau: State of charge (MWh) of battery unit j at the start of subperiod tau.\ng^B_j tau: Generation (MWh) of battery unit j at the end of subperiod tau.\ns^B_j tau: State of charge (MWh) of battery unit j at the end of subperiod tau.\ns^B_in_j: State of charge (MWh) of battery unit j at the start of the period.\ns^B_out_j: State of charge (MWh) of battery unit j at the end of the period.","category":"section"},{"location":"centralized_operation_problem.html#Demands-2","page":"Centralized operation problem","title":"Demands","text":"delta_j tau: Demand deficit (GWh) of demand j during subperiod tau.\ndelta^F_j tau: Demand curtailment (GWh) of demand j during subperiod tau.\nd^F_j tau: Flexible demand to be attended (GWh) of demand j during subperiod tau.\nd^E_j tau: Elastic demand to be attended (GWh) of demand j during subperiod tau.","category":"section"},{"location":"centralized_operation_problem.html#Interconnections","page":"Centralized operation problem","title":"Interconnections","text":"f^I_j tau: Flow (MW) of interconnection j during subperiod tau.","category":"section"},{"location":"centralized_operation_problem.html#Transmission-Lines","page":"Centralized operation problem","title":"Transmission Lines","text":"f_j tau: Flow (MW) of line j during subperiod tau.","category":"section"},{"location":"centralized_operation_problem.html#Network-Nodes","page":"Centralized operation problem","title":"Network Nodes","text":"theta_n tau: Voltage angle (rad) at node n during subperiod tau.","category":"section"},{"location":"centralized_operation_problem.html#Subproblem-Constraints","page":"Centralized operation problem","title":"Subproblem Constraints","text":"The following constraints are defined for a subproblem at period t and scenario omega.","category":"section"},{"location":"centralized_operation_problem.html#Demand-Balance-(Zonal)","page":"Centralized operation problem","title":"Demand Balance (Zonal)","text":"    C_MW rightarrow GW  bigg(\n    sum_j in J^T(z)g^T_j tau\n    + sum_j in J^H(z)g^H_j tau\n    + sum_j in J^R(z)g^R_j tau\n    + sum_j in J^B(z)g^B_j tau \n    + sum_l in I^in(z)f^I_l tau cdot d(tau) \n    - sum_l in I^out(z)f^I_l tau cdot d(tau) bigg)\n    + sum_j in J^DI(z)delta_j tau\n    = sum_j in J^DI(z)D_j tau omega\n    + sum_j in J^DF(z)d^F_j tau\n    + sum_j in J^DE(z)d^E_j tau\n    quad forall z in Z tau in B(t)","category":"section"},{"location":"centralized_operation_problem.html#Demand-Balance-(Nodal)","page":"Centralized operation problem","title":"Demand Balance (Nodal)","text":"    C_MW rightarrow GW  bigg(\n    sum_j in J^T(n)g^T_j tau\n    + sum_j in J^H(n)g^H_j tau\n    + sum_j in J^R(n)g^R_j tau\n    + sum_j in J^B(n)g^B_j tau \n    + sum_l in L^in(n)f_l tau cdot d(tau) \n    - sum_l in L^out(n)f_l tau cdot d(tau) bigg)\n    + sum_j in J^DI(n)delta_j tau\n    = sum_j in J^DI(n)D_j tau omega\n    + sum_j in J^DF(n)d^F_j tau \n    + sum_j in J^DE(n)d^E_j tau\n    quad forall n in N tau in B(t)","category":"section"},{"location":"centralized_operation_problem.html#Demand-shift-bounds","page":"Centralized operation problem","title":"Demand shift bounds","text":"    (1 - underlined^F_j) cdot D_j tau omega\n    leq d^F_j tau + delta_j tau\n    leq (1 + overlined^F_j) cdot D_j tau omega\n    quad forall j in J^DF tau in B(t)","category":"section"},{"location":"centralized_operation_problem.html#Demand-window-sum","page":"Centralized operation problem","title":"Demand window sum","text":"    sum_tau in B(j t w) (d^F_j tau + delta^F_j tau)\n    = sum_tau in B(j t w) ( D_j tau omega - delta_j tau )\n    quad forall j in J^DF w in W_j t","category":"section"},{"location":"centralized_operation_problem.html#Demand-window-maximum-curtailment","page":"Centralized operation problem","title":"Demand window maximum curtailment","text":"    sum_tau in B(j t w) delta^F_j tau\n    leq sum_tau in B(j t w) overlinedelta^F_j D_j tau omega\n    quad forall j in J^DF w in W_j t","category":"section"},{"location":"centralized_operation_problem.html#Hydro-Balance","page":"Centralized operation problem","title":"Hydro Balance","text":"","category":"section"},{"location":"centralized_operation_problem.html#Intra-period-balance","page":"Centralized operation problem","title":"Intra-period balance","text":"    v_j tau+1 = v_j tau - u_j tau - z_j tau\n    + sum_n in J^H_U(j)u_n tau \n    + sum_n in J^H_Z(j)z_n tau +  a_j tau + a^S_j tau \n    quad forall j in J^H tau in B(t)","category":"section"},{"location":"centralized_operation_problem.html#Inter-period-balance","page":"Centralized operation problem","title":"Inter-period balance","text":"    v^S_in_j = v_j 1\n    quad forall j in J^H\n\n    v^S_out_j = v_j B(t) + 1\n    quad forall j in J^H","category":"section"},{"location":"centralized_operation_problem.html#Initial-and-final-volume-of-run-of-river-hydro-units","page":"Centralized operation problem","title":"Initial and final volume of run of river hydro units","text":"    v_j 1 = v_j B(t) + 1\n    quad forall j in J^HRR","category":"section"},{"location":"centralized_operation_problem.html#Hydro-Generation","page":"Centralized operation problem","title":"Hydro Generation","text":"    g^H_j tau = rho_j u_j tau C_hm^3h rightarrow m^3s\nquad forall j in J^H tau in B(t)","category":"section"},{"location":"centralized_operation_problem.html#Hydro-Minimum-Outflow","page":"Centralized operation problem","title":"Hydro Minimum Outflow","text":"    u_j tau + z_j tau + eta_j tau geq O_j cdot d(tau) cdot C_m^3s rightarrow hm^3h\n    quad forall j in J^H tau in B(t)","category":"section"},{"location":"centralized_operation_problem.html#Thermal-Commitment","page":"Centralized operation problem","title":"Thermal Commitment","text":"    y^T_j tau - w^T_j tau = x^T_j tau - x^T_j tau-1\n    quad forall j in J^TC tau in B(t)\n\n    y^T_j tau + w^T_j tau leq x^T_j tau + x^T_j tau-1\n    quad forall j in J^TC tau in B(t)\n\n    y^T_j tau + w^T_j tau + x^T_j tau + x^T_j tau-1 leq 2\n    quad forall j in J^TC tau in B(t)","category":"section"},{"location":"centralized_operation_problem.html#Thermal-Ramping","page":"Centralized operation problem","title":"Thermal Ramping","text":"    g^T_j tau - g^T_j tau-1 leq Delta^up_j cdot C_1h rightarrow 1min cdot fracd(tau)+d(tau-1)2\n    quad forall j in J^T tau in B(t)\n\n    g^T_j tau-1 - g^T_j tau leq Delta^down_j cdot C_1h rightarrow 1min cdot fracd(tau)+d(tau-1)2\n    quad forall j in J^T tau in B(t)","category":"section"},{"location":"centralized_operation_problem.html#Thermal-Minimum-Up/Down-Time","page":"Centralized operation problem","title":"Thermal Minimum Up/Down Time","text":"Based on the initial conditions t^up_j0 and t^down_j0, the following terms are defined:\n\n    I^up_j tau =\n    begincases\n        1  textif  t = 1 text and  t^up_j 0 + sum_gamma = 1^tau - 1d(gamma)  UT^min_j \n        0  textotherwise\n    endcases\n    quad forall j in J^TC tau in B(t)\n\n    I^down_j tau =\n    begincases\n        1  textif  t = 1 text and  t^down_j 0 + sum_gamma = 1^tau - 1d(gamma)   DT^min_j \n        0  textotherwise\n    endcases\n    quad forall j in J^TC tau in B(t)\n\nThe indicators I^up and I^down represent whether the plant started/stopped in the previous period AND has yet to reach the minimum uptime/downtime. Also, the following auxiliar terms are defined:\n\n    Gamma^UT^min_j tau = min left gamma in B(t) Bigvert sum_kappa = gamma^tau-1d(kappa)  UT^min_j  right\n\n    Gamma^DT^min_j tau = min left gamma in B(t) Bigvert sum_kappa = gamma^tau-1d(kappa)  DT^min_j  right\n\nWith these terms, the following constraints are defined:\n\n    left(sum_gamma = Gamma^UT^min_j tau^tauy^T_j gammaright) + I^up_j tau leq x^T_j tau  \n    quad forall j in J^TC tau in B(t)\n\n    left(sum_gamma= Gamma^DT^min_j tau^tauw^T_j gammaright) + I^down_j tau leq 1 - x^T_j tau \n    quad forall j in J^TC tau in B(t)\n\nFor the uptime, the constraint states that if the plant started in the last UT^min_j hours or if the indicator I^up_j tau is active, then the plant must remain active. The same logic applies to the downtime.","category":"section"},{"location":"centralized_operation_problem.html#Thermal-Maximum-Uptime","page":"Centralized operation problem","title":"Thermal Maximum Uptime","text":"Based on the initial condition t^up_j0 and the UT^max parameter, the following terms are defined:\n\n    T^up_j tau =\n    begincases\n        t^up_j 0      textif  t^up_j 0 + sum_gamma = 1^tau - 1d(gamma) leq UT^max_j \n        UT^max_j - sum_gamma = 1^tau - 1d(gamma)  textif  sum_gamma = 1^tau - 1d(gamma) leq UT^max_j               \n        0                  textotherwise\n    endcases\n    quad forall j in J^TC tau in B(t)\n\n     Gamma^UT^max_j tau = min left gamma in B(t) Bigvert sum_kappa = gamma^tau-1d(kappa) leq UT^max_j  right\n\nFor a time window of UT^max_j hours before the beginning of subperiod tau, the term T^up_j tau represents the amount of hours that the plant has been active in the period before. The term Gamma^UT^max_j tau indicates the first subperiod in the current period that is within the time window of UT^max_j hours before the current subperiod tau. \n\nWith these terms, the following constraint is defined:\n\n    left(sum_gamma=Gamma^UT^max_j tau^taud(tau) cdot x^T_j gammaright) + T^up_j tau leq UT^max_j\n    quad forall j in J^TC tau in B(t)\n\nThe constraint states that the amount of time that the plant has been active in the last UT^max_j hours plus the time that the plant is active in the current subperiod must be less than or equal to UT^max_j.","category":"section"},{"location":"centralized_operation_problem.html#Renewable-Balance","page":"Centralized operation problem","title":"Renewable Balance","text":"    g^R_j tau + z^r_j tau = G^R_j tau(omega)cdot G^R_j cdot d(tau)\n    quad forall j in J^R tau in B(t)","category":"section"},{"location":"centralized_operation_problem.html#Battery-Unit-Balance","page":"Centralized operation problem","title":"Battery Unit Balance","text":"","category":"section"},{"location":"centralized_operation_problem.html#Intra-period-balance-2","page":"Centralized operation problem","title":"Intra-period balance","text":"    s^B_j tau+1 = s^B_j tau - g^B_j tau\n    quad forall j in J^B tau in B(t)","category":"section"},{"location":"centralized_operation_problem.html#Inter-period-balance-2","page":"Centralized operation problem","title":"Inter-period balance","text":"    s^B_in_j = s^B_j 1\n    quad forall j in J^B\n\n    s^B_out_j = s^B_j B(t) + 1\n    quad forall j in J^B","category":"section"},{"location":"centralized_operation_problem.html#Kirchhoff's-Voltage-Law","page":"Centralized operation problem","title":"Kirchhoff's Voltage Law","text":"When considering the compact version of the power flow, the following constraints can be omitted and the voltage angles are not decision variables.\n\n    frac-1X_j (theta_n^to_j tau - theta_n^from_j tau) = f_j tau quad\n    forall j in L^AC tau in B(t)","category":"section"},{"location":"centralized_operation_problem.html#Hydro-Bounds","page":"Centralized operation problem","title":"Hydro Bounds","text":"","category":"section"},{"location":"centralized_operation_problem.html#Volume-bounds","page":"Centralized operation problem","title":"Volume bounds","text":"    0 leq v_j tau leq V_j quad\n    forall j in J^H tau = 1  B(t) + 1","category":"section"},{"location":"centralized_operation_problem.html#Commitment-plants","page":"Centralized operation problem","title":"Commitment plants","text":"    underlineG^H_j x^H_j taucdot d(tau) leq g^H_j tau leq overlineG^H_j x^H_j taucdot d(tau)\n     quad forall j in J^HC tau in B(t)","category":"section"},{"location":"centralized_operation_problem.html#Other-bounds","page":"Centralized operation problem","title":"Other bounds","text":"    0 leq u_j tau leq U_j cdot d(tau) cdot C_m^3s rightarrow hm^3h quad\n    z_j tau geq 0  quad\n    eta_j tau geq 0 quad\n    0 leq g^H_j tau leq overlineG^H_jcdot d(tau) \n    forall j in J^H tau in B(t)","category":"section"},{"location":"centralized_operation_problem.html#Thermal-Bounds","page":"Centralized operation problem","title":"Thermal Bounds","text":"","category":"section"},{"location":"centralized_operation_problem.html#Commitment-plants-2","page":"Centralized operation problem","title":"Commitment plants","text":"    underlineG^T_j x^T_j taucdot d(tau) leq g^T_j tau leq overlineG^T_j x^T_j taucdot d(tau)\n     quad forall j in J^TC tau in B(t)","category":"section"},{"location":"centralized_operation_problem.html#Other-plants","page":"Centralized operation problem","title":"Other plants","text":"    underlineG^T_jcdot d(tau) leq g^T_j tau leq overlineG^T_jcdot d(tau) quad\n    forall j in J^T setminus J^TC tau in B(t)","category":"section"},{"location":"centralized_operation_problem.html#Renewable-bounds","page":"Centralized operation problem","title":"Renewable bounds","text":"    0 leq g^R_j tau quad\n    0 leq z^r_j tau quad\n    forall j in J^R tau in B(t)","category":"section"},{"location":"centralized_operation_problem.html#Battery-Unit-bounds","page":"Centralized operation problem","title":"Battery Unit bounds","text":"    -G^B_j cdot d(tau) leq g^B_j tau leq G^B_j cdot d(tau) quad\n    underlines^B_j leq s^B_j tau leq overlines^B_j quad\n    forall j in J^B tau in B(t)","category":"section"},{"location":"centralized_operation_problem.html#Transmission-Bounds","page":"Centralized operation problem","title":"Transmission Bounds","text":"","category":"section"},{"location":"centralized_operation_problem.html#Interconnections-2","page":"Centralized operation problem","title":"Interconnections","text":"    -overlinef^Z from_j leq f^I_j tau leq overlinef^Z to_j quad\n    forall j in I tau in B(t)","category":"section"},{"location":"centralized_operation_problem.html#DC-Lines-2","page":"Centralized operation problem","title":"DC Lines","text":"    -overlinef^from_j leq f_j tau leq overlinef^to_j quad\n    forall j in L^DC tau in B(t)","category":"section"},{"location":"centralized_operation_problem.html#Branches-2","page":"Centralized operation problem","title":"Branches","text":"When the complete DC power flow formulation is considered, the flow limits are given by:\n\n    -overlinef_j leq f_j tau leq overlinef_j quad\n    forall j in L^AC tau in B(t)\n\nWhereas the compact form of the power flow considers the flow limits as:\n\n    -overlinef_j leq sum_n in N^-refbeta_j n cdot (sum_l in L^out(n)f_l tau - sum_l in L^in(n)f_l tau) leq overlinef_j quad\n    forall j in L^AC tau in B(t)\n\nWhere beta is the branch flow sensitivity matrix, that can be calculated using the data from the nodes and branches.\n\n    beta = Gamma A^T(A Gamma A^T)^-1\n\nThe matrix A is the reduced incidence matrix and Gamma is the diagonal matrix with the susceptance of each branch of the system.\n\nThe incidence matrix defines the connections between the network nodes and branches. It has the node indices as the matrix rows, and the branch indices as the matrix columns. The elements are 1 in the intersection of a from node row and the branch column, -1 in the intersection of a to node row and the branch column, and 0 otherwise, i.e., when the node column does not belong to the branch column. Finally, the reduced incidence matrix is given by the elimination of the row corresponding to the reference node in the original incidence matrix.","category":"section"},{"location":"centralized_operation_problem.html#Demand-Deficit-Bounds","page":"Centralized operation problem","title":"Demand Deficit Bounds","text":"    delta_j tau geq 0 quad\n    forall j in J^D tau in B(t)","category":"section"},{"location":"centralized_operation_problem.html#Attended-Elastic-Demand-Bounds","page":"Centralized operation problem","title":"Attended Elastic Demand Bounds","text":"    0 leq d^E_j tau leq D_j tau omega quad\n    forall j in J^DE tau in B(t)","category":"section"},{"location":"centralized_operation_problem.html#Objective-Function","page":"Centralized operation problem","title":"Objective Function","text":"textmin quad C_ rightarrow k sum_tau in B(t) Bigg(\n    C_GW rightarrow MW bigg( sum_j in J^D C^delta delta_j tau\n    + sum_j in J^DF C^delta^F_j tau delta^F_j tau\n    - sum_j in J^DE P_j tau(omega) d^E_j tau bigg) \n    + sum_j in J^B C^S_j s^B_j tau \n    + sum_j in J^H left( C^eta eta_j tau  + C^z z_j tau right)\n    + sum_j in J^T left( C^T_up_j y^T_j tau\n    + C^T_down_j w^T_j tau right) \n    +  sum_j in J^T C^T_j g^T_j tau\n    + sum_j in J^R C^Rz_j z^r_j tau + sum_j in J^R C^R_j g^R_j tau \n    Bigg)","category":"section"},{"location":"conceptual_formulation.html#Conceptual-Formulation","page":"Conceptual formulations","title":"Conceptual Formulation","text":"There are four possible representations for how the individual units can be represented within each optimization problem:\n\nThe cost-based paradigm\nThe bid-based paradigm\nThe hybrid paradigm\nThe virtual reservoir hybrid paradigm\n\nThis page describes conceptually each of these paradigms, by first introducing the notation and then gradually building up intuition:\n\nFirst, we present a simple contrast between the cost-based paradigm representation and the bid-based paradigm representation, in a simplified version of the optimization problem\nThen, we introduce a more general version, in which each bidding group in the system can be classified between bid-based, cost-based, or hybrid in terms of its representation\nThen, we introduce additional complexities and show that most intuitions from the previous representation remain valid\nFinally, we introduce the virtual reservoir representation.\n\nNote that the formulations presented in this page abstract away the specific features of the cost-based representation of units, which involve (for example) reservoir management decision variables for hydro power plants and startup decision variables for thermal power plants; as well as the specific features of the bid-based representation of bidding groups, which are characterized by independent bids, profile bids, complementarity sets, minimum activation constraints, and precedence constraints. More detailed information is available in the linked pages.","category":"section"},{"location":"conceptual_formulation.html#Base-notation","page":"Conceptual formulations","title":"Base notation","text":"The following notation will be used throughout the problems introduced in this page:\n\nIndices and associated sets:\nPhysical units i in mathcalI\nBidding groups j in mathcalJ\nDecision-making agents a in mathcalA\nVirtual reservoirs r in mathcalR\nNetwork buses n in mathcalN\nSubperiods t in mathcalT\nPrimal decision variables and associated feasibility sets:\nGeneral system operator's flexible choices x in mathcalX\nPhysical unit's operating decisions y_i in mathcalY_i\nBidding Group's activation decisions q_j in mathcalQ_j\nVirtual reservoir account's activation decisions w_ra in mathcalW_ra\nOther input data:\nUnit production function Q_i(y_i)\nUnit cost function C^Y_i(y_i)\nBidding group cost function C^Q_j(q_j)\nVirtual reservoir cost function C^W_ra(w_ra)\nA small weighing parameter epsilon\nVirtual reservoir aggregation function W\nDual variables:\nDemand marginal price pi\nVirtual reservoir marginal price mu\n\nNote that the information that is submitted by a bidding agent to the system operator (in a bid-based or in a hybrid representation) constitutes of a feasibility set mathcalQ and a cost function C^Q, in each case for each of the bidding groups that are under the control of agent a. In a virtual reservoir hydrid representation, information is submitted per \"virtual reservoir account\", which is characterized by both a virtual reservoir r and a bidding agent a.","category":"section"},{"location":"conceptual_formulation.html#A-simple-contrast","page":"Conceptual formulations","title":"A simple contrast","text":"","category":"section"},{"location":"conceptual_formulation.html#The-cost-based-representation","page":"Conceptual formulations","title":"The cost-based representation","text":"For an initial exercise, we will write two problem formulations, one cost-based and one bid-based, and highlight the contrasts between the two. In addition to assuming fully coherent representations (i.e. all units are represented as bid-based or all units are represented as cost-based), for the moment we will also consider that there is only one bus and only one subperiod represented, thus omitting the indices n and t.\n\nFirst we introduce the standard formulation for the cost-based problem. Note that the decision variables are y_i for each unit i in mathcalI, and that the production function Q_i is used to represent both produced quantities (if Q_i0) and consumed quantities (if Q_i0). Therefore, the last constraint represented in the optimization problem below represents the supply-demand balance, and the associated dual variable pi represents the marginal cost of demand.\n\nIn the optimization problem below, the objective function applies the cost function C^Y_i to the operating decisions y_i for each individual unit. Operating decisions must be feasible, as illustrated by the first constraint (with feasibility sets mathcalY_i), and they must satisfy the supply-demand balance constraint (associated with the dual variable pi).\n\nbegingather*\n    beginaligned\n     min_y  sum_i in mathcalI C^Y_i(y_i)     \n     st quad y_i in mathcalY_i quad forall i in mathcalI \n     sum_i in mathcalI Q_i(y_i) = 0 quad  space pi \n    endaligned\nendgather*\n\nEven though the formulation above is simplified (as in particular it does not allow for the representation of multiple hours or multiple zones), it can easily be refined and it already highlights the key features that are relevant for the contrast with other alternative representations presented below. ","category":"section"},{"location":"conceptual_formulation.html#The-bid-based-representation","page":"Conceptual formulations","title":"The bid-based representation","text":"The structure of the bid-based problem, as shown below, is similar to the previous version at first glance. Now the decision variables are q_j for each bidding group j in mathcalJ, and the production function is no longer necessary as the balance equation uses quantities q_j directly (although the convention q_j0 for generation and q_j0 for consumption persists). Fundamentally, there are two key distinctions from the previous formulation: the first one is that the agent is now responsible for actively informing mathcalQ_j and C^Q_j rather than assuming a more passive role. The second distinction is that some information could become unavailable to the system operator: not only because y may incorporate richer information than q, but also because multiple units i might be grouped into a single bidding group j.\n\nIn the optimization problem below, the objective function applies the cost function C^Q_j to the operating decisions q_j for each individual bidding group. Operating decisions must be feasible, as illustrated by the first constraint (with feasibility sets mathcalQ_j), and they must satisfy the supply-demand balance constraint (associated with the dual variable pi).\n\nbegingather*\n    beginaligned\n     min_q  sum_j in mathcalJ C^Q_j(q_j)     \n     st quad q_j in mathcalQ_j quad forall j in mathcalJ \n     sum_j in mathcalJ q_j = 0 quad  space pi\n    endaligned\nendgather*\n\nEven with these differences, as long as agents do not have market power and there are no exernalities involved (i.e. the operating decisions from different units only interact to the extent that they influence the balance equation), one can expect that the incentive represented by the price signal pi will encourage the decentralized agents to find the same equilibrium solution as the direct cost-based minimization problem. This is a classic result from the economic literature, although more refined assessments require exploring results without the assumption of no market power.","category":"section"},{"location":"conceptual_formulation.html#The-hybrid-representation","page":"Conceptual formulations","title":"The hybrid representation","text":"Finally, we can introduce the hybrid representation, as shown below. The defining feature of the hybrid representation is that both sets of decision variables, y and q, are present - and as a consequence, there is an additional constraint ensuring the compatibility between the produced quantities as indicated by the two sets of variables. For this additional constraint, we introduce the notation mathcalI^J(j) to represent the units that belong to the bidding group j.\n\nThe structure of the opimization problem below resembles the optimization problems above. Both cost functions (C^Q_j and C^Y_i) appear in the objective function, and both feasibility sets (mathcalQ_j and mathcalY_i) appear as constraints. The third constraint is the supply-demand balance constraint, which could be expressed with either the q_j variables (as represented below) or by applying the production function Q_i(y_i). These two alternative representations are equivalent thanks to the final constraint, which forces equality between q_j and Q_i(y_i) for the units i that belong to biddning group j in the representation.\n\nbegingather*\n    beginaligned\n     min_qy  sum_j in mathcalJ C^Q_j(q_i) + epsilon cdot sum_i in mathcalI C^Y_i(y_i)     \n     st quad q_j in mathcalQ_j quad forall j in mathcalJ \n     quad y_i in mathcalY_i quad forall i in mathcalI \n      sum_j in mathcalJ q_j = 0 quad  space pi \n      sum_i in mathcalI^J(j) Q_i(y_i) = q_j quad forall j in mathcalJ\n    endaligned\nendgather*\n\nIt's also worth noting the role of the parameter epsilon in the formulation above: because epsilon is small, it indicates that the bid-based cost function representation C^Q_j is the chief driver of the objective function, with C^Y_i playing the role of a \"tiebreaker\" between units that are not distinguished otherwise.","category":"section"},{"location":"conceptual_formulation.html#A-mixed-representation","page":"Conceptual formulations","title":"A mixed representation","text":"In practice, it is possible for multiple representations (cost-based, bid-based, and hybrid) to coexist in the same optimization problem. In order to represent this properly, we introduce the following notation:\n\nA partition of the set of all bidding groups can be written as mathcalJ =mathcalJ^C cup mathcalJ^B cup mathcalJ^H: that is, all bidding groups are represented as either cost-based, bid-based, or hybrid.\nWe also define the shorthands mathcalI^C = bigcup_j in mathcalJ^C mathcalI^J(j) and mathcalI^H = bigcup_j in mathcalJ^H mathcalI^J(j): in practice, the sets of all units with a cost-based or hybrid representation are fully determined by mathcalJ^C or mathcalJ^H respectively.\n\nWith this, we reach the following version of the optimization problem. Note that it represents essentially a combination of the three optimization problems above, with some units being represented only with a variable y_i (cost-based), others only via their bidding group's variable q_j (bid-based), and others with both types of variable (hybrid), in accordance with the sets mathcalJ^C mathcalJ^B mathcalJ^H:\n\nbegingather*\n    beginaligned\n     min_qy  sum_j in mathcalJ^B cup mathcalJ^H C^Q_j(q_j) + sum_i in mathcalI^C C^Y_i(y_i) + epsilon cdot sum_i in mathcalI^H C^Y_i(y_i) \n     st quad q_j in mathcalQ_j quad forall j in mathcalJ^B cup mathcalJ^H \n     quad y_i in mathcalY_i quad forall i in mathcalI^C cup mathcalI^H \n      sum_j in mathcalJ^B cup mathcalJ^H q_j = 0 quad  space pi \n      sum_i in mathcalI^J(j) Q_i(y_i) = q_j quad forall j in mathcalJ^H\n    endaligned\nendgather*","category":"section"},{"location":"conceptual_formulation.html#The-virtual-reservoir-representation","page":"Conceptual formulations","title":"The virtual reservoir representation","text":"The virtual reservoir representation is a \"specialized\" version of the hybrid representation, which was designed with features of hydro cascades in mind. When dealing with virtual reservoirs, all units that are associated with virtual reservoirs are automatically removed from their corresponding bidding groups - and therefore the partition of the set of bidding groups remains unchanged, mathcalJ =mathcalJ^C cup mathcalJ^B cup mathcalJ^H. It is, however, necessary to introduce mathcalI^W the set of units that are tied to a virtual reservoir (and note that mathcalI^W cap mathcalI^J(j) = emptyset space forall j in mathcalJ).\n\nThe representation of the optimization problem shown below introduces a single virtual reservoir (thus ommitting the index r in mathcalR) into the flexible problem representation introduced previously. In addition to introducing a new decision variable w associated with the virtual reservoir decisions (note that each agent a in mathcalA can potentially make one such decision), we introduce a new constraint to guarantee the compatibility between the virtual reservoir decisions and the physical decisions y_i, governed by the aggregation function W. This equality constraint is analogous to the constraint used for hybrid representations in general, but because it plays a role in the financial settlements associated with the virtual reservoir mechanism it is highlighted here (with its dual variable mu).\n\nbegingather*\n    beginaligned\n     min_qyw  sum_j in mathcalJ^B cup mathcalJ^H C^Q_j(q_j) + sum_i in mathcalI^C C^Y_i(y_i) + sum_a in mathcalA C^W_a(w_a) + epsilon cdot sum_i in mathcalI^H cup mathcalI^W C^Y_i(y_i) \n     st quad q_j in mathcalQ_j quad forall j in mathcalJ^B cup mathcalJ^H \n     quad y_i in mathcalY_i quad forall i in mathcalI^C cup mathcalI^H cup mathcalI^W\n     quad w_a in mathcalW_a quad forall a in mathcalA\n      sum_j in mathcalJ^B cup mathcalJ^H q_j + sum_i in mathcalI^C cup mathcalI^W Q_i(y_i)= 0 quad  space pi \n      sum_i in mathcalI^J(j) Q_i(y_i) = q_j quad forall j in mathcalJ^H \n      W( y_i _i in mathcalI ) = sum_a w_a quad  space mu\n    endaligned\nendgather*","category":"section"},{"location":"how_to_input_fcf.html#How-to-Input-a-FCF-File","page":"How to Input a FCF File","title":"How to Input a FCF File","text":"Follow these steps to integrate a FCF (Future Cost Function) file into your study:\n\nPrepare the FCF File   Ensure that the FCF file (cuts.json) is available in your study’s input directory.\nLoad the Study   Load your study database using the following command (make sure to replace PATH with your study path):\ndb = IARA.load_study(PATH; read_only = false)\nLink the Time Series File   Link the FCF file (cuts.json) to your study’s configuration using the code snippet below:\nIARA.link_time_series_to_file(\n    db,\n    \"Configuration\";\n    fcf_cuts = \"cuts.json\",\n)\nClose the Study   Once the file is linked, close the database:\nIARA.close_study!(db)\n\nFor a complete working example, refer to the modify_case.jl file in the test/case_01/base_case_simulation directory.","category":"section"},{"location":"how_to_input_fcf.html#Use-cases-for-FCF-Input","page":"How to Input a FCF File","title":"Use cases for FCF Input","text":"Minimum Cost Run: If you have already trained a policy and wish to run a decoupled simulation using that trained policy, you can input an FCF file to ensure that the simulation utilizes the expected cost function.\nClearing Simulations:\nHYBRID: If you are running a clearing simulation with the HYBRID construction type, you may input a FCF file to define the water values for the simulation. This option is enabled when there are virtual reservoirs in the system and the market_clearing_tiebreaker_weight_for_fcf parameter is set to a value greater than zero. In that case, the FCF will be scaled according to the market_clearing_tiebreaker_weight_for_fcf value.\nCOST_BASED: If you are running a clearing simulation with the COST_BASED construction type, inputting an FCF file is mandatory to define the water values for the simulation.\n\ntip: Tip\nIf you are using the HYBRID construction type, providing an FCF file is optional, but strongly recommended. This will help ensure more accurate water values during the simulation.\n\ndanger: Warning\nWhen using the COST_BASED construction type, it is mandatory to input an FCF file. Failure to do so will result in an error during the simulation.","category":"section"},{"location":"tutorial/case_07_modifications_case.html#Modification-Parameters","page":"Modification Parameters","title":"Modification Parameters","text":"The data for this case is available in the folder data/case_7","category":"section"},{"location":"tutorial/case_07_modifications_case.html#Case-overview","page":"Modification Parameters","title":"Case overview","text":"In this tutorial, we will understand an important concept of the IARA package: time series modifications.\n\nIf we take a look at the documentation for the constructor functions such as IARA.add_demand_unit!, IARA.add_thermal_unit!, and IARA.add_hydro_unit!, we can see that they all have a parameter called parameters.\n\nThese parameters are inputted as DataFrames and need to have at least one row, which we can call the registry of the element. This registry is used to define the initial state of the element, and it can be modified in time by adding more rows to the parameters DataFrame.\n\nIn this tutorial we will present a very simple example of how to use modifications parameters. We will create two Thermal Units: Thermal1 and Thermal2.\n\nThe first will exist from the beginning of the case and will have a maximum generation of 20 MW and an O&M cost of 10 $/MWh. The second will not exist at the beginning of the case, but will be ready for use on the 1st of March 2020, with an O&M cost of 5 $/MWh and a maximum generation of 30 MW.\n\nWe expect that the first unit will stop operating after the second unit is ready for use.\n\nHowever, we will add a modification for the first unit on the 1st of April 2020, where it will have a new O&M cost of 3 $/MWh and a maximum generation of 20 MW. This will make the first unit more competitive and it will start operating again.\n\nWe'll start by importing the necessary packages.\n\nusing Dates\nusing DataFrames\nusing IARA\n; #hide\nnothing #hide\n\nWe also need to define a directory to store the case.\n\nconst PATH_MODIFICATIONS_CASE = joinpath(@__DIR__, \"data\", \"case_7\")\n; #hide\n\nnumber_of_periods = 4\nnumber_of_subperiods = 1\nnumber_of_scenarios = 1\nsubperiod_duration_in_hours = [24.0]\ncycle_discount_rate = 0.1\ncycle_duration_in_hours = sum(subperiod_duration_in_hours) * number_of_periods\n; #hide\nnothing #hide\n\nUsing IARA.create_study! we can create a new study. This function will return a database reference that will store all the information about the case.\n\nWe will set the initial date of the case to the 1st of January 2020.\n\ndb = IARA.create_study!(PATH_MODIFICATIONS_CASE;\n    number_of_periods = number_of_periods,\n    number_of_scenarios = number_of_scenarios,\n    number_of_subperiods = number_of_subperiods,\n    subperiod_duration_in_hours = subperiod_duration_in_hours,\n    policy_graph_type = IARA.Configurations_PolicyGraphType.CYCLIC_WITH_NULL_ROOT,\n    number_of_nodes = number_of_periods,\n    cycle_discount_rate = cycle_discount_rate,\n    cycle_duration_in_hours = cycle_duration_in_hours,\n    demand_deficit_cost = 3000.0,\n    initial_date_time = \"2020-01-01\",\n    demand_scenarios_files = IARA.Configurations_UncertaintyScenariosFiles.ONLY_EX_ANTE,\n);\nnothing #hide","category":"section"},{"location":"tutorial/case_07_modifications_case.html#Zone-and-Bus","page":"Modification Parameters","title":"Zone and Bus","text":"IARA.add_zone!(db; label = \"zone_1\")\nIARA.add_bus!(db; label = \"bus_1\", zone_id = \"zone_1\")","category":"section"},{"location":"tutorial/case_07_modifications_case.html#Demand","page":"Modification Parameters","title":"Demand","text":"IARA.add_demand_unit!(db;\n    label = \"dem_1\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0)],\n        existing = [1],\n    ),\n    bus_id = \"bus_1\",\n    max_demand = 1.0,\n)","category":"section"},{"location":"tutorial/case_07_modifications_case.html#Thermal-Units","page":"Modification Parameters","title":"Thermal Units","text":"IARA.add_thermal_unit!(\n    db;\n    label = \"Thermal1\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0), DateTime(\"2020-04-01\")],\n        existing = [1, 1],\n        max_generation = [20.0, 20.0],\n        om_cost = [10.0, 3.0],\n    ),\n    bus_id = \"bus_1\",\n)\n\nIARA.add_thermal_unit!(\n    db;\n    label = \"Thermal2\",\n    parameters = DataFrame(;\n        date_time = [DateTime(0), DateTime(\"2020-03-01\")],\n        existing = [0, 1],\n        max_generation = [0.0, 30.0],\n        om_cost = [5.0, 5.0],\n    ),\n    bus_id = \"bus_1\",\n)","category":"section"},{"location":"tutorial/case_07_modifications_case.html#Time-Series","page":"Modification Parameters","title":"Time Series","text":"Using a text editor, we have created the following CSV files containing time series information about the demand and solar generation:\n\ndemand.csv\n\nYou can find them in the data/case_7 folder.\n\nLet's take a quick look at the demand file using IARA.time_series_dataframe.\n\nIARA.time_series_dataframe(joinpath(PATH_MODIFICATIONS_CASE, \"demand.csv\"))\n\nIARA.link_time_series_to_file(\n    db,\n    \"DemandUnit\";\n    demand_ex_ante = \"demand\",\n)\n; #hide\nnothing #hide","category":"section"},{"location":"tutorial/case_07_modifications_case.html#Closing-the-database","page":"Modification Parameters","title":"Closing the database","text":"Now that we have added all the elements and linked the time series files, we can close the database to run the case with the function IARA.IARA.close_study!.\n\nIARA.close_study!(db)","category":"section"},{"location":"tutorial/case_07_modifications_case.html#Running","page":"Modification Parameters","title":"Running","text":"Before running, let's create a separate folder for execution.\n\nPATH_MODIFICATIONS_CASE_EXECUTION = joinpath(@__DIR__, \"case_7_execution\")\n\nif !isdir(PATH_MODIFICATIONS_CASE_EXECUTION)\n    mkdir(PATH_MODIFICATIONS_CASE_EXECUTION)\nend\n\ncp(PATH_MODIFICATIONS_CASE, PATH_MODIFICATIONS_CASE_EXECUTION; force = true);\nnothing #hide\n\nNow we can run the case with IARA.train_min_cost.\n\nIARA.train_min_cost(PATH_MODIFICATIONS_CASE_EXECUTION)","category":"section"},{"location":"tutorial/case_07_modifications_case.html#Analyzing-the-results","page":"Modification Parameters","title":"Analyzing the results","text":"After running the case, the outputs are saved in the outputs folder inside the case folder. Inside this directory, you will find the raw results and some plots (inside the plots subdirectory).\n\ncase_folder\n ├── outputs\n │    ├── plots\n │    │   └── ...\n │    └── ...\n └── ...\n\nLet's take a look at the thermal generation of the units.\n\n<iframe src=\"case_7_execution\\\\outputs\\\\plots\\\\thermal_generation_all.html\" style=\"height:500px;width:100%;\"></iframe>\n\nAs we can see, the first unit stops operating after the second unit is ready for use, and starts operating again after the modification on the 1st of April 2020.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"market_clearing_problem.html#Market-Clearing-Problem","page":"Market clearing problem","title":"Market Clearing Problem","text":"This problem is defined at period t and scenario omega.","category":"section"},{"location":"market_clearing_problem.html#Sets","page":"Market clearing problem","title":"Sets","text":"Lists new sets, not present in the centralized operation subproblems.\n\nK(i n): Set of segment bids at node n for the asset owner i.\nK^M(i): Set of bid profiles for the asset owner i.\nmathcalK_m(i): Complementary grouping m for the asset owner i.\nJ^VR: Set of virtual reservoirs.\nJ^H_VR: Set of hydro units associated with some virtual reservoir.\nJ^H_VR(r): Set of hydro units associated with virtual reservoir r.\nI^VR(r): Set of asset owners associated with virtual reservoir r.\nK^VR(r i): Set of segment bids at virtual reservoir r for the asset owner i.","category":"section"},{"location":"market_clearing_problem.html#Parameters","page":"Market clearing problem","title":"Parameters","text":"We add the following parameters to the list of parameters of the strategic subproblem:","category":"section"},{"location":"market_clearing_problem.html#Flexible-Bids","page":"Market clearing problem","title":"Flexible Bids","text":"P_i n tau k(omega): Price bid of asset owner i on network node n during subperiod tau, segment k and scenario omega.\nQ_i n tau k(omega): Quantity bid of asset owner i on network node n during subperiod tau, segment k and scenario omega.","category":"section"},{"location":"market_clearing_problem.html#Profile-Bids","page":"Market clearing problem","title":"Profile Bids","text":"P^M_i n k(omega): Price bid of asset owner i on network node n, profile k and scenario omega.\nQ^M_i n tau k(omega): Quantity bid of asset owner i on network node n during subperiod tau, profile k and scenario omega.\nmathcalp(k): Parent profile of profile k.\nX_i k(omega): Minimum activation level of profile k of asset owner i on network node n and scenario omega.","category":"section"},{"location":"market_clearing_problem.html#Virtual-Reservoirs","page":"Market clearing problem","title":"Virtual Reservoirs","text":"P^VR_r i k(omega): Price bid of asset owner i on virtual reservoir r for segment k at scenario omega.\nQ^VR_r i k(omega): Quantity bid of asset owner i on virtual reservoir r for segment k at scenario omega.\nE^in_ri: Energy account of asset owner i on virtual reservoir r at beginning of period.\nzeta_rh: Factor that converts the water volume at hydro unit h, where h in J^H_VR(r), into energy. \ne^inflow_r: Additional energy from inflow water, at virtual reservoir r.\ngamma^VR_ri: Inflow shares of asset owner i at virtual reservoir r. sum_i in I^VR(r) gamma^VR_ri = 1  forall r in J^VR.","category":"section"},{"location":"market_clearing_problem.html#Variables","page":"Market clearing problem","title":"Variables","text":"Lists new variables, not present in the centralized operation subproblems.","category":"section"},{"location":"market_clearing_problem.html#Flexible-Bids-2","page":"Market clearing problem","title":"Flexible Bids","text":"lambda_i n tau k: Linear combination coefficients for segment bid k of asset owner i on network node n during subperiod tau.\nq_i n tau k: Total energy generated by asset owner i on network node n during subperiod tau related to the segment bid k.","category":"section"},{"location":"market_clearing_problem.html#Multi-hour-Bids","page":"Market clearing problem","title":"Multi-hour Bids","text":"lambda^M_i k: Convex combination coefficients for profile k of asset owner i.\nlambda^X_i k: Activation of profile k of asset owner i.\nq^M_i n tau k: Total energy generated by asset owner i on network node n during subperiod tau related to the profile k.","category":"section"},{"location":"market_clearing_problem.html#Virtual-Reservoirs-2","page":"Market clearing problem","title":"Virtual Reservoirs","text":"q^VR_r i k: Total energy generated by asset owner i on virtual reservoir r related to segment bid k.\nE^out_ri: Energy account of asset owner i at virtual reservoir r at the end of the period.","category":"section"},{"location":"market_clearing_problem.html#Subproblem-Constraints","page":"Market clearing problem","title":"Subproblem Constraints","text":"","category":"section"},{"location":"market_clearing_problem.html#Offer-bounds","page":"Market clearing problem","title":"Offer bounds","text":"Flexible Bids\n\n    0 leq lambda_i n  tau k leq 1 quad forall i in I n in N tau in B(t) k in K(i n) \n\nProfile Bids\n\n    0 leq lambda^M_i k leq 1 quad forall i in I k in K^M(i) \n\n    lambda^X_i k in 0 1 quad forall i in I k in K^M(i) \n\nVirtual Reservoirs\n\n    0 leq q^VR_r i k leq Q^VR_r i k(omega) quad forall r in J^VR i in I^VR(r) k in K^VR(r i) ","category":"section"},{"location":"market_clearing_problem.html#Bids-Segment-Curve","page":"Market clearing problem","title":"Bids Segment Curve","text":"Flexible Bids\n\n    q_i n tau k = lambda_i n  tau k Q_i n tau k(omega) quad forall i in I n in N tau in B(t) k in K(i n) \n\nProfile Bids\n\n    q^M_i n tau k = lambda^M_i k Q^M_i n tau k(omega) quad forall i in I n in N tau in B(t) k in K^M(i) ","category":"section"},{"location":"market_clearing_problem.html#Complementarity-Constraints","page":"Market clearing problem","title":"Complementarity Constraints","text":"    sum_k in Klambda^M_i k leq 1 quad forall K in mathcalK_m(i) i in I m in M ","category":"section"},{"location":"market_clearing_problem.html#Precedence-Relationship","page":"Market clearing problem","title":"Precedence Relationship","text":"    lambda^M_i k leq lambda^M_i mathcalp(k) quad forall i in I k in K^M(i) ","category":"section"},{"location":"market_clearing_problem.html#Minimum-Acceptance","page":"Market clearing problem","title":"Minimum Acceptance","text":"   lambda^X_i k X_i k(omega) leq lambda^M_i k leq lambda^X_i k quad forall i in I k in K^M(i) ","category":"section"},{"location":"market_clearing_problem.html#Positive-Final-Account","page":"Market clearing problem","title":"Positive Final Account","text":"E^out_ri = E^in_ri + e^inflow_r cdot gamma^VR_ri - sum_k in K^VR(r i)q^VR_r i k quad forall i in I^VR(r) forall r in J^VR \nE^out_ri ge 0 quad forall i in I^VR(r) forall r in J^VR","category":"section"},{"location":"market_clearing_problem.html#Physical-Virtual-Coupling","page":"Market clearing problem","title":"Physical-Virtual Coupling","text":"The physical-virtual coupling can be done by generation:\n\n    sum_tau in B(t)sum_h in J^H_VR(r)(u_h tau + s_h tau) cdot rho_h cdot C_hm^3h rightarrow m^3s = sum_i in I^VR(r)sum_k in K^VR(r i)q^VR_r i k quad forall r in J^VR\n\nor by volume:\n\n    sum_h in J^H_VR(r) v_h tau^end cdot zeta_rh = sum_i in I^VR(r) left(E^out_ri - sum_k in K^VR(ri) q^VR_rikright) quad forall r in J^VR\n","category":"section"},{"location":"market_clearing_problem.html#Demand-Balance","page":"Market clearing problem","title":"Demand Balance","text":"    sum_i in I sum_k in K(i n)q_i n tau k\n    + sum_i in I sum_k in K^M(i n)q^M_i n tau k\n    + sum_h in J^H_VRg^H_h tau\n    + sum_l in L^in(n)f_l tau\n    - sum_l in L^out(n)f_l tau\n    + sum_j in J^D(n)delta_j tau \n    = sum_j in J^D(n)D_j tau omega\n    quad forall n in N tau in B(t)","category":"section"},{"location":"market_clearing_problem.html#Transmission-Bounds","page":"Market clearing problem","title":"Transmission Bounds","text":"    -F_j tau leq f_j tau leq F_j tau quad\n    forall j in L tau in B(t)","category":"section"},{"location":"market_clearing_problem.html#Demand-Deficit-Bounds","page":"Market clearing problem","title":"Demand Deficit Bounds","text":"    0 leq delta_j tau quad\n    forall j in J^D tau in B(t)","category":"section"},{"location":"market_clearing_problem.html#Convex-combination-bounds","page":"Market clearing problem","title":"Convex combination bounds","text":"    0 leq lambda^WG_r p leq 1 quad forall r in J^VR p in P^WG(r)","category":"section"},{"location":"market_clearing_problem.html#Objective-Function","page":"Market clearing problem","title":"Objective Function","text":"Flexible Bids\n\n    min\n    sum_tau in B(t)\n        sum_n in N\n            sum_i in I sum_k in K(i n)P_i n tau k(omega) q_i n tau k\n        \n    \n    \n\nMulti-hour Bids\n\n    min\n    sum_tau in B(t)\n        sum_n in N\n            sum_i in I sum_k in K^M(i)P^M_i k(omega) q^M_i n tau k\n        \n    \n    \n\nVirtual Reservoirs\n\n    min\n    sum_r in J^VR\n        sum_i in I_VR(r)\n            sum_k in K^VR(r i)P^VR_r i k(omega) q^VR_r i k\n        \n    \n    \n\nHydro Units related to Virtual Reservoirs\n\n    min\n    sum_tau in B(t) sum_h in J^H_VR\n        C^H g^H_h tau\n    \n    \n\nHydro constraints penalty\n\n    min\n    sum_tau in B(t)\n        sum_j in J^H C^eta eta_j tau\n    \n    ","category":"section"},{"location":"heuristic_bids_vr.html#Hydro-reference-curve","page":"Heuristic bids for virtual reservoirs","title":"Hydro reference curve","text":"The hydro reference curve seeks to draw the aggregate bid curve for each virtual reservoir for a given period and scenario, defining price and quantity levels. These results are later used for the heuristic bidding of virtual reservoirs.\n\nThe maximum energy generation in the period and scenario is determined by the amount of stored energy and the turbine limits of the reservoirs. A set of multipliers Theta is defined, ranging uniformly from 0 to 1, and the amount of elements is defined by the user. Each multiplier theta in Theta is applied to the maximum amount of available energy. For each value of the multiplier theta, a single optimization model Z(theta) is run, which returns the quantity q_r^* for each virtual reservoir and the price mu in the scenario considered.\n\nBased on these results, the price and quantity segments corresponding to the multiplier theta are defined for each reservoir r:\n\nmu_r(theta) = mu^*, which represents the price for the multiplier theta.\nq_r(theta) = q_r^* - sum_vartheta in Theta vartheta  thetaq_r(vartheta), which defines the quantity for the multiplier theta. It is the incremental quantity generated by the virtual reservoir r for the multiplier theta, calculated as the difference between the total generation at theta and the total generation at all previous multipliers.\n\nFor each virtual reservoir r, this process generates two vectors: one for the price levels P_r and one for the quantities Q_r. The vectors are ordered in ascending order of price, which is important for constructing the heuristic bid later. The last segment of quantities is extended to reach the total stored energy, as it can be greater than the maximum turbinable energy.\n\nThe variables, constraints, objective function, and parameters of the Z(theta) problem are presented below. Additional symbols are defined in the Market Clearing Problem and Centralized Operation Problem sections.","category":"section"},{"location":"heuristic_bids_vr.html#Sets","page":"Heuristic bids for virtual reservoirs","title":"Sets","text":"Theta: Set of reference curve multipliers.\nC: Set of future cost cutting planes coefficients.","category":"section"},{"location":"heuristic_bids_vr.html#Parameters","page":"Heuristic bids for virtual reservoirs","title":"Parameters","text":"barq_r(omega): Available energy of virtual reservoir r for current period, scenario omega. Calculated as the minimum between the total stored energy at r and the maximum turbinable energy at r considering the period duration: barq_r(omega) = min(sum_i in I^VR(r) E_ri   sum_h in J^H_VR(r) sum_tau in B(t) rho_h cdot U_h cdot d(tau))","category":"section"},{"location":"heuristic_bids_vr.html#Variables","page":"Heuristic bids for virtual reservoirs","title":"Variables","text":"q_r: Total energy generated by virtual reservoir r at period.\nalpha: Future cost.","category":"section"},{"location":"heuristic_bids_vr.html#Objective-Function","page":"Heuristic bids for virtual reservoirs","title":"Objective Function","text":"    min  alpha","category":"section"},{"location":"heuristic_bids_vr.html#Constraints","page":"Heuristic bids for virtual reservoirs","title":"Constraints","text":"","category":"section"},{"location":"heuristic_bids_vr.html#Future-Cost-Cuts","page":"Heuristic bids for virtual reservoirs","title":"Future Cost Cuts","text":"    alpha ge sum_j in J^H_VR m_j cdot v^S_out_j + b quad forall (m b) in C","category":"section"},{"location":"heuristic_bids_vr.html#Physical-Virtual-Coupling","page":"Heuristic bids for virtual reservoirs","title":"Physical-Virtual Coupling","text":"    sum_tau in B(t)sum_h in J^H_VR(r) rho_h u_h tau  = q_r quad forall r in J^VR","category":"section"},{"location":"heuristic_bids_vr.html#Generation-reference","page":"Heuristic bids for virtual reservoirs","title":"Generation reference","text":"    sum_r in J^VR q_r = theta cdot sum_r in J^VR barq_r(omega) quad mu","category":"section"},{"location":"heuristic_bids_vr.html#Non-decreasing-Generation-Reference","page":"Heuristic bids for virtual reservoirs","title":"Non-decreasing Generation Reference","text":"This constraint ensures that the curve of the virtual reservoir generation is non-decreasing, which is essential for keeping the incremental generation quantities non-negative. Generally, this constraint is satisfied by the optimization model, but in degenerate cases, it may not hold. Therefore, we explicitly enforce it.\n\n    q_r(theta) ge q_r(vartheta) quad forall r in J^VR forall vartheta in Theta vartheta  theta\n\n    q_r ge sum_vartheta in Theta vartheta  theta q_r(vartheta)","category":"section"},{"location":"heuristic_bids_vr.html#Hydro-Balance","page":"Heuristic bids for virtual reservoirs","title":"Hydro Balance","text":"    v_j tau+1 = v_j tau - u_j tau - z_j tau\n    + sum_n in J^H_U(j)u_n tau \n    + sum_n in J^H_Z(j)z_n tau +  a_j tau + a^S_j tau \n    quad forall j in J^H_VR tau in B(t)\n\n    v^S_in_j = v_j 1\n    quad forall j in J^H\n\n    v^S_out_j = v_j B(t) + 1\n    quad forall j in J^H","category":"section"},{"location":"heuristic_bids_vr.html#Heuristic-bid-for-virtual-reservoir","page":"Heuristic bids for virtual reservoirs","title":"Heuristic bid for virtual reservoir","text":"For each asset owner i in the virtual reservoir r, the heuristic bid is constructed based on the hydro reference curve Q_r g P_rg_g in G, the pairs of reference and markup (s_if m_if)_f in F^AO(i), the purchase discount rate o_i, and the energy accounts E^in_r.\n\nThe available parameters for the heuristic bid are either input data or results from the market clearing problem. They are defined as follows:\n\nF^AO(i): Set of risk factors for asset owner i.\nG: Set of points on the hydro reference curve.\ns_if: Maximum account share at which the risk factor p_if is applied for asset owner i, with s_if  s_if+1, s_i1  0, and s_i F^AO(i) = 1.\nm_if: Risk factor for asset owner i at level f.\no_i: Purchase discount rate for asset owner i.\nE^in_ri: Energy account of asset owner i in virtual reservoir r.\nP_r g: Price at point g of the hydro reference curve for virtual reservoir r.\nQ_r g: Quantity at point g of the hydro reference curve for virtual reservoir r.\n\nThe calculation of the heuristic bid for virtual reservoir r can be split into three steps:\n\nAdjusting the pairs of reference and markup (s_if m_if)_f in F^AO(i) into pairs of energy quantity and markup (s_if m_if)_f in F^AO(i).\nAdjusting the hydro reference curve for each asset owner i, based on the energy accounts.\nApplying the adjusted markup vectors to the adjusted hydro reference curve to obtain the heuristic bid for asset owner i.","category":"section"},{"location":"heuristic_bids_vr.html#Adjust-markup-vectors-for-asset-owner-i","page":"Heuristic bids for virtual reservoirs","title":"Adjust markup vectors for asset owner i","text":"The markup vectors for asset owner i form a set of pairs (s_if m_if)_f in F^AO(i), where s_if is the maximum share of the energy account at which the risk factor m_if is applied. The image below illustrates the markup vectors for an asset owner, where (s_if m_if)_f in F^AO(i) = (01 03) (06 005) (10 -02). The risk factor curve decreases as the share increases, meaning that when the agent holds a smaller amount of water, it is valued higher. However, as the share increases, the value of the water decreases.\n\n(Image: Risk factor over account share)\n\nWe aim to understand the relationship between energy bid and the risk factor by examining how the energy bid influences the share of the energy account. As the energy bid increases, the share of the energy account may decrease. In this context, the risk factor is dynamic and varies depending on the energy bid and the consequential share of the energy account. The following calculated parameters are used:\n\nE_ri: Energy account of asset owner i in virtual reservoir r, considering the initial energy account and the inflow, E_ri = E^in_ri + e^inflow_r cdot gamma^VR_ri, where e^inflow_r is the inflow energy of virtual reservoir r and gamma^VR_ri is the inflow share of asset owner i in virtual reservoir r.\nT: Sum of the energy accounts of all asset owners in the virtual reservoir r, T = sum_i in I^VR(r) E_ri.\nS_i: Share of the energy account of asset owner i in the virtual reservoir r, calculated as S_i = fracE_riT.\nj_S_i: Index of the first risk factor above the share S_i of asset owner i. j_S_i = minf mid s_if ge S_i.\nn_i: Number of risk factors for asset owner i, n_i = F^AO(i).\n\nThe energy account share as a function of the energy bid is s(q) = fracE_ri - qT = S_i - fracqT.\n\nFor our example, considering S_i = 10, T=125, the image below shows the graph of the function.\n\n(Image: Account share over energy bid)\n\nIf f(s) is the risk factor as a function of the share s, then f(s(q)) will give us the risk factor as a function of the energy bid q. Intuitively, we take the graph of the function f(s), mirror it on a vertical axis so the domain remains the same, stretch it to the right by a factor of T, and then shift it to the left by T - E_ri. The image below shows the graph of the function f(s(q)) for our example.\n\n(Image: Risk factor over energy bid)\n\nAdditionally, for the negative side of the energy bid, we apply the purchase discount rate o_i to the risk factor, which is o_i = 01 in our example. The image below shows the final graph of the risk factor as a function of the energy bid for our example.\n\n(Image: Risk factor over energy bid discounted)\n\nThe pair of vectors m s representing the risk factors and the energy bid segments for asset owner i are defined as follows:\n\n(s_if m_if)_f in F^AO(i) = beginbmatrix\n    -(s_i n_i - s_n-1) cdot T   m_i n_i - o_i \n    -(s_i n_i-1 - s_n-1) cdot T   m_i n_i-1 - o_i \n    vdots   vdots \n    -(s_i j_S_i+1 - s_i j_S_i) cdot T   m_i j_S_i+1 - o_i \n    -(s_i j_S_i - S_i) cdot T   m_i j_S_i - o_i \n    (S_i -  s_i j_S_i-1) cdot T   m_i j_S_i \n    (s_i j_S_i-1 -  s_i j_S_i-2) cdot T   m_i j_S_i-1 \n    vdots   vdots \n    (s_i 2 -  s_i 1) cdot T   m_i 2 \n    (s_i 1 -  0) cdot T   m_i 1 \nendbmatrix\n\nNote that the energy bid segment (s_if) represents the length of the corresponding segment in the graph. This way, for our example, where j_S_i = 3, the pair of vectors for asset owner i is s_if = -25 25 625 125 and m_if = -03 -02 005 03.","category":"section"},{"location":"heuristic_bids_vr.html#Adjust-hydro-reference-curve-for-asset-owner-i","page":"Heuristic bids for virtual reservoirs","title":"Adjust hydro reference curve for asset owner i","text":"The hydro reference curve for virtual reservoir r is defined as a set of points G_r = (Q_rg P_rg)_g in G, where Q_rg is the quantity and P_rg is the price at point g. The image below illustrates the hydro reference curve for virtual reservoir r.\n\n(Image: Reference curve)\n\nWe want to adjust the hydro reference curve for asset owner i to let it be proportional to the energy account of asset owner i: \n\nq_rig = Q_rg cdot S_i\n\nAlso, we want to have a price for buying energy, so we extend the hydro reference curve to the negative side of the energy bid. This is done by adding a segment with the same price as the first point of the hydro reference curve, but with a quantity equal to the negative difference between the energy account of asset owner i and the sum of energy accounts. This negative segment represents all the available energy that asset owner i can buy from the virtual reservoir r.\n\nq_ri0 = E_ri - T quad textand quad P_ri0 = P_r1\n\nThe image below shows the adjusted hydro reference curve for asset owner i.\n\n(Image: Adjusted reference curve)\n\nThe vectors that represent the adjusted hydro reference curve for asset owner i are defined as follows:\n\n(q_rig P_rig)_g in G =  beginbmatrix\n    E_ri - T   P_r1 \n    Q_r1 cdot S_i   P_r1 \n    Q_r2 cdot S_i   P_r2 \n    vdots   vdots \n    Q_rG-1 cdot S_i   P_rG-1 \n    Q_rG cdot S_i   P_rG \nendbmatrix\n\nwhere G = G cup 0.","category":"section"},{"location":"heuristic_bids_vr.html#Apply-adjusted-markup-vectors-to-adjusted-hydro-reference-curve","page":"Heuristic bids for virtual reservoirs","title":"Apply adjusted markup vectors to adjusted hydro reference curve","text":"Once we have the reference price and the markup for each quantity segment, we can construct the heuristic bid for asset owner i. The image below shows the adjusted hydro reference curve h(q), the adjusted markup curve, shifted 1 unit up, 1 + f(q), and the heuristic bid p(q) = h(q)cdot(1+f(q)). \n\n(Image: Final curve)\n\nTo calculate the vectors that represent the quantity bidding segments for asset owner i, we get the vectors of the adjusted hydro reference curve q_rig and the adjusted markup energy bid segments s_if.\n\nBased on the quantity segments q_rig, we define the segment boundaries Q_rig, where the price P_rig is applied in the interval Q_rig Q_rig+1). The boundaries are defined as follows:\n\nQ^+ = leftsum_g in G g le h q_rigright_h in G q_rih  0 \nQ^- = leftsum_g in G g ge h q_rigright_h in G q_rih  0 \nQ = left Q^- 0 Q^+ right\n\nWe do the same for the adjusted markup segments s_if, defining the boundaries S_if as follows:\n\nS^+ = leftsum_f in F^AO(i) f le h s_ifright_h in F^AO(i) s_ih  0 \nS^- = leftsum_f in F^AO(i) f ge h s_ifright_h in F^AO(i) s_ih  0 \nS = left S^- 0 S^+ right\n\nThis way, the boundaries that represent the quantity bid at the heuristic bid are defined by Q_rik^VR_k in K(r i) =  Q cup S.\n\nTo find the quantity bid of each segment k, we calculate:\n\nq^VR_rik = Q^VR_rik+1 - Q^VR_rik\n\nAnd for the price at the segment k, we calculate as follows:\n\nP^VR_rik =\nmax_g leftP_rig mid Q_g le Q^VR_rikright cdot  left(1+max_fleftm_if mid S_f le Q^VR_rik rightright)","category":"section"},{"location":"heuristic_bids_vr.html#Supply-Security-Agent","page":"Heuristic bids for virtual reservoirs","title":"Supply Security Agent","text":"The Supply Security Agent is a special type of asset owner that acts as a safeguard for the system. If present, the following conditions must be met:\n\nIt must be associated with every virtual reservoir r in the system.\nIt cannot be associated with any bidding group, meaning it does not own any units.\nFor each virtual reservoir r, the inflow share of the supply security agent must be zero, i.e., gamma^VR_r i = 0.\n\nThe role of the supply security agent is to mitigate risks arising from the actions of other asset owners in the virtual reservoir. If the other asset owners in the virtual reservoir r are selling too much energy at a low price, this could deplete the reservoir too quickly, creating a risk of failing to meet future demand. In such cases, the supply security agent will place buying bids at a price higher than or equal to the prices of the other asset owners, effectively increasing its own energy account and reducing the rate at which water is withdrawn from the reservoir.\n\nConversely, if the other asset owners are selling energy at excessively high prices, the supply security agent will place selling bids at lower prices, ensuring fairer prices for consumers.\n\nThe determination of \"too cheap\" and \"too expensive\" is based on the future cost of water, ensuring the agent's actions are aligned with the long-term sustainability of the system, as presented in the hydro reference curve. \n\nTo ensure the supply security agent behaves as expected, the user can either define the markup vectors for the agent’s heuristic bid, as described above, or specify the bids in an external file.","category":"section"},{"location":"tutorial/plots_tutorial.html#Plotting","page":"Plotting","title":"Plotting","text":"The data for this case is available in the folder data/plot\n\nWe'll start by importing the necessary packages.\n\nusing IARA\n; #hide\nnothing #hide\n\nFrom other tutorials, we have seen that IARA.jl automatically generates some plots for the case results. Sometimes, these plots can contain too much information, which can make it hard to understand what is happening. Having this in mind, we can use the IARA.custom_plot function to generate a custom plot, with only the information we want. In this tutorial we will take a look into some examples.","category":"section"},{"location":"tutorial/plots_tutorial.html#Plot-types-overview","page":"Plotting","title":"Plot types overview","text":"The IARA.custom_plot function can generate the following types of plots:\n\nIARA.PlotTimeSeriesAll\nIARA.PlotTimeSeriesStackedMean\nIARA.PlotTimeSeriesQuantiles\nIARA.PlotTechnologyHistogram\nIARA.PlotTechnologyHistogramSubperiod\nIARA.PlotTechnologyHistogramPeriod\nIARA.PlotTechnologyHistogramPeriodSubperiod","category":"section"},{"location":"tutorial/plots_tutorial.html#Creating-a-custom-plot","page":"Plotting","title":"Creating a custom plot","text":"Before anything, we need to define the path to the time series that we are going to plot.\n\npath_volume = joinpath(@__DIR__, \"data\", \"plot\", \"hydro_initial_volume.csv\")\npath_turbining = joinpath(@__DIR__, \"data\", \"plot\", \"hydro_turbining.csv\")\n; #hide\nnothing #hide\n\nLet's start by plotting a time series for the volume of some Hydro Units just like the IARA.jl default plot.\n\nIARA.custom_plot(path_volume, IARA.PlotTimeSeriesAll)\n\nThe plot above shows the volume of the Hydro Units in all scenarios. As the case contains multiple agents, scenarios, periods and subperiods, the plot can be a bit confusing. Let's try to plot just a single scenario.\n\nIARA.custom_plot(path_volume, IARA.PlotTimeSeriesAll; scenario = 1)\n\nNow, let's try to plot the data only for the agent FURNAS.\n\nIARA.custom_plot(path_volume, IARA.PlotTimeSeriesAll; agents = [\"FURNAS\"])\n\nNow we can see the volume of the Hydro Unit FURNAS in all scenarios. This is a bit more clear, but we can still improve it. Let's say that we are only interested in the mean volume of the Hydro Unit FURNAS in all scenarios. We can use the IARA.PlotTimeSeriesQuantiles plot type to generate this plot.\n\nIARA.custom_plot(path_volume, IARA.PlotTimeSeriesQuantiles; agents = [\"FURNAS\"])\n\nNow we have a plot with the mean volume of the Hydro Unit FURNAS in all scenarios. This is a lot more clear than the default plot. We can also specify a range of periods to plot (or even scenarios and subperiods). let's try to plot the first 10 periods.\n\nIARA.custom_plot(\n    path_volume,\n    IARA.PlotTimeSeriesQuantiles;\n    agents = [\"FURNAS\"],\n    period = 1:10,\n)\n\nNow we have a plot with the mean volume of the Hydro Unit FURNAS in the first 10 periods of all scenarios. Let's put a more specific title to the plot.\n\nIARA.custom_plot(\n    path_volume,\n    IARA.PlotTimeSeriesQuantiles;\n    agents = [\"FURNAS\"],\n    period = 1:10,\n    title = \"Volume of FURNAS in the first 10 periods\",\n)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"index.html#IARA:-Interaction-Assessment-between-Regulators-and-Agents","page":"About IARA","title":"IARA: Interaction Assessment between Regulators and Agents","text":"IARA is a computational model that provides the capability to simulate mechanism designs for economic dispatch and price formation in electricity markets. Through hourly simulations of large-scale systems, incorporating uncertainties, and with detailed representation of the physical components of generation, transmission, storage, and consumption, it is possible to assess the impacts on agents and the system of price formation mechanisms based on \"cost,\" \"bid,\" or any hybrid model between the two.","category":"section"},{"location":"index.html#Installation-Guide","page":"About IARA","title":"Installation Guide","text":"IARA.jl is a Julia package that can be installed using the Julia package manager. First, if you do not have Julia installed, you can download it from the official website. If you are using Julia for the first time, you can follow the Getting Started guide.\n\nTo install IARA.jl, you can run the following command in the Julia REPL:\n\nusing Pkg\n\nPkg.add(url=\"https://github.com/psrenergy/IARA.jl\")\n\nThis will install the package and its dependencies. You can then use the package by running:\n\nusing IARA\n\nNow, let's get started on IARA.","category":"section"}]
}
